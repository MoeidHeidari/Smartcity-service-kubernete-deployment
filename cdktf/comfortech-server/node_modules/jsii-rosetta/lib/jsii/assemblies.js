"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findContainingSubmodule = exports.findTypeLookupAssembly = exports.replaceAssembly = exports.allTypeScriptSnippets = exports.allSnippetSources = exports.loadAllDefaultTablets = exports.loadAssemblies = exports.EXAMPLE_METADATA_JSDOCTAG = void 0;
const spec = require("@jsii/spec");
const spec_1 = require("@jsii/spec");
const crypto = require("crypto");
const fs = require("fs-extra");
const path = require("path");
const find_utils_1 = require("../find-utils");
const fixtures_1 = require("../fixtures");
const extract_snippets_1 = require("../markdown/extract-snippets");
const snippet_1 = require("../snippet");
const strict_1 = require("../strict");
const tablets_1 = require("../tablets/tablets");
const util_1 = require("../util");
// eslint-disable-next-line @typescript-eslint/no-var-requires, @typescript-eslint/no-require-imports
const sortJson = require('sort-json');
/**
 * The JSDoc tag users can use to associate non-visible metadata with an example
 *
 * In a Markdown section, metadata goes after the code block fence, where it will
 * be attached to the example but invisible.
 *
 *    ```ts metadata=goes here
 *
 * But in doc comments, '@example' already delineates the example, and any metadata
 * in there added by the '///' tags becomes part of the visible code (there is no
 * place to put hidden information).
 *
 * We introduce the '@exampleMetadata' tag to put that additional information.
 */
exports.EXAMPLE_METADATA_JSDOCTAG = 'exampleMetadata';
/**
 * Load assemblies by filename or directory
 */
function loadAssemblies(assemblyLocations, validateAssemblies) {
    return assemblyLocations.map(loadAssembly);
    function loadAssembly(location) {
        const stat = fs.statSync(location);
        if (stat.isDirectory()) {
            return loadAssembly((0, spec_1.findAssemblyFile)(location));
        }
        const directory = path.dirname(location);
        const pjLocation = path.join(directory, 'package.json');
        const assembly = (0, spec_1.loadAssemblyFromFile)(location, validateAssemblies);
        const packageJson = fs.pathExistsSync(pjLocation) ? fs.readJSONSync(pjLocation, { encoding: 'utf-8' }) : undefined;
        return { assembly, directory, packageJson };
    }
}
exports.loadAssemblies = loadAssemblies;
/**
 * Load the default tablets for every assembly, if available
 *
 * Returns a map of { directory -> tablet }.
 */
async function loadAllDefaultTablets(asms) {
    return (0, util_1.mkDict)(await Promise.all(asms.map(async (a) => [a.directory, await tablets_1.LanguageTablet.fromOptionalFile(guessTabletLocation(a))])));
    function guessTabletLocation(a) {
        const defaultTablet = path.join(a.directory, tablets_1.DEFAULT_TABLET_NAME);
        const compDefaultTablet = path.join(a.directory, tablets_1.DEFAULT_TABLET_NAME_COMPRESSED);
        return fs.existsSync(defaultTablet) ? defaultTablet : compDefaultTablet;
    }
}
exports.loadAllDefaultTablets = loadAllDefaultTablets;
/**
 * Return all markdown and example snippets from the given assembly
 */
function allSnippetSources(assembly) {
    const ret = [];
    if (assembly.readme) {
        ret.push({
            type: 'markdown',
            markdown: assembly.readme.markdown,
            location: { api: 'moduleReadme', moduleFqn: assembly.name },
        });
    }
    for (const [submoduleFqn, submodule] of Object.entries(assembly.submodules ?? {})) {
        if (submodule.readme) {
            ret.push({
                type: 'markdown',
                markdown: submodule.readme.markdown,
                location: { api: 'moduleReadme', moduleFqn: submoduleFqn },
            });
        }
    }
    if (assembly.types) {
        Object.values(assembly.types).forEach((type) => {
            emitDocs(type.docs, { api: 'type', fqn: type.fqn });
            if (spec.isEnumType(type)) {
                type.members.forEach((m) => emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name }));
            }
            if (spec.isClassType(type)) {
                emitDocsForCallable(type.initializer, type.fqn);
            }
            if (spec.isClassOrInterfaceType(type)) {
                (type.methods ?? []).forEach((m) => emitDocsForCallable(m, type.fqn, m.name));
                (type.properties ?? []).forEach((m) => emitDocs(m.docs, { api: 'member', fqn: type.fqn, memberName: m.name }));
            }
        });
    }
    return ret;
    function emitDocsForCallable(callable, fqn, memberName) {
        if (!callable) {
            return;
        }
        emitDocs(callable.docs, memberName ? { api: 'member', fqn, memberName } : { api: 'initializer', fqn });
        for (const parameter of callable.parameters ?? []) {
            emitDocs(parameter.docs, {
                api: 'parameter',
                fqn: fqn,
                methodName: memberName ?? snippet_1.INITIALIZER_METHOD_NAME,
                parameterName: parameter.name,
            });
        }
    }
    function emitDocs(docs, location) {
        if (!docs) {
            return;
        }
        if (docs.remarks) {
            ret.push({
                type: 'markdown',
                markdown: docs.remarks,
                location,
            });
        }
        if (docs.example) {
            ret.push({
                type: 'example',
                source: docs.example,
                metadata: (0, util_1.fmap)(docs.custom?.[exports.EXAMPLE_METADATA_JSDOCTAG], snippet_1.parseMetadataLine),
                location,
            });
        }
    }
}
exports.allSnippetSources = allSnippetSources;
async function allTypeScriptSnippets(assemblies, loose = false) {
    return Promise.all(assemblies
        .flatMap((loaded) => allSnippetSources(loaded.assembly).map((source) => ({ source, loaded })))
        .flatMap(({ source, loaded }) => {
        switch (source.type) {
            case 'example':
                return [
                    {
                        snippet: (0, snippet_1.updateParameters)((0, snippet_1.typeScriptSnippetFromSource)(source.source, { api: source.location, field: { field: 'example' } }, isStrict(loaded)), source.metadata ?? {}),
                        loaded,
                    },
                ];
            case 'markdown':
                return (0, extract_snippets_1.extractTypescriptSnippetsFromMarkdown)(source.markdown, source.location, isStrict(loaded)).map((snippet) => ({ snippet, loaded }));
        }
    })
        .map(async ({ snippet, loaded }) => {
        const isInfused = snippet.parameters?.infused != null;
        // Ignore fixturization errors if requested on this command, or if the snippet was infused
        const ignoreFixtureErrors = loose || isInfused;
        // Also if the snippet was infused: switch off 'strict' mode if it was set
        if (isInfused) {
            snippet = { ...snippet, strict: false };
        }
        snippet = await withDependencies(loaded, withProjectDirectory(loaded.directory, snippet));
        return (0, fixtures_1.fixturize)(snippet, ignoreFixtureErrors);
    }));
}
exports.allTypeScriptSnippets = allTypeScriptSnippets;
/**
 * Replaces the file where the original assembly file *should* be found with a new assembly file.
 * Detects whether or not there is a compressed assembly, and if there is, compresses the new assembly also.
 * Recalculates the fingerprint of the assembly to avoid tampering detection.
 */
function replaceAssembly(assembly, directory) {
    (0, spec_1.writeAssembly)(directory, _fingerprint(assembly), { compress: (0, spec_1.compressedAssemblyExists)(directory) });
}
exports.replaceAssembly = replaceAssembly;
/**
 * This function is copied from `packages/jsii/lib/assembler.ts`.
 * We should make sure not to change one without changing the other as well.
 */
function _fingerprint(assembly) {
    delete assembly.fingerprint;
    assembly = sortJson(assembly);
    const fingerprint = crypto.createHash('sha256').update(JSON.stringify(assembly)).digest('base64');
    return { ...assembly, fingerprint };
}
const MAX_ASM_CACHE = 3;
const ASM_CACHE = [];
/**
 * Recursively searches for a .jsii file in the directory.
 * When file is found, checks cache to see if we already
 * stored the assembly in memory. If not, we synchronously
 * load the assembly into memory.
 */
function findTypeLookupAssembly(startingDirectory) {
    const pjLocation = findPackageJsonLocation(path.resolve(startingDirectory));
    if (!pjLocation) {
        return undefined;
    }
    const directory = path.dirname(pjLocation);
    const fromCache = ASM_CACHE.find((c) => c.directory === directory);
    if (fromCache) {
        return fromCache;
    }
    const loaded = loadLookupAssembly(directory);
    if (!loaded) {
        return undefined;
    }
    while (ASM_CACHE.length >= MAX_ASM_CACHE) {
        ASM_CACHE.pop();
    }
    ASM_CACHE.unshift(loaded);
    return loaded;
}
exports.findTypeLookupAssembly = findTypeLookupAssembly;
function loadLookupAssembly(directory) {
    try {
        const packageJson = fs.readJSONSync(path.join(directory, 'package.json'), { encoding: 'utf-8' });
        const assembly = (0, spec_1.loadAssemblyFromPath)(directory);
        const symbolIdMap = (0, util_1.mkDict)([
            ...Object.values(assembly.types ?? {}).map((type) => [type.symbolId ?? '', type.fqn]),
            ...Object.entries(assembly.submodules ?? {}).map(([fqn, mod]) => [mod.symbolId ?? '', fqn]),
        ]);
        return {
            packageJson,
            assembly,
            directory,
            symbolIdMap,
        };
    }
    catch {
        return undefined;
    }
}
function findPackageJsonLocation(currentPath) {
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const candidate = path.join(currentPath, 'package.json');
        if (fs.existsSync(candidate)) {
            return candidate;
        }
        const parentPath = path.resolve(currentPath, '..');
        if (parentPath === currentPath) {
            return undefined;
        }
        currentPath = parentPath;
    }
}
/**
 * Find the jsii [sub]module that contains the given FQN
 *
 * @returns `undefined` if the type is a member of the assembly root.
 */
function findContainingSubmodule(assembly, fqn) {
    const submoduleNames = Object.keys(assembly.submodules ?? {});
    (0, util_1.sortBy)(submoduleNames, (s) => [-s.length]); // Longest first
    for (const s of submoduleNames) {
        if (fqn.startsWith(`${s}.`)) {
            return s;
        }
    }
    return undefined;
}
exports.findContainingSubmodule = findContainingSubmodule;
function withProjectDirectory(dir, snippet) {
    return (0, snippet_1.updateParameters)(snippet, {
        [snippet_1.SnippetParameters.$PROJECT_DIRECTORY]: dir,
    });
}
/**
 * Return a TypeScript snippet with dependencies added
 *
 * The dependencies will be taken from the package.json, and will consist of:
 *
 * - The package itself
 * - The package's dependencies and peerDependencies
 * - Any additional dependencies declared in `jsiiRosetta.exampleDependencies`.
 */
async function withDependencies(asm, snippet) {
    const compilationDependencies = {};
    compilationDependencies[asm.assembly.name] = {
        type: 'concrete',
        resolvedDirectory: await fs.realpath(asm.directory),
    };
    Object.assign(compilationDependencies, (0, util_1.mkDict)(await Promise.all(Object.keys({ ...asm.packageJson?.dependencies, ...asm.packageJson?.peerDependencies })
        .filter((name) => !(0, find_utils_1.isBuiltinModule)(name))
        .filter((name) => !asm.packageJson?.bundledDependencies?.includes(name) &&
        !asm.packageJson?.bundleDependencies?.includes(name))
        .map(async (name) => [
        name,
        {
            type: 'concrete',
            resolvedDirectory: await fs.realpath(await (0, find_utils_1.findDependencyDirectory)(name, asm.directory)),
        },
    ]))));
    Object.assign(compilationDependencies, (0, util_1.mkDict)(Object.entries(asm.packageJson?.jsiiRosetta?.exampleDependencies ?? {}).map(([name, versionRange]) => [name, { type: 'symbolic', versionRange }])));
    return {
        ...snippet,
        compilationDependencies,
    };
}
/**
 * Whether samples in the assembly should be treated as strict
 *
 * True if the strict flag is found in the package.json (modern) or the assembly itself (legacy).
 */
function isStrict(loaded) {
    return loaded.packageJson?.jsiiRosetta?.strict ?? (0, strict_1.enforcesStrictMode)(loaded.assembly);
}
//# sourceMappingURL=assemblies.js.map