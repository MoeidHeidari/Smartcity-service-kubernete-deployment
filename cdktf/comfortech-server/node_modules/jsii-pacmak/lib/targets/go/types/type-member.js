"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GoParameter = exports.GoMethod = exports.GoProperty = void 0;
const jsii_reflect_1 = require("jsii-reflect");
const naming_util_1 = require("../../../naming-util");
const runtime_1 = require("../runtime");
const util_1 = require("../util");
const index_1 = require("./index");
/*
 * GoProperty encapsulates logic for public properties on a concrete struct, which could represent
 either a JSII class proxy or datatype interface proxy
*/
class GoProperty {
    constructor(parent, property) {
        this.parent = parent;
        this.property = property;
        this.name = (0, naming_util_1.jsiiToPascalCase)(this.property.name);
        this.immutable = property.immutable;
        this.apiLocation = {
            api: 'member',
            fqn: this.parent.fqn,
            memberName: this.property.name,
        };
    }
    get reference() {
        return new index_1.GoTypeRef(this.parent.pkg.root, this.property.type);
    }
    get specialDependencies() {
        return {
            runtime: true,
            init: this.static,
            internal: false,
            time: !!this.reference?.specialDependencies.time,
        };
    }
    get static() {
        return !!this.property.static;
    }
    get returnType() {
        return (this.reference?.scopedReference(this.parent.pkg) ??
            this.property.type.toString());
    }
    get instanceArg() {
        return this.parent.proxyName.substring(0, 1).toLowerCase();
    }
    get override() {
        return `${runtime_1.JSII_RT_ALIAS}.MemberProperty{JsiiProperty: "${this.property.name}", GoGetter: "${this.name}"}`;
    }
    emitStructMember({ code, documenter }) {
        documenter.emit(this.property.docs, this.apiLocation);
        const memberType = this.reference?.type?.name === this.parent.name
            ? `*${this.returnType}`
            : this.returnType;
        const requiredOrOptional = this.property.optional ? 'optional' : 'required';
        // Adds json and yaml tags for easy deserialization
        code.line(`${this.name} ${memberType} \`field:"${requiredOrOptional}" json:"${this.property.name}" yaml:"${this.property.name}"\``);
        // TODO add newline if not the last member
    }
    emitGetterDecl({ code, documenter }) {
        documenter.emit(this.property.docs, this.apiLocation);
        code.line(`${this.name}() ${this.returnType}`);
    }
    emitGetter({ code }) {
        const receiver = this.parent.name;
        const instanceArg = receiver.substring(0, 1).toLowerCase();
        code.openBlock(`func (${instanceArg} *${receiver}) Get${this.name}() ${this.returnType}`);
        code.line(`return ${instanceArg}.${this.name}`);
        code.closeBlock();
    }
    emitSetterDecl({ code, documenter }) {
        if (!this.immutable) {
            // For setters, only emit the stability. Copying the documentation from
            // the getter might result in confusing documentation. This is an "okay"
            // middle-ground.
            documenter.emitStability(this.property.docs);
            code.line(`Set${this.name}(val ${this.returnType})`);
        }
    }
    // Emits getter methods on the struct for each property
    emitGetterProxy(context) {
        const { code } = context;
        const receiver = this.parent.proxyName;
        const instanceArg = receiver.substring(0, 1).toLowerCase();
        code.openBlock(`func (${instanceArg} *${receiver}) ${this.name}() ${this.returnType}`);
        new runtime_1.GetProperty(this).emit(code);
        code.closeBlock();
        code.line();
    }
    emitSetterProxy(context) {
        if (!this.immutable) {
            const { code } = context;
            const receiver = this.parent.proxyName;
            const instanceArg = receiver.substring(0, 1).toLowerCase();
            code.openBlock(`func (${instanceArg} *${receiver}) Set${this.name}(val ${this.returnType})`);
            new runtime_1.SetProperty(this).emit(code);
            code.closeBlock();
            code.line();
        }
    }
}
exports.GoProperty = GoProperty;
class GoMethod {
    constructor(parent, method) {
        this.parent = parent;
        this.method = method;
        this.name = (0, naming_util_1.jsiiToPascalCase)(method.name);
        this.parameters = this.method.parameters.map((param) => new GoParameter(parent, param));
        this.apiLocation =
            method.kind === jsii_reflect_1.MemberKind.Initializer
                ? { api: 'initializer', fqn: parent.fqn }
                : { api: 'member', fqn: parent.fqn, memberName: method.name };
    }
    get reference() {
        if (jsii_reflect_1.Method.isMethod(this.method) && this.method.returns.type) {
            return new index_1.GoTypeRef(this.parent.pkg.root, this.method.returns.type);
        }
        return undefined;
    }
    get returnsRef() {
        if (this.reference?.type?.type.isClassType() ||
            this.reference?.type?.type.isInterfaceType()) {
            return true;
        }
        return false;
    }
    get returnType() {
        return (this.reference?.scopedReference(this.parent.pkg) ?? this.method.toString());
    }
    get instanceArg() {
        return this.parent.name.substring(0, 1).toLowerCase();
    }
    get override() {
        return `${runtime_1.JSII_RT_ALIAS}.MemberMethod{JsiiMethod: "${this.method.name}", GoMethod: "${this.name}"}`;
    }
    paramString() {
        return this.parameters.length === 0
            ? ''
            : this.parameters.map((p) => p.toString()).join(', ');
    }
}
exports.GoMethod = GoMethod;
class GoParameter {
    constructor(parent, parameter) {
        this.name = (0, util_1.substituteReservedWords)(parameter.name);
        this.isVariadic = parameter.variadic;
        this.type = parameter.type;
        this.pkg = parent.pkg;
    }
    get reference() {
        return new index_1.GoTypeRef(this.pkg.root, this.type);
    }
    toString() {
        const paramType = this.reference.scopedReference(this.pkg);
        return `${this.name} ${this.isVariadic ? '...' : ''}${paramType}`;
    }
}
exports.GoParameter = GoParameter;
//# sourceMappingURL=type-member.js.map