"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticMethod = exports.ClassMethod = exports.GoClassConstructor = exports.GoClass = void 0;
const naming_util_1 = require("../../../naming-util");
const comparators = require("../comparators");
const runtime_1 = require("../runtime");
const util_1 = require("../util");
const go_type_1 = require("./go-type");
const go_type_reference_1 = require("./go-type-reference");
const type_member_1 = require("./type-member");
/*
 * GoClass wraps a Typescript class as a Go custom struct type
 */
class GoClass extends go_type_1.GoType {
    constructor(pkg, type) {
        super(pkg, type);
        const methods = new Array();
        const staticMethods = new Array();
        for (const method of type.allMethods) {
            if (method.static) {
                staticMethods.push(new StaticMethod(this, method));
            }
            else {
                methods.push(new ClassMethod(this, method));
            }
        }
        // Ensure consistent order, mostly cosmetic.
        this.methods = methods.sort(comparators.byName);
        this.staticMethods = staticMethods.sort(comparators.byName);
        const properties = new Array();
        const staticProperties = new Array();
        for (const prop of type.allProperties) {
            if (prop.static) {
                staticProperties.push(new type_member_1.GoProperty(this, prop));
            }
            else {
                properties.push(new type_member_1.GoProperty(this, prop));
            }
        }
        // Ensure consistent order, mostly cosmetic.
        this.properties = properties.sort(comparators.byName);
        this.staticProperties = staticProperties.sort(comparators.byName);
        if (type.initializer) {
            this.initializer = new GoClassConstructor(this, type.initializer);
        }
    }
    get extends() {
        // Cannot compute in constructor, as dependencies may not have finished
        // resolving just yet.
        if (this._extends === undefined) {
            this._extends = this.type.base
                ? this.pkg.root.findType(this.type.base.fqn)
                : null;
        }
        return this._extends == null ? undefined : this._extends;
    }
    get implements() {
        // Cannot compute in constructor, as dependencies may not have finished
        // resolving just yet.
        if (this._implements === undefined) {
            this._implements = this.type.interfaces
                .map((iface) => this.pkg.root.findType(iface.fqn))
                // Ensure consistent order, mostly cosmetic.
                .sort((l, r) => l.fqn.localeCompare(r.fqn));
        }
        return this._implements;
    }
    get baseTypes() {
        return [...(this.extends ? [this.extends] : []), ...this.implements];
    }
    emit(context) {
        this.emitInterface(context);
        this.emitStruct(context);
        this.emitGetters(context);
        if (this.initializer) {
            this.initializer.emit(context);
        }
        this.emitSetters(context);
        for (const method of this.staticMethods) {
            method.emit(context);
        }
        for (const prop of this.staticProperties) {
            this.emitStaticProperty(context, prop);
        }
        for (const method of this.methods) {
            method.emit(context);
        }
    }
    emitRegistration(code) {
        code.open(`${runtime_1.JSII_RT_ALIAS}.RegisterClass(`);
        code.line(`"${this.fqn}",`);
        code.line(`reflect.TypeOf((*${this.name})(nil)).Elem(),`);
        const allMembers = [
            ...this.type.allMethods
                .filter((method) => !method.static)
                .map((method) => new ClassMethod(this, method)),
            ...this.type.allProperties
                .filter((property) => !property.static)
                .map((property) => new type_member_1.GoProperty(this, property)),
        ].sort(comparators.byName);
        if (allMembers.length === 0) {
            code.line('nil, // no members');
        }
        else {
            code.open(`[]${runtime_1.JSII_RT_ALIAS}.Member{`);
            for (const member of allMembers) {
                code.line(`${member.override},`);
            }
            code.close('},');
        }
        this.emitProxyMakerFunction(code, this.baseTypes);
        code.close(')');
    }
    get members() {
        return [
            ...(this.initializer ? [this.initializer] : []),
            ...this.methods,
            ...this.properties,
            ...this.staticMethods,
            ...this.staticProperties,
        ];
    }
    get specialDependencies() {
        return {
            runtime: this.initializer != null || this.members.length > 0,
            init: this.initializer != null ||
                this.members.some((m) => m.specialDependencies.init),
            internal: this.baseTypes.some((base) => this.pkg.isExternalType(base)),
            time: !!this.initializer?.specialDependencies.time ||
                this.members.some((m) => m.specialDependencies.time),
        };
    }
    emitInterface(context) {
        const { code, documenter } = context;
        documenter.emit(this.type.docs, this.apiLocation);
        code.openBlock(`type ${this.name} interface`);
        // embed extended interfaces
        if (this.extends) {
            code.line(new go_type_reference_1.GoTypeRef(this.pkg.root, this.extends.type.reference).scopedName(this.pkg));
        }
        for (const iface of this.implements) {
            code.line(new go_type_reference_1.GoTypeRef(this.pkg.root, iface.type.reference).scopedName(this.pkg));
        }
        for (const property of this.properties) {
            property.emitGetterDecl(context);
            property.emitSetterDecl(context);
        }
        for (const method of this.methods) {
            method.emitDecl(context);
        }
        code.closeBlock();
        code.line();
    }
    emitGetters(context) {
        if (this.properties.length === 0) {
            return;
        }
        for (const property of this.properties) {
            property.emitGetterProxy(context);
        }
        context.code.line();
    }
    emitStruct({ code }) {
        code.line(`// The jsii proxy struct for ${this.name}`);
        code.openBlock(`type ${this.proxyName} struct`);
        // Make sure this is not 0-width
        if (this.baseTypes.length === 0) {
            code.line('_ byte // padding');
        }
        else {
            for (const base of this.baseTypes) {
                code.line(this.pkg.resolveEmbeddedType(base).embed);
            }
        }
        code.closeBlock();
        code.line();
    }
    emitStaticProperty({ code }, prop) {
        const getCaller = new runtime_1.StaticGetProperty(prop);
        const propertyName = (0, naming_util_1.jsiiToPascalCase)(prop.name);
        const name = `${this.name}_${propertyName}`;
        code.openBlock(`func ${name}() ${prop.returnType}`);
        getCaller.emit(code);
        code.closeBlock();
        code.line();
        if (!prop.immutable) {
            const setCaller = new runtime_1.StaticSetProperty(prop);
            const name = `${this.name}_Set${propertyName}`;
            code.openBlock(`func ${name}(val ${prop.returnType})`);
            setCaller.emit(code);
            code.closeBlock();
            code.line();
        }
    }
    // emits the implementation of the setters for the struct
    emitSetters(context) {
        for (const property of this.properties) {
            property.emitSetterProxy(context);
        }
    }
    get dependencies() {
        // need to add dependencies of method arguments and constructor arguments
        return [
            ...this.baseTypes.map((ref) => ref.pkg),
            ...(0, util_1.getMemberDependencies)(this.members),
            ...(0, util_1.getParamDependencies)(this.members.filter(isGoMethod)),
        ];
    }
    /*
     * Get fqns of interfaces the class implements
     */
    get interfaces() {
        return this.type.interfaces.map((iFace) => iFace.fqn);
    }
}
exports.GoClass = GoClass;
class GoClassConstructor extends type_member_1.GoMethod {
    constructor(parent, type) {
        super(parent, type);
        this.parent = parent;
        this.type = type;
        this.constructorRuntimeCall = new runtime_1.ClassConstructor(this);
    }
    get specialDependencies() {
        return {
            runtime: true,
            init: true,
            internal: false,
            time: this.parameters.some((p) => p.reference.specialDependencies.time),
        };
    }
    emit(context) {
        // Abstract classes cannot be directly created
        if (!this.parent.type.abstract) {
            this.emitNew(context);
        }
        // Subclassable classes (the default) get an _Overrides constructor
        if (this.parent.type.spec.docs?.subclassable ?? true) {
            this.emitOverride(context);
        }
    }
    emitNew({ code, documenter }) {
        const constr = `New${this.parent.name}`;
        const paramString = this.parameters.length === 0
            ? ''
            : this.parameters.map((p) => p.toString()).join(', ');
        documenter.emit(this.type.docs, this.apiLocation);
        code.openBlock(`func ${constr}(${paramString}) ${this.parent.name}`);
        this.constructorRuntimeCall.emit(code);
        code.closeBlock();
        code.line();
    }
    emitOverride({ code, documenter }) {
        const constr = `New${this.parent.name}_Override`;
        const params = this.parameters.map((p) => p.toString());
        const instanceVar = (0, runtime_1.slugify)(this.parent.name[0].toLowerCase(), params);
        params.unshift(`${instanceVar} ${this.parent.name}`);
        documenter.emit(this.type.docs, this.apiLocation);
        code.openBlock(`func ${constr}(${params.join(', ')})`);
        this.constructorRuntimeCall.emitOverride(code, instanceVar);
        code.closeBlock();
        code.line();
    }
}
exports.GoClassConstructor = GoClassConstructor;
class ClassMethod extends type_member_1.GoMethod {
    constructor(parent, method) {
        super(parent, method);
        this.parent = parent;
        this.method = method;
        this.runtimeCall = new runtime_1.MethodCall(this);
    }
    /* emit generates method implementation on the class */
    emit({ code }) {
        const name = this.name;
        const returnTypeString = this.reference?.void ? '' : ` ${this.returnType}`;
        code.openBlock(`func (${this.instanceArg} *${this.parent.proxyName}) ${name}(${this.paramString()})${returnTypeString}`);
        this.runtimeCall.emit(code);
        code.closeBlock();
        code.line();
    }
    /* emitDecl generates method declaration in the class interface */
    emitDecl({ code, documenter }) {
        const returnTypeString = this.reference?.void ? '' : ` ${this.returnType}`;
        documenter.emit(this.method.docs, this.apiLocation);
        code.line(`${this.name}(${this.paramString()})${returnTypeString}`);
    }
    get instanceArg() {
        return this.parent.name.substring(0, 1).toLowerCase();
    }
    get specialDependencies() {
        return {
            runtime: true,
            init: this.method.static,
            internal: false,
            time: !!this.parameters.some((p) => p.reference.specialDependencies.time) ||
                !!this.reference?.specialDependencies.time,
        };
    }
}
exports.ClassMethod = ClassMethod;
class StaticMethod extends ClassMethod {
    constructor(parent, method) {
        super(parent, method);
        this.parent = parent;
        this.method = method;
    }
    emit({ code, documenter }) {
        const name = `${this.parent.name}_${this.name}`;
        const returnTypeString = this.reference?.void ? '' : ` ${this.returnType}`;
        documenter.emit(this.method.docs, this.apiLocation);
        code.openBlock(`func ${name}(${this.paramString()})${returnTypeString}`);
        this.runtimeCall.emit(code);
        code.closeBlock();
        code.line();
    }
}
exports.StaticMethod = StaticMethod;
function isGoMethod(m) {
    return m instanceof type_member_1.GoMethod;
}
//# sourceMappingURL=class.js.map