"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.toPlanSuccessfully = exports.toBeValidTerraform = exports.getToHaveResourceWithProperties = exports.getToHaveDataSourceWithProperties = exports.asymetricDeepEqualIgnoringObjectCasing = exports.returnMatcherToJest = exports.AssertionReturn = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
const util_1 = require("../util");
const terraformBinaryName = process.env.TERRAFORM_BINARY_NAME || "terraform";
class AssertionReturn {
    constructor(message, pass) {
        this.message = message;
        this.pass = pass;
    }
}
exports.AssertionReturn = AssertionReturn;
_a = JSII_RTTI_SYMBOL_1;
AssertionReturn[_a] = { fqn: "cdktf.testingMatchers.AssertionReturn", version: "0.12.0" };
function returnMatcherToJest(toReturn) {
    return {
        message: () => toReturn.message,
        pass: toReturn.pass,
    };
}
exports.returnMatcherToJest = returnMatcherToJest;
// All expected properties are matched and considered equal if
// There can be more properties in the received object than in the expected object while still returning true
function asymetricDeepEqualIgnoringObjectCasing(expected, received) {
    switch (typeof expected) {
        case "object":
            if (Array.isArray(expected)) {
                return (Array.isArray(received) &&
                    expected.length === received.length &&
                    expected.every((item, index) => asymetricDeepEqualIgnoringObjectCasing(item, received[index]) // recursively compare arrays
                    ));
            }
            if (expected === null && received === null) {
                return true;
            }
            if (expected === undefined && received === undefined) {
                return true;
            }
            if (expected === null || received === null) {
                return false;
            }
            // recursively compare objects and allow snake case as well as camel case
            return Object.keys(expected).every((key) => {
                if (received[key] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[key]);
                }
                if (received[util_1.snakeCase(key)] !== undefined) {
                    return asymetricDeepEqualIgnoringObjectCasing(expected[key], received[util_1.snakeCase(key)]);
                }
                return false;
            });
        default:
            return expected === received;
    }
}
exports.asymetricDeepEqualIgnoringObjectCasing = asymetricDeepEqualIgnoringObjectCasing;
const defaultPassEvaluation = (items, assertedProperties) => {
    return Object.values(items).some((item) => asymetricDeepEqualIgnoringObjectCasing(assertedProperties, item));
};
function isAsymmetric(obj) {
    return !!obj && typeof obj === "object" && "asymmetricMatch" in obj;
}
// You can use expect.Anything(), expect.ObjectContaining, etc in jest, this makes it nicer to read
// when we print error mesages
function jestAsymetricMatcherStringifyReplacer(_key, value) {
    return isAsymmetric(value) ? `expect.${value.toString()}` : value;
}
function getAssertElementWithProperties(
// We have the evaluation function configurable so we can make use of the specific testing frameworks capabilities
// This makes the resulting tests more native to the testing framework
customPassEvaluation) {
    const passEvaluation = customPassEvaluation || defaultPassEvaluation;
    return function getAssertElementWithProperties(type, received, itemType, properties = {}) {
        let stack;
        try {
            stack = JSON.parse(received);
        }
        catch (e) {
            throw new Error(`invalid JSON string passed: ${received}`);
        }
        const items = Object.values(Object.entries(stack[type] || {}) // for all data/resource entries
            .find(
        // find the object with a matching name
        ([type, _values]) => type === itemType.tfResourceType)?.[1] || {} // get all items of that type (encoded as a record of name -> config)
        ) || []; // get a list of all configs of that type
        const pass = passEvaluation(items, properties);
        if (pass) {
            return new AssertionReturn(`Expected no ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesised stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
        else {
            return new AssertionReturn(`Expected ${itemType.tfResourceType} with properties ${JSON.stringify(properties, jestAsymetricMatcherStringifyReplacer)} to be present in synthesised stack.
Found ${items.length === 0 ? "no" : items.length} ${itemType.tfResourceType} resources instead${items.length > 0 ? ":\n" + JSON.stringify(items, null, 2) : ""}`, pass);
        }
    };
}
function getToHaveDataSourceWithProperties(customPassEvaluation) {
    return function toHaveDataSourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("data", received, resourceType, properties);
    };
}
exports.getToHaveDataSourceWithProperties = getToHaveDataSourceWithProperties;
function getToHaveResourceWithProperties(customPassEvaluation) {
    return function toHaveResourceWithProperties(received, resourceType, properties = {}) {
        return getAssertElementWithProperties(customPassEvaluation)("resource", received, resourceType, properties);
    };
}
exports.getToHaveResourceWithProperties = getToHaveResourceWithProperties;
function toBeValidTerraform(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([name, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "pipe",
            };
            child_process_1.execSync(`${terraformBinaryName} init`, opts);
            const out = child_process_1.execSync(`${terraformBinaryName} validate -json`, opts);
            const result = JSON.parse(out.toString());
            if (!result.valid) {
                throw new Error(`Found ${result.error_count} Errors in stack ${name}: ${result.diagnostics.join("\n")}`);
            }
        });
        return new AssertionReturn(`Expected subject not to be a valid terraform stack`, true);
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a valid terraform stack: ${e}`, false);
    }
}
exports.toBeValidTerraform = toBeValidTerraform;
function toPlanSuccessfully(received) {
    try {
        if (!fs.statSync(received).isDirectory()) {
            throw new Error("Path is not a directory");
        }
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to be a terraform directory: ${e}`, false);
    }
    try {
        const manifest = JSON.parse(fs.readFileSync(path.resolve(received, "manifest.json"), "utf8"));
        const stacks = Object.entries(manifest.stacks);
        stacks.forEach(([, stack]) => {
            const opts = {
                cwd: path.resolve(received, stack.workingDirectory),
                env: process.env,
                stdio: "ignore",
            };
            child_process_1.execSync(`${terraformBinaryName} init`, opts);
            // Throws on a non-zero exit code
            child_process_1.execSync(`${terraformBinaryName} plan -input=false `, opts);
        });
        return new AssertionReturn(`Expected subject not to plan successfully`, true);
    }
    catch (e) {
        return new AssertionReturn(`Expected subject to plan successfully: ${e}`, false);
    }
}
exports.toPlanSuccessfully = toPlanSuccessfully;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0Y2hlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJtYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsaURBQXlDO0FBQ3pDLGtDQUFvQztBQUVwQyxNQUFNLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMscUJBQXFCLElBQUksV0FBVyxDQUFDO0FBWTdFLE1BQWEsZUFBZTtJQUMxQixZQUE0QixPQUFlLEVBQWtCLElBQWE7UUFBOUMsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFrQixTQUFJLEdBQUosSUFBSSxDQUFTO0lBQUcsQ0FBQzs7QUFEaEYsMENBRUM7OztBQUdELFNBQWdCLG1CQUFtQixDQUNqQyxRQUF5QjtJQUV6QixPQUFPO1FBQ0wsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxPQUFPO1FBQy9CLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtLQUNwQixDQUFDO0FBQ0osQ0FBQztBQVBELGtEQU9DO0FBRUQsOERBQThEO0FBQzlELDZHQUE2RztBQUM3RyxTQUFnQixzQ0FBc0MsQ0FDcEQsUUFBaUIsRUFDakIsUUFBaUI7SUFFakIsUUFBUSxPQUFPLFFBQVEsRUFBRTtRQUN2QixLQUFLLFFBQVE7WUFDWCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQzNCLE9BQU8sQ0FDTCxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQztvQkFDdkIsUUFBUSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsTUFBTTtvQkFDbkMsUUFBUSxDQUFDLEtBQUssQ0FDWixDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsRUFBRSxDQUNkLHNDQUFzQyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyw2QkFBNkI7cUJBQzlGLENBQ0YsQ0FBQzthQUNIO1lBQ0QsSUFBSSxRQUFRLEtBQUssSUFB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QWlELENBQUMsRUFBRSxFQUNwRCxLQUFLLENBQ04sQ0FBQztLQUNIO0lBRUQsSUFBSTtRQUNGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ3pCLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsZUFBZSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQ2pFLENBQUM7UUFFRixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUUvQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEdBQUc7Z0JBQ1gsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFHLEtBQWEsQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDNUQsR0FBRyxFQUFFLE9BQU8sQ0FBQyxHQUFHO2dCQUNoQixLQUFLLEVBQUUsUUFBUTthQUNULENBQUM7WUFDVCx3QkFBUSxDQUFDLEdBQUcsbUJBQW1CLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztZQUU5QyxpQ0FBaUM7WUFDakMsd0JBQVEsQ0FBQyxHQUFHLG1CQUFtQixxQkFBcUIsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5RCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sSUFBSSxlQUFlLENBQ3hCLDJDQUEyQyxFQUMzQyxJQUFJLENBQ0wsQ0FBQztLQUNIO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixPQUFPLElBQUksZUFBZSxDQUN4QiwwQ0FBMEMsQ0FBQyxFQUFFLEVBQzdDLEtBQUssQ0FDTixDQUFDO0tBQ0g7QUFDSCxDQUFDO0FBekNELGdEQXlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgc25ha2VDYXNlIH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuY29uc3QgdGVycmFmb3JtQmluYXJ5TmFtZSA9IHByb2Nlc3MuZW52LlRFUlJBRk9STV9CSU5BUllfTkFNRSB8fCBcInRlcnJhZm9ybVwiO1xuXG4vLyBUZXJyYWZvcm1Db25zdHJ1Y3RvciBpcyBjbGFzcyB3aXRoIHRoZSBzdGF0aWMgcHJvcGVydHkgJ3RmUmVzb3VyY2VUeXBlJ1xuZXhwb3J0IGludGVyZmFjZSBUZXJyYWZvcm1Db25zdHJ1Y3RvciB7XG4gIHJlYWRvbmx5IHRmUmVzb3VyY2VUeXBlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIFN5bnRoZXNpemVkU3RhY2sgPSB7XG4gIHJlc291cmNlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufTtcblxuZXhwb3J0IGNsYXNzIEFzc2VydGlvblJldHVybiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyByZWFkb25seSBwYXNzOiBib29sZWFuKSB7fVxufVxuXG5leHBvcnQgdHlwZSBNYXRjaGVyUmV0dXJuSmVzdCA9IHsgbWVzc2FnZTogKCkgPT4gc3RyaW5nOyBwYXNzOiBib29sZWFuIH07XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTWF0Y2hlclRvSmVzdChcbiAgdG9SZXR1cm46IEFzc2VydGlvblJldHVyblxuKTogTWF0Y2hlclJldHVybkplc3Qge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6ICgpID0+IHRvUmV0dXJuLm1lc3NhZ2UsXG4gICAgcGFzczogdG9SZXR1cm4ucGFzcyxcbiAgfTtcbn1cblxuLy8gQWxsIGV4cGVjdGVkIHByb3BlcnRpZXMgYXJlIG1hdGNoZWQgYW5kIGNvbnNpZGVyZWQgZXF1YWwgaWZcbi8vIFRoZXJlIGNhbiBiZSBtb3JlIHByb3BlcnRpZXMgaW4gdGhlIHJlY2VpdmVkIG9iamVjdCB0aGFuIGluIHRoZSBleHBlY3RlZCBvYmplY3Qgd2hpbGUgc3RpbGwgcmV0dXJuaW5nIHRydWVcbmV4cG9ydCBmdW5jdGlvbiBhc3ltZXRyaWNEZWVwRXF1YWxJZ25vcmluZ09iamVjdENhc2luZyhcbiAgZXhwZWN0ZWQ6IHVua25vd24sXG4gIHJlY2VpdmVkOiB1bmtub3duXG4pOiBib29sZWFuIHtcbiAgc3dpdGNoICh0eXBlb2YgZXhwZWN0ZWQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBBcnJheS5pc0FycmF5KHJlY2VpdmVkKSAmJlxuICAgICAgICAgIGV4cGVjdGVkLmxlbmd0aCA9PT0gcmVjZWl2ZWQubGVuZ3RoICYmXG4gICAgICAgICAgZXhwZWN0ZWQuZXZlcnkoXG4gICAgICAgICAgICAoaXRlbSwgaW5kZXgpID0+XG4gICAgICAgICAgICAgIGFzeW1ldHJpY0RlZXBFcXVhbElnbm9yaW5nT2JqZWN0Q2FzaW5nKGl0ZW0sIHJlY2VpdmVkW2luZGV4XSkgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXNcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWQgPT09IG51bGwgJiYgcmVjZWl2ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCAmJiByZWNlaXZlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVjdGVkID09PSBudWxsIHx8IHJlY2VpdmVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhbGxvdyBzbmFrZSBjYXNlIGFzIHdlbGwgYXMgY2FtZWwgY2FzZVxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGV4cGVjdGVkIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5ldmVyeSgoa2V5KSA9PiB7XG4gICAgICAgIGlmICgocmVjZWl2ZWQgYXMgYW55KVtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoXG4gICAgICAgICAgICAoZXhwZWN0ZWQgYXMgYW55KVtrZXldLFxuICAgICAgICAgICAgKHJlY2VpdmVkIGFzIGFueSlba2V5XVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHJlY2VpdmVkIGFzIGFueSlbc25ha2VDYXNlKGtleSldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoXG4gICAgICAgICAgICAoZXhwZWN0ZWQgYXMgYW55KVtrZXldLFxuICAgICAgICAgICAgKHJlY2VpdmVkIGFzIGFueSlbc25ha2VDYXNlKGtleSldXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHJlY2VpdmVkO1xuICB9XG59XG5jb25zdCBkZWZhdWx0UGFzc0V2YWx1YXRpb24gPSAoXG4gIGl0ZW1zOiBhbnksXG4gIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuKSA9PiB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGl0ZW1zKS5zb21lKChpdGVtOiBhbnkpID0+XG4gICAgYXN5bWV0cmljRGVlcEVxdWFsSWdub3JpbmdPYmplY3RDYXNpbmcoYXNzZXJ0ZWRQcm9wZXJ0aWVzLCBpdGVtKVxuICApO1xufTtcblxuZnVuY3Rpb24gaXNBc3ltbWV0cmljKG9iajogYW55KSB7XG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIFwiYXN5bW1ldHJpY01hdGNoXCIgaW4gb2JqO1xufVxuLy8gWW91IGNhbiB1c2UgZXhwZWN0LkFueXRoaW5nKCksIGV4cGVjdC5PYmplY3RDb250YWluaW5nLCBldGMgaW4gamVzdCwgdGhpcyBtYWtlcyBpdCBuaWNlciB0byByZWFkXG4vLyB3aGVuIHdlIHByaW50IGVycm9yIG1lc2FnZXNcbmZ1bmN0aW9uIGplc3RBc3ltZXRyaWNNYXRjaGVyU3RyaW5naWZ5UmVwbGFjZXIoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gIHJldHVybiBpc0FzeW1tZXRyaWModmFsdWUpID8gYGV4cGVjdC4ke3ZhbHVlLnRvU3RyaW5nKCl9YCA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKFxuICAvLyBXZSBoYXZlIHRoZSBldmFsdWF0aW9uIGZ1bmN0aW9uIGNvbmZpZ3VyYWJsZSBzbyB3ZSBjYW4gbWFrZSB1c2Ugb2YgdGhlIHNwZWNpZmljIHRlc3RpbmcgZnJhbWV3b3JrcyBjYXBhYmlsaXRpZXNcbiAgLy8gVGhpcyBtYWtlcyB0aGUgcmVzdWx0aW5nIHRlc3RzIG1vcmUgbmF0aXZlIHRvIHRoZSB0ZXN0aW5nIGZyYW1ld29ya1xuICBjdXN0b21QYXNzRXZhbHVhdGlvbj86IChcbiAgICBpdGVtczogYW55W10sIC8vIGNvbmZpZ3VyYXRpb25zIG9mIHRoZSByZXF1ZXN0ZWQgdHlwZVxuICAgIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IGJvb2xlYW5cbikge1xuICBjb25zdCBwYXNzRXZhbHVhdGlvbiA9IGN1c3RvbVBhc3NFdmFsdWF0aW9uIHx8IGRlZmF1bHRQYXNzRXZhbHVhdGlvbjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldEFzc2VydEVsZW1lbnRXaXRoUHJvcGVydGllcyhcbiAgICB0eXBlOiBrZXlvZiBTeW50aGVzaXplZFN0YWNrLFxuICAgIHJlY2VpdmVkOiBzdHJpbmcsXG4gICAgaXRlbVR5cGU6IFRlcnJhZm9ybUNvbnN0cnVjdG9yLFxuICAgIHByb3BlcnRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxuICApOiBBc3NlcnRpb25SZXR1cm4ge1xuICAgIGxldCBzdGFjazogU3ludGhlc2l6ZWRTdGFjaztcbiAgICB0cnkge1xuICAgICAgc3RhY2sgPSBKU09OLnBhcnNlKHJlY2VpdmVkKSBhcyBTeW50aGVzaXplZFN0YWNrO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBKU09OIHN0cmluZyBwYXNzZWQ6ICR7cmVjZWl2ZWR9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPVxuICAgICAgT2JqZWN0LnZhbHVlcyhcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3RhY2tbdHlwZV0gfHwge30pIC8vIGZvciBhbGwgZGF0YS9yZXNvdXJjZSBlbnRyaWVzXG4gICAgICAgICAgLmZpbmQoXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBvYmplY3Qgd2l0aCBhIG1hdGNoaW5nIG5hbWVcbiAgICAgICAgICAgIChbdHlwZSwgX3ZhbHVlc10pID0+IHR5cGUgPT09IGl0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlXG4gICAgICAgICAgKT8uWzFdIHx8IHt9IC8vIGdldCBhbGwgaXRlbXMgb2YgdGhhdCB0eXBlIChlbmNvZGVkIGFzIGEgcmVjb3JkIG9mIG5hbWUgLT4gY29uZmlnKVxuICAgICAgKSB8fCBbXTsgLy8gZ2V0IGEgbGlzdCBvZiBhbGwgY29uZmlncyBvZiB0aGF0IHR5cGVcbiAgICBjb25zdCBwYXNzID0gcGFzc0V2YWx1YXRpb24oaXRlbXMsIHByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHBhc3MpIHtcbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgICBgRXhwZWN0ZWQgbm8gJHtcbiAgICAgICAgICBpdGVtVHlwZS50ZlJlc291cmNlVHlwZVxuICAgICAgICB9IHdpdGggcHJvcGVydGllcyAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgamVzdEFzeW1ldHJpY01hdGNoZXJTdHJpbmdpZnlSZXBsYWNlclxuICAgICAgICApfSB0byBiZSBwcmVzZW50IGluIHN5bnRoZXNpc2VkIHN0YWNrLlxuRm91bmQgJHtpdGVtcy5sZW5ndGggPT09IDAgPyBcIm5vXCIgOiBpdGVtcy5sZW5ndGh9ICR7XG4gICAgICAgICAgaXRlbVR5cGUudGZSZXNvdXJjZVR5cGVcbiAgICAgICAgfSByZXNvdXJjZXMgaW5zdGVhZCR7XG4gICAgICAgICAgaXRlbXMubGVuZ3RoID4gMCA/IFwiOlxcblwiICsgSlNPTi5zdHJpbmdpZnkoaXRlbXMsIG51bGwsIDIpIDogXCJcIlxuICAgICAgICB9YCxcbiAgICAgICAgcGFzc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICAgIGBFeHBlY3RlZCAke2l0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlfSB3aXRoIHByb3BlcnRpZXMgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgIGplc3RBc3ltZXRyaWNNYXRjaGVyU3RyaW5naWZ5UmVwbGFjZXJcbiAgICAgICAgKX0gdG8gYmUgcHJlc2VudCBpbiBzeW50aGVzaXNlZCBzdGFjay5cbkZvdW5kICR7aXRlbXMubGVuZ3RoID09PSAwID8gXCJub1wiIDogaXRlbXMubGVuZ3RofSAke1xuICAgICAgICAgIGl0ZW1UeXBlLnRmUmVzb3VyY2VUeXBlXG4gICAgICAgIH0gcmVzb3VyY2VzIGluc3RlYWQke1xuICAgICAgICAgIGl0ZW1zLmxlbmd0aCA+IDAgPyBcIjpcXG5cIiArIEpTT04uc3RyaW5naWZ5KGl0ZW1zLCBudWxsLCAyKSA6IFwiXCJcbiAgICAgICAgfWAsXG4gICAgICAgIHBhc3NcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9IYXZlRGF0YVNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICBjdXN0b21QYXNzRXZhbHVhdGlvbj86IChcbiAgICBpdGVtczogYW55LFxuICAgIGFzc2VydGVkUHJvcGVydGllczogUmVjb3JkPHN0cmluZywgYW55PlxuICApID0+IGJvb2xlYW5cbikge1xuICByZXR1cm4gZnVuY3Rpb24gdG9IYXZlRGF0YVNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICAgIHJlY2VpdmVkOiBzdHJpbmcsXG4gICAgcmVzb3VyY2VUeXBlOiBUZXJyYWZvcm1Db25zdHJ1Y3RvcixcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgICByZXR1cm4gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKGN1c3RvbVBhc3NFdmFsdWF0aW9uKShcbiAgICAgIFwiZGF0YVwiLFxuICAgICAgcmVjZWl2ZWQsXG4gICAgICByZXNvdXJjZVR5cGUsXG4gICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvSGF2ZVJlc291cmNlV2l0aFByb3BlcnRpZXMoXG4gIGN1c3RvbVBhc3NFdmFsdWF0aW9uPzogKFxuICAgIGl0ZW1zOiBhbnksXG4gICAgYXNzZXJ0ZWRQcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICkgPT4gYm9vbGVhblxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0hhdmVSZXNvdXJjZVdpdGhQcm9wZXJ0aWVzKFxuICAgIHJlY2VpdmVkOiBzdHJpbmcsXG4gICAgcmVzb3VyY2VUeXBlOiBUZXJyYWZvcm1Db25zdHJ1Y3RvcixcbiAgICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKTogQXNzZXJ0aW9uUmV0dXJuIHtcbiAgICByZXR1cm4gZ2V0QXNzZXJ0RWxlbWVudFdpdGhQcm9wZXJ0aWVzKGN1c3RvbVBhc3NFdmFsdWF0aW9uKShcbiAgICAgIFwicmVzb3VyY2VcIixcbiAgICAgIHJlY2VpdmVkLFxuICAgICAgcmVzb3VyY2VUeXBlLFxuICAgICAgcHJvcGVydGllc1xuICAgICk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdG9CZVZhbGlkVGVycmFmb3JtKHJlY2VpdmVkOiBzdHJpbmcpOiBBc3NlcnRpb25SZXR1cm4ge1xuICB0cnkge1xuICAgIGlmICghZnMuc3RhdFN5bmMocmVjZWl2ZWQpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdGggaXMgbm90IGEgZGlyZWN0b3J5XCIpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgYEV4cGVjdGVkIHN1YmplY3QgdG8gYmUgYSB0ZXJyYWZvcm0gZGlyZWN0b3J5OiAke2V9YCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKFxuICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGgucmVzb2x2ZShyZWNlaXZlZCwgXCJtYW5pZmVzdC5qc29uXCIpLCBcInV0ZjhcIilcbiAgICApO1xuXG4gICAgY29uc3Qgc3RhY2tzID0gT2JqZWN0LmVudHJpZXMobWFuaWZlc3Quc3RhY2tzKTtcblxuICAgIHN0YWNrcy5mb3JFYWNoKChbbmFtZSwgc3RhY2tdKSA9PiB7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjd2Q6IHBhdGgucmVzb2x2ZShyZWNlaXZlZCwgKHN0YWNrIGFzIGFueSkud29ya2luZ0RpcmVjdG9yeSksXG4gICAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgICAgIHN0ZGlvOiBcInBpcGVcIixcbiAgICAgIH0gYXMgYW55O1xuICAgICAgZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gaW5pdGAsIG9wdHMpO1xuICAgICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gdmFsaWRhdGUgLWpzb25gLCBvcHRzKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZShvdXQudG9TdHJpbmcoKSk7XG4gICAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZvdW5kICR7XG4gICAgICAgICAgICByZXN1bHQuZXJyb3JfY291bnRcbiAgICAgICAgICB9IEVycm9ycyBpbiBzdGFjayAke25hbWV9OiAke3Jlc3VsdC5kaWFnbm9zdGljcy5qb2luKFwiXFxuXCIpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIGBFeHBlY3RlZCBzdWJqZWN0IG5vdCB0byBiZSBhIHZhbGlkIHRlcnJhZm9ybSBzdGFja2AsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uUmV0dXJuKFxuICAgICAgYEV4cGVjdGVkIHN1YmplY3QgdG8gYmUgYSB2YWxpZCB0ZXJyYWZvcm0gc3RhY2s6ICR7ZX1gLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1BsYW5TdWNjZXNzZnVsbHkocmVjZWl2ZWQ6IHN0cmluZyk6IEFzc2VydGlvblJldHVybiB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5zdGF0U3luYyhyZWNlaXZlZCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCBpcyBub3QgYSBkaXJlY3RvcnlcIik7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICBgRXhwZWN0ZWQgc3ViamVjdCB0byBiZSBhIHRlcnJhZm9ybSBkaXJlY3Rvcnk6ICR7ZX1gLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBtYW5pZmVzdCA9IEpTT04ucGFyc2UoXG4gICAgICBmcy5yZWFkRmlsZVN5bmMocGF0aC5yZXNvbHZlKHJlY2VpdmVkLCBcIm1hbmlmZXN0Lmpzb25cIiksIFwidXRmOFwiKVxuICAgICk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBPYmplY3QuZW50cmllcyhtYW5pZmVzdC5zdGFja3MpO1xuXG4gICAgc3RhY2tzLmZvckVhY2goKFssIHN0YWNrXSkgPT4ge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgY3dkOiBwYXRoLnJlc29sdmUocmVjZWl2ZWQsIChzdGFjayBhcyBhbnkpLndvcmtpbmdEaXJlY3RvcnkpLFxuICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICBzdGRpbzogXCJpZ25vcmVcIixcbiAgICAgIH0gYXMgYW55O1xuICAgICAgZXhlY1N5bmMoYCR7dGVycmFmb3JtQmluYXJ5TmFtZX0gaW5pdGAsIG9wdHMpO1xuXG4gICAgICAvLyBUaHJvd3Mgb24gYSBub24temVybyBleGl0IGNvZGVcbiAgICAgIGV4ZWNTeW5jKGAke3RlcnJhZm9ybUJpbmFyeU5hbWV9IHBsYW4gLWlucHV0PWZhbHNlIGAsIG9wdHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBBc3NlcnRpb25SZXR1cm4oXG4gICAgICBgRXhwZWN0ZWQgc3ViamVjdCBub3QgdG8gcGxhbiBzdWNjZXNzZnVsbHlgLFxuICAgICAgdHJ1ZVxuICAgICk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbmV3IEFzc2VydGlvblJldHVybihcbiAgICAgIGBFeHBlY3RlZCBzdWJqZWN0IHRvIHBsYW4gc3VjY2Vzc2Z1bGx5OiAke2V9YCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgfVxufVxuIl19