"use strict";
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapTerraformIterator = exports.ListTerraformIterator = exports.TerraformIterator = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const terraform_dynamic_expression_1 = require("./terraform-dynamic-expression");
const terraform_functions_1 = require("./terraform-functions");
const tfExpression_1 = require("./tfExpression");
const tokens_1 = require("./tokens");
class TerraformIterator {
    /**
     * Creates a new iterator from a list
     */
    static fromList(list) {
        // TODO: this could return different iterators depending on the type of the list
        // for example it could return a NumberListIterator whose iterator.key would be a number
        return new ListTerraformIterator(list);
    }
    /**
     * Creates a new iterator from a map
     */
    static fromMap(map) {
        return new MapTerraformIterator(map);
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a string
     */
    getString(attribute) {
        return tokens_1.Token.asString(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a number
     */
    getNumber(attribute) {
        return tokens_1.Token.asNumber(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a boolean
     */
    getBoolean(attribute) {
        return tokens_1.Token.asAny(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as any
     */
    getAny(attribute) {
        return tokens_1.Token.asAny(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a (string) list
     */
    getList(attribute) {
        return tokens_1.Token.asList(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a number list
     */
    getNumberList(attribute) {
        return tokens_1.Token.asNumberList(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map
     */
    getMap(attribute) {
        return tokens_1.Token.asAnyMap(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of strings
     */
    getStringMap(attribute) {
        return tokens_1.Token.asStringMap(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of numbers
     */
    getNumberMap(attribute) {
        return tokens_1.Token.asNumberMap(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of booleans
     */
    getBooleanMap(attribute) {
        return tokens_1.Token.asBooleanMap(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @param attribute name of the property to retrieve
     * @returns the given attribute of the current item iterated over as a map of any
     */
    getAnyMap(attribute) {
        return tokens_1.Token.asAnyMap(tfExpression_1.propertyAccess(this._getValue(), [attribute]));
    }
    /**
     * @internal
     */
    _getValue() {
        // uses a Lazy value to be able to access the current TerraformStack and pass it to ref()
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                switch (context.iteratorContext) {
                    case "DYNAMIC_BLOCK":
                        return tfExpression_1.ref("each.value");
                    case "FOR_EXPRESSION":
                        return tfExpression_1.FOR_EXPRESSION_VALUE;
                    default:
                        // same as dynamic block, as this is the case when a iterator is passed to the root level of e.g. a resource
                        return tfExpression_1.ref("each.value");
                }
            },
        }, { displayHint: "<iterator value>" });
    }
    /**
     * @internal
     */
    _getKey() {
        // uses a Lazy value to be able to access the current TerraformStack and pass it to ref()
        return tokens_1.Lazy.anyValue({
            produce: (context) => {
                switch (context.iteratorContext) {
                    case "DYNAMIC_BLOCK":
                        return tfExpression_1.ref("each.key");
                    case "FOR_EXPRESSION":
                        return tfExpression_1.FOR_EXPRESSION_KEY;
                    default:
                        // same as dynamic block, as this is the case when a iterator is passed to the root level of e.g. a resource
                        return tfExpression_1.ref("each.key");
                }
            },
        }, { displayHint: "<iterator key>" });
    }
    dynamic(attributes) {
        return tokens_1.Token.asAny(new terraform_dynamic_expression_1.TerraformDynamicExpression({
            iterator: this,
            content: attributes,
        }));
    }
}
exports.TerraformIterator = TerraformIterator;
_a = JSII_RTTI_SYMBOL_1;
TerraformIterator[_a] = { fqn: "cdktf.TerraformIterator", version: "0.12.0" };
class ListTerraformIterator extends TerraformIterator {
    constructor(list) {
        super();
        this.list = list;
    }
    /**
     * Returns the currenty entry in the list or set that is being iterated over.
     * For lists this is the same as `iterator.value`. If you need the index,
     * use count using the escape hatch:
     * https://www.terraform.io/cdktf/concepts/providers-and-resources#escape-hatch
     */
    get key() {
        return this._getKey();
    }
    /**
     * Returns the value of the current item iterated over.
     */
    get value() {
        return this._getValue();
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        // needs to be wrapped in a set as Terraform only allows sets in for_each
        return terraform_functions_1.Fn.toset(this.list);
    }
}
exports.ListTerraformIterator = ListTerraformIterator;
_b = JSII_RTTI_SYMBOL_1;
ListTerraformIterator[_b] = { fqn: "cdktf.ListTerraformIterator", version: "0.12.0" };
class MapTerraformIterator extends TerraformIterator {
    constructor(map) {
        super();
        this.map = map;
    }
    /**
     * @internal used by TerraformResource to set the for_each expression
     */
    _getForEachExpression() {
        // explicit wrapping to circumvent "Found an encoded map token in a scalar string context." error
        return tokens_1.Token.asString(this.map);
    }
    /**
     * Returns the key of the current entry in the map that is being iterated over.
     */
    get key() {
        return tokens_1.Token.asString(this._getKey());
    }
    /**
     * Returns the value of the current item iterated over.
     */
    get value() {
        return this._getValue();
    }
}
exports.MapTerraformIterator = MapTerraformIterator;
_c = JSII_RTTI_SYMBOL_1;
MapTerraformIterator[_c] = { fqn: "cdktf.MapTerraformIterator", version: "0.12.0" };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVycmFmb3JtLWl0ZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidGVycmFmb3JtLWl0ZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBWUEsaUZBQTRFO0FBQzVFLCtEQUEyQztBQUMzQyxpREFLd0I7QUFDeEIscUNBQW9EO0FBOEJwRCxNQUFzQixpQkFBaUI7SUFNckM7O09BRUc7SUFDSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQWM7UUFDbkMsZ0ZBQWdGO1FBQ2hGLHdGQUF3RjtRQUN4RixPQUFPLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLE9BQU8sQ0FDbkIsR0FLOEI7UUFFOUIsT0FBTyxJQUFJLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsU0FBaUI7UUFDekIsT0FBTyxjQUFLLENBQUMsUUFBUSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsU0FBaUI7UUFDekIsT0FBTyxjQUFLLENBQUMsUUFBUSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxVQUFVLENBQUMsU0FBaUI7UUFDMUIsT0FBTyxjQUFLLENBQUMsS0FBSyxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsU0FBaUI7UUFDdEIsT0FBTyxjQUFLLENBQUMsS0FBSyxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsU0FBaUI7UUFDdkIsT0FBTyxjQUFLLENBQUMsTUFBTSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsU0FBaUI7UUFDN0IsT0FBTyxjQUFLLENBQUMsWUFBWSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxNQUFNLENBQUMsU0FBaUI7UUFDdEIsT0FBTyxjQUFLLENBQUMsUUFBUSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZLENBQUMsU0FBaUI7UUFDNUIsT0FBTyxjQUFLLENBQUMsV0FBVyxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxZQUFZLENBQUMsU0FBaUI7UUFDNUIsT0FBTyxjQUFLLENBQUMsV0FBVyxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxhQUFhLENBQUMsU0FBaUI7UUFDN0IsT0FBTyxjQUFLLENBQUMsWUFBWSxDQUFDLDZCQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLENB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ekJILG9EQTBCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFueU1hcCxcbiAgQW55TWFwTGlzdCxcbiAgQm9vbGVhbk1hcCxcbiAgQm9vbGVhbk1hcExpc3QsXG4gIENvbXBsZXhMaXN0LFxuICBDb21wbGV4TWFwLFxuICBOdW1iZXJNYXAsXG4gIE51bWJlck1hcExpc3QsXG4gIFN0cmluZ01hcCxcbiAgU3RyaW5nTWFwTGlzdCxcbn0gZnJvbSBcIi4vY29tcGxleC1jb21wdXRlZC1saXN0XCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1EeW5hbWljRXhwcmVzc2lvbiB9IGZyb20gXCIuL3RlcnJhZm9ybS1keW5hbWljLWV4cHJlc3Npb25cIjtcbmltcG9ydCB7IEZuIH0gZnJvbSBcIi4vdGVycmFmb3JtLWZ1bmN0aW9uc1wiO1xuaW1wb3J0IHtcbiAgRk9SX0VYUFJFU1NJT05fS0VZLFxuICBGT1JfRVhQUkVTU0lPTl9WQUxVRSxcbiAgcHJvcGVydHlBY2Nlc3MsXG4gIHJlZixcbn0gZnJvbSBcIi4vdGZFeHByZXNzaW9uXCI7XG5pbXBvcnQgeyBJUmVzb2x2YWJsZSwgTGF6eSwgVG9rZW4gfSBmcm9tIFwiLi90b2tlbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBJVGVycmFmb3JtSXRlcmF0b3Ige1xuICAvKipcbiAgICogQGludGVybmFsIHVzZWQgYnkgVGVycmFmb3JtUmVzb3VyY2UgdG8gc2V0IHRoZSBmb3JfZWFjaCBleHByZXNzaW9uXG4gICAqL1xuICBfZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKTogYW55O1xufVxuXG50eXBlIExpc3RUeXBlID1cbiAgfCBBcnJheTxzdHJpbmc+XG4gIHwgQXJyYXk8bnVtYmVyPlxuICB8IEFycmF5PGJvb2xlYW4gfCBJUmVzb2x2YWJsZT5cbiAgfCBJUmVzb2x2YWJsZSAvLyBlLmcuIGFycmF5IG9mIGJvb2xlYW5zXG4gIHwgQ29tcGxleExpc3RcbiAgfCBTdHJpbmdNYXBMaXN0XG4gIHwgTnVtYmVyTWFwTGlzdFxuICB8IEJvb2xlYW5NYXBMaXN0XG4gIHwgQW55TWFwTGlzdDtcblxudHlwZSBNYXBUeXBlID1cbiAgfCB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIHwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICB8IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH1cbiAgfCBTdHJpbmdNYXBcbiAgfCBOdW1iZXJNYXBcbiAgfCBCb29sZWFuTWFwXG4gIHwgQW55TWFwXG4gIHwgQ29tcGxleE1hcDtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFRlcnJhZm9ybUl0ZXJhdG9yIGltcGxlbWVudHMgSVRlcnJhZm9ybUl0ZXJhdG9yIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCB1c2VkIGJ5IFRlcnJhZm9ybVJlc291cmNlIHRvIHNldCB0aGUgZm9yX2VhY2ggZXhwcmVzc2lvblxuICAgKi9cbiAgYWJzdHJhY3QgX2dldEZvckVhY2hFeHByZXNzaW9uKCk6IGFueTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVyYXRvciBmcm9tIGEgbGlzdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmcm9tTGlzdChsaXN0OiBMaXN0VHlwZSk6IExpc3RUZXJyYWZvcm1JdGVyYXRvciB7XG4gICAgLy8gVE9ETzogdGhpcyBjb3VsZCByZXR1cm4gZGlmZmVyZW50IGl0ZXJhdG9ycyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2YgdGhlIGxpc3RcbiAgICAvLyBmb3IgZXhhbXBsZSBpdCBjb3VsZCByZXR1cm4gYSBOdW1iZXJMaXN0SXRlcmF0b3Igd2hvc2UgaXRlcmF0b3Iua2V5IHdvdWxkIGJlIGEgbnVtYmVyXG4gICAgcmV0dXJuIG5ldyBMaXN0VGVycmFmb3JtSXRlcmF0b3IobGlzdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpdGVyYXRvciBmcm9tIGEgbWFwXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21NYXAoXG4gICAgbWFwOlxuICAgICAgfCBDb21wbGV4TWFwXG4gICAgICB8IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgICAgIHwgeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfVxuICAgICAgfCB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9XG4gICAgICB8IHsgW2tleTogc3RyaW5nXTogYm9vbGVhbiB9XG4gICk6IE1hcFRlcnJhZm9ybUl0ZXJhdG9yIHtcbiAgICByZXR1cm4gbmV3IE1hcFRlcnJhZm9ybUl0ZXJhdG9yKG1hcCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIHN0cmluZ1xuICAgKi9cbiAgZ2V0U3RyaW5nKGF0dHJpYnV0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gVG9rZW4uYXNTdHJpbmcocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgbnVtYmVyXG4gICAqL1xuICBnZXROdW1iZXIoYXR0cmlidXRlOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiBUb2tlbi5hc051bWJlcihwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBib29sZWFuXG4gICAqL1xuICBnZXRCb29sZWFuKGF0dHJpYnV0ZTogc3RyaW5nKTogSVJlc29sdmFibGUge1xuICAgIHJldHVybiBUb2tlbi5hc0FueShwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYW55XG4gICAqL1xuICBnZXRBbnkoYXR0cmlidXRlOiBzdHJpbmcpOiBJUmVzb2x2YWJsZSB7XG4gICAgcmV0dXJuIFRva2VuLmFzQW55KHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIChzdHJpbmcpIGxpc3RcbiAgICovXG4gIGdldExpc3QoYXR0cmlidXRlOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFRva2VuLmFzTGlzdChwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBudW1iZXIgbGlzdFxuICAgKi9cbiAgZ2V0TnVtYmVyTGlzdChhdHRyaWJ1dGU6IHN0cmluZyk6IG51bWJlcltdIHtcbiAgICByZXR1cm4gVG9rZW4uYXNOdW1iZXJMaXN0KHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIG1hcFxuICAgKi9cbiAgZ2V0TWFwKGF0dHJpYnV0ZTogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgcmV0dXJuIFRva2VuLmFzQW55TWFwKHByb3BlcnR5QWNjZXNzKHRoaXMuX2dldFZhbHVlKCksIFthdHRyaWJ1dGVdKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB0aGUgZ2l2ZW4gYXR0cmlidXRlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3ZlciBhcyBhIG1hcCBvZiBzdHJpbmdzXG4gICAqL1xuICBnZXRTdHJpbmdNYXAoYXR0cmlidXRlOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcbiAgICByZXR1cm4gVG9rZW4uYXNTdHJpbmdNYXAocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm5zIHRoZSBnaXZlbiBhdHRyaWJ1dGUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyIGFzIGEgbWFwIG9mIG51bWJlcnNcbiAgICovXG4gIGdldE51bWJlck1hcChhdHRyaWJ1dGU6IHN0cmluZyk6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0ge1xuICAgIHJldHVybiBUb2tlbi5hc051bWJlck1hcChwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBtYXAgb2YgYm9vbGVhbnNcbiAgICovXG4gIGdldEJvb2xlYW5NYXAoYXR0cmlidXRlOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XG4gICAgcmV0dXJuIFRva2VuLmFzQm9vbGVhbk1hcChwcm9wZXJ0eUFjY2Vzcyh0aGlzLl9nZXRWYWx1ZSgpLCBbYXR0cmlidXRlXSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gcmV0cmlldmVcbiAgICogQHJldHVybnMgdGhlIGdpdmVuIGF0dHJpYnV0ZSBvZiB0aGUgY3VycmVudCBpdGVtIGl0ZXJhdGVkIG92ZXIgYXMgYSBtYXAgb2YgYW55XG4gICAqL1xuICBnZXRBbnlNYXAoYXR0cmlidXRlOiBzdHJpbmcpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICByZXR1cm4gVG9rZW4uYXNBbnlNYXAocHJvcGVydHlBY2Nlc3ModGhpcy5fZ2V0VmFsdWUoKSwgW2F0dHJpYnV0ZV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByb3RlY3RlZCBfZ2V0VmFsdWUoKTogYW55IHtcbiAgICAvLyB1c2VzIGEgTGF6eSB2YWx1ZSB0byBiZSBhYmxlIHRvIGFjY2VzcyB0aGUgY3VycmVudCBUZXJyYWZvcm1TdGFjayBhbmQgcGFzcyBpdCB0byByZWYoKVxuICAgIHJldHVybiBMYXp5LmFueVZhbHVlKFxuICAgICAge1xuICAgICAgICBwcm9kdWNlOiAoY29udGV4dCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY29udGV4dC5pdGVyYXRvckNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJEWU5BTUlDX0JMT0NLXCI6XG4gICAgICAgICAgICAgIHJldHVybiByZWYoXCJlYWNoLnZhbHVlXCIpO1xuICAgICAgICAgICAgY2FzZSBcIkZPUl9FWFBSRVNTSU9OXCI6XG4gICAgICAgICAgICAgIHJldHVybiBGT1JfRVhQUkVTU0lPTl9WQUxVRTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIHNhbWUgYXMgZHluYW1pYyBibG9jaywgYXMgdGhpcyBpcyB0aGUgY2FzZSB3aGVuIGEgaXRlcmF0b3IgaXMgcGFzc2VkIHRvIHRoZSByb290IGxldmVsIG9mIGUuZy4gYSByZXNvdXJjZVxuICAgICAgICAgICAgICByZXR1cm4gcmVmKFwiZWFjaC52YWx1ZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgeyBkaXNwbGF5SGludDogXCI8aXRlcmF0b3IgdmFsdWU+XCIgfVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm90ZWN0ZWQgX2dldEtleSgpOiBhbnkge1xuICAgIC8vIHVzZXMgYSBMYXp5IHZhbHVlIHRvIGJlIGFibGUgdG8gYWNjZXNzIHRoZSBjdXJyZW50IFRlcnJhZm9ybVN0YWNrIGFuZCBwYXNzIGl0IHRvIHJlZigpXG4gICAgcmV0dXJuIExhenkuYW55VmFsdWUoXG4gICAgICB7XG4gICAgICAgIHByb2R1Y2U6IChjb250ZXh0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjb250ZXh0Lml0ZXJhdG9yQ29udGV4dCkge1xuICAgICAgICAgICAgY2FzZSBcIkRZTkFNSUNfQkxPQ0tcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZihcImVhY2gua2V5XCIpO1xuICAgICAgICAgICAgY2FzZSBcIkZPUl9FWFBSRVNTSU9OXCI6XG4gICAgICAgICAgICAgIHJldHVybiBGT1JfRVhQUkVTU0lPTl9LRVk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBzYW1lIGFzIGR5bmFtaWMgYmxvY2ssIGFzIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiBhIGl0ZXJhdG9yIGlzIHBhc3NlZCB0byB0aGUgcm9vdCBsZXZlbCBvZiBlLmcuIGEgcmVzb3VyY2VcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZihcImVhY2gua2V5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7IGRpc3BsYXlIaW50OiBcIjxpdGVyYXRvciBrZXk+XCIgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZHluYW1pYyhhdHRyaWJ1dGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9KTogSVJlc29sdmFibGUge1xuICAgIHJldHVybiBUb2tlbi5hc0FueShcbiAgICAgIG5ldyBUZXJyYWZvcm1EeW5hbWljRXhwcmVzc2lvbih7XG4gICAgICAgIGl0ZXJhdG9yOiB0aGlzLFxuICAgICAgICBjb250ZW50OiBhdHRyaWJ1dGVzLFxuICAgICAgfSlcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBMaXN0VGVycmFmb3JtSXRlcmF0b3IgZXh0ZW5kcyBUZXJyYWZvcm1JdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbGlzdDogTGlzdFR5cGUpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnR5IGVudHJ5IGluIHRoZSBsaXN0IG9yIHNldCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gICAqIEZvciBsaXN0cyB0aGlzIGlzIHRoZSBzYW1lIGFzIGBpdGVyYXRvci52YWx1ZWAuIElmIHlvdSBuZWVkIHRoZSBpbmRleCxcbiAgICogdXNlIGNvdW50IHVzaW5nIHRoZSBlc2NhcGUgaGF0Y2g6XG4gICAqIGh0dHBzOi8vd3d3LnRlcnJhZm9ybS5pby9jZGt0Zi9jb25jZXB0cy9wcm92aWRlcnMtYW5kLXJlc291cmNlcyNlc2NhcGUtaGF0Y2hcbiAgICovXG4gIHB1YmxpYyBnZXQga2V5KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEtleSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGl0ZW0gaXRlcmF0ZWQgb3Zlci5cbiAgICovXG4gIHB1YmxpYyBnZXQgdmFsdWUoKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgdXNlZCBieSBUZXJyYWZvcm1SZXNvdXJjZSB0byBzZXQgdGhlIGZvcl9lYWNoIGV4cHJlc3Npb25cbiAgICovXG4gIHB1YmxpYyBfZ2V0Rm9yRWFjaEV4cHJlc3Npb24oKTogYW55IHtcbiAgICAvLyBuZWVkcyB0byBiZSB3cmFwcGVkIGluIGEgc2V0IGFzIFRlcnJhZm9ybSBvbmx5IGFsbG93cyBzZXRzIGluIGZvcl9lYWNoXG4gICAgcmV0dXJuIEZuLnRvc2V0KHRoaXMubGlzdCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1hcFRlcnJhZm9ybUl0ZXJhdG9yIGV4dGVuZHMgVGVycmFmb3JtSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IG1hcDogTWFwVHlwZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsIHVzZWQgYnkgVGVycmFmb3JtUmVzb3VyY2UgdG8gc2V0IHRoZSBmb3JfZWFjaCBleHByZXNzaW9uXG4gICAqL1xuICBwdWJsaWMgX2dldEZvckVhY2hFeHByZXNzaW9uKCk6IGFueSB7XG4gICAgLy8gZXhwbGljaXQgd3JhcHBpbmcgdG8gY2lyY3VtdmVudCBcIkZvdW5kIGFuIGVuY29kZWQgbWFwIHRva2VuIGluIGEgc2NhbGFyIHN0cmluZyBjb250ZXh0LlwiIGVycm9yXG4gICAgcmV0dXJuIFRva2VuLmFzU3RyaW5nKHRoaXMubWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGN1cnJlbnQgZW50cnkgaW4gdGhlIG1hcCB0aGF0IGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIuXG4gICAqL1xuICBwdWJsaWMgZ2V0IGtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBUb2tlbi5hc1N0cmluZyh0aGlzLl9nZXRLZXkoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgaXRlbSBpdGVyYXRlZCBvdmVyLlxuICAgKi9cbiAgcHVibGljIGdldCB2YWx1ZSgpOiBhbnkge1xuICAgIHJldHVybiB0aGlzLl9nZXRWYWx1ZSgpO1xuICB9XG59XG4iXX0=