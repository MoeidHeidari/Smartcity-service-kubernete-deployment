"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCustomSynthesis = exports.invokeAspects = exports.StackSynthesizer = void 0;
const path = require("path");
const fs = require("fs");
const stringify = require("json-stable-stringify");
const annotations_1 = require("../annotations");
const constructs_1 = require("constructs");
const aspect_1 = require("../aspect");
class StackSynthesizer {
    /**
     * @param stack the stack to synthesize
     * @param continueOnErrorAnnotations if set to true, `synthesize()` will not throw an error
     * if it encounters an error Annotation. However, it will still add all errors to the manifest
     * file. The cdktf-cli uses this flag to print the errors itself.
     */
    constructor(stack, continueOnErrorAnnotations = false) {
        this.stack = stack;
        this.continueOnErrorAnnotations = continueOnErrorAnnotations;
    }
    synthesize(session) {
        invokeAspects(this.stack);
        if (!session.skipValidation) {
            const errors = this.stack.node
                .findAll()
                .map((node) => node.node
                .validate()
                .map((error) => ({ message: error, source: node })))
                .reduce((prev, curr) => [...prev, ...curr], []);
            if (errors.length > 0) {
                const errorList = errors
                    .map((e) => `[${e.source.node.path}] ${e.message}`)
                    .join("\n  ");
                throw new Error(`Validation failed with the following errors:\n  ${errorList}`);
            }
        }
        const manifest = session.manifest;
        const stackManifest = manifest.forStack(this.stack);
        const workingDirectory = path.join(session.outdir, stackManifest.workingDirectory);
        if (!fs.existsSync(workingDirectory))
            fs.mkdirSync(workingDirectory);
        // call custom synthesis on child nodes (leafs first)
        this.stack.node
            .findAll(constructs_1.ConstructOrder.POSTORDER)
            .forEach((node) => getCustomSynthesis(node)?.onSynthesize(session));
        // collect Annotations into Manifest
        const annotations = this.stack.node
            .findAll()
            .map((node) => ({
            node,
            metadatas: node.node.metadata.filter(isAnnotationMetadata),
        }))
            .map(({ node, metadatas }) => metadatas.map((metadata) => ({
            constructPath: node.node.path,
            level: metadata.type,
            message: metadata.data,
            stacktrace: metadata.trace,
        })))
            .reduce((list, metadatas) => [...list, ...metadatas], []); // Array.flat()
        // it is readonly but this is the place where we are allowed to write to it
        stackManifest.annotations = annotations;
        // abort if one or more error annotations have been encountered
        if (!this.continueOnErrorAnnotations &&
            annotations.some(isErrorAnnotation)) {
            throw new Error(`Encountered Annotations with level "ERROR":\n${annotations
                .filter(isErrorAnnotation)
                .map((a) => `[${a.constructPath}] ${a.message}`)
                .join("\n")}`);
        }
        const tfConfig = this.stack.toTerraform();
        fs.writeFileSync(path.join(session.outdir, stackManifest.synthesizedStackPath), stringify(tfConfig, { space: 2 }));
    }
}
exports.StackSynthesizer = StackSynthesizer;
/**
 * Invoke aspects on the given construct tree.
 *
 * originally from https://github.com/aws/aws-cdk/blob/dcae3eead0dbf9acb1ed80ba95bb104c64cb1bd7/packages/@aws-cdk/core/lib/private/synthesis.ts#L99-L137
 */
function invokeAspects(root) {
    const invokedByPath = {};
    let nestedAspectWarning = false;
    recurse(root, []);
    function recurse(construct, inheritedAspects) {
        const node = construct.node;
        const aspects = aspect_1.Aspects.of(construct);
        const allAspectsHere = [...(inheritedAspects ?? []), ...aspects.all];
        const nodeAspectsCount = aspects.all.length;
        for (const aspect of allAspectsHere) {
            let invoked = invokedByPath[node.path];
            if (!invoked) {
                invoked = invokedByPath[node.path] = [];
            }
            if (invoked.includes(aspect)) {
                continue;
            }
            aspect.visit(construct);
            // if an aspect was added to the node while invoking another aspect it will not be invoked, emit a warning
            // the `nestedAspectWarning` flag is used to prevent the warning from being emitted for every child
            if (!nestedAspectWarning && nodeAspectsCount !== aspects.all.length) {
                annotations_1.Annotations.of(construct).addWarning("We detected an Aspect was added via another Aspect, and will not be applied");
                nestedAspectWarning = true;
            }
            // mark as invoked for this node
            invoked.push(aspect);
        }
        for (const child of construct.node.children) {
            recurse(child, allAspectsHere);
        }
    }
}
exports.invokeAspects = invokeAspects;
const annotationMetadataEntryTypes = [
    annotations_1.AnnotationMetadataEntryType.INFO,
    annotations_1.AnnotationMetadataEntryType.WARN,
    annotations_1.AnnotationMetadataEntryType.ERROR,
];
function isAnnotationMetadata(metadata) {
    return annotationMetadataEntryTypes.includes(metadata.type);
}
function isErrorAnnotation(annotation) {
    return annotation.level === annotations_1.AnnotationMetadataEntryType.ERROR;
}
// originally from https://github.com/aws/aws-cdk/blob/dcae3eead0dbf9acb1ed80ba95bb104c64cb1bd7/packages/%40aws-cdk/core/lib/private/synthesis.ts#L52
const CUSTOM_SYNTHESIS_SYM = Symbol.for("cdktf/customSynthesis");
function addCustomSynthesis(construct, synthesis) {
    Object.defineProperty(construct, CUSTOM_SYNTHESIS_SYM, {
        value: synthesis,
        enumerable: false,
    });
}
exports.addCustomSynthesis = addCustomSynthesis;
function getCustomSynthesis(construct) {
    return construct[CUSTOM_SYNTHESIS_SYM];
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGhlc2l6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzeW50aGVzaXplci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLG1EQUFvRDtBQUdwRCxnREFBMEU7QUFDMUUsMkNBQXVFO0FBQ3ZFLHNDQUE2QztBQUc3QyxNQUFhLGdCQUFnQjtJQUMzQjs7Ozs7T0FLRztJQUNILFlBQ1ksS0FBcUIsRUFDdkIsNkJBQTZCLEtBQUs7UUFEaEMsVUFBSyxHQUFMLEtBQUssQ0FBZ0I7UUFDdkIsK0JBQTBCLEdBQTFCLDBCQUEwQixDQUFRO0lBQ3pDLENBQUM7SUFFSixVQUFVLENBQUMsT0FBMEI7UUFDbkMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUxQixJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtZQUMzQixNQUFNLE1BQU0sR0FBOEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJO2lCQUN0RSxPQUFPLEVBQUU7aUJBQ1QsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FDWixJQUFJLENBQUMsSUFBSTtpQkFDTixRQUFRLEVBQUU7aUJBQ1YsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUN0RDtpQkFDQSxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDbEQsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDckIsTUFBTSxTQUFTLEdBQUcsTUFBTTtxQkFDckIsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENB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QzthQUM1QjtZQUVELGdDQUFnQztZQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3RCO1FBRUQsS0FBSyxNQUFNLEtBQUssSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUMzQyxPQUFPLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1NBQ2hDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUF4Q0Qsc0NBd0NDO0FBRUQsTUFBTSw0QkFBNEIsR0FBRztJQUNuQyx5Q0FBMkIsQ0FBQyxJQUFJO0lBQ2hDLHlDQUEyQixDQUFDLElBQUk7SUFDaEMseUNBQTJCLENBQUMsS0FBSztDQUN0QixDQUFDO0FBRWQsU0FBUyxvQkFBb0IsQ0FBQyxRQUF1QjtJQUNuRCxPQUFPLDRCQUE0QixDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDOUQsQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUMsVUFBMkI7SUFDcEQsT0FBTyxVQUFVLENBQUMsS0FBSyxLQUFLLHlDQUEyQixDQUFDLEtBQUssQ0FBQztBQUNoRSxDQUFDO0FBRUQscUpBQXFKO0FBQ3JKLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0FBZWpFLFNBQWdCLGtCQUFrQixDQUNoQyxTQUFxQixFQUNyQixTQUEyQjtJQUUzQixNQUFNLENBQUMsY0FBYyxDQUFDLFNBQVMsRUFBRSxvQkFBb0IsRUFBRTtRQUNyRCxLQUFLLEVBQUUsU0FBUztRQUNoQixVQUFVLEVBQUUsS0FBSztLQUNsQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBUkQsZ0RBUUM7QUFFRCxTQUFTLGtCQUFrQixDQUN6QixTQUFxQjtJQUVyQixPQUFRLFNBQWlCLENBQUMsb0JBQW9CLENBQUMsQ0FBQztBQUNsRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgc3RyaW5naWZ5ID0gcmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKTtcbmltcG9ydCB7IFRlcnJhZm9ybVN0YWNrIH0gZnJvbSBcIi4uL3RlcnJhZm9ybS1zdGFja1wiO1xuaW1wb3J0IHsgSVN0YWNrU3ludGhlc2l6ZXIsIElTeW50aGVzaXNTZXNzaW9uIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IEFubm90YXRpb25NZXRhZGF0YUVudHJ5VHlwZSwgQW5ub3RhdGlvbnMgfSBmcm9tIFwiLi4vYW5ub3RhdGlvbnNcIjtcbmltcG9ydCB7IENvbnN0cnVjdE9yZGVyLCBJQ29uc3RydWN0LCBNZXRhZGF0YUVudHJ5IH0gZnJvbSBcImNvbnN0cnVjdHNcIjtcbmltcG9ydCB7IEFzcGVjdHMsIElBc3BlY3QgfSBmcm9tIFwiLi4vYXNwZWN0XCI7XG5pbXBvcnQgeyBTdGFja0Fubm90YXRpb24gfSBmcm9tIFwiLi4vbWFuaWZlc3RcIjtcblxuZXhwb3J0IGNsYXNzIFN0YWNrU3ludGhlc2l6ZXIgaW1wbGVtZW50cyBJU3RhY2tTeW50aGVzaXplciB7XG4gIC8qKlxuICAgKiBAcGFyYW0gc3RhY2sgdGhlIHN0YWNrIHRvIHN5bnRoZXNpemVcbiAgICogQHBhcmFtIGNvbnRpbnVlT25FcnJvckFubm90YXRpb25zIGlmIHNldCB0byB0cnVlLCBgc3ludGhlc2l6ZSgpYCB3aWxsIG5vdCB0aHJvdyBhbiBlcnJvclxuICAgKiBpZiBpdCBlbmNvdW50ZXJzIGFuIGVycm9yIEFubm90YXRpb24uIEhvd2V2ZXIsIGl0IHdpbGwgc3RpbGwgYWRkIGFsbCBlcnJvcnMgdG8gdGhlIG1hbmlmZXN0XG4gICAqIGZpbGUuIFRoZSBjZGt0Zi1jbGkgdXNlcyB0aGlzIGZsYWcgdG8gcHJpbnQgdGhlIGVycm9ycyBpdHNlbGYuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3RhY2s6IFRlcnJhZm9ybVN0YWNrLFxuICAgIHByaXZhdGUgY29udGludWVPbkVycm9yQW5ub3RhdGlvbnMgPSBmYWxzZVxuICApIHt9XG5cbiAgc3ludGhlc2l6ZShzZXNzaW9uOiBJU3ludGhlc2lzU2Vzc2lvbikge1xuICAgIGludm9rZUFzcGVjdHModGhpcy5zdGFjayk7XG5cbiAgICBpZiAoIXNlc3Npb24uc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IGVycm9yczogeyBtZXNzYWdlOiBzdHJpbmc7IHNvdXJjZTogSUNvbnN0cnVjdCB9W10gPSB0aGlzLnN0YWNrLm5vZGVcbiAgICAgICAgLmZpbmRBbGwoKVxuICAgICAgICAubWFwKChub2RlKSA9PlxuICAgICAgICAgIG5vZGUubm9kZVxuICAgICAgICAgICAgLnZhbGlkYXRlKClcbiAgICAgICAgICAgIC5tYXAoKGVycm9yKSA9PiAoeyBtZXNzYWdlOiBlcnJvciwgc291cmNlOiBub2RlIH0pKVxuICAgICAgICApXG4gICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IFsuLi5wcmV2LCAuLi5jdXJyXSwgW10pO1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTGlzdCA9IGVycm9yc1xuICAgICAgICAgIC5tYXAoKGUpID0+IGBbJHtlLnNvdXJjZS5ub2RlLnBhdGh9XSAke2UubWVzc2FnZX1gKVxuICAgICAgICAgIC5qb2luKFwiXFxuICBcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsaWRhdGlvbiBmYWlsZWQgd2l0aCB0aGUgZm9sbG93aW5nIGVycm9yczpcXG4gICR7ZXJyb3JMaXN0fWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYW5pZmVzdCA9IHNlc3Npb24ubWFuaWZlc3Q7XG4gICAgY29uc3Qgc3RhY2tNYW5pZmVzdCA9IG1hbmlmZXN0LmZvclN0YWNrKHRoaXMuc3RhY2spO1xuXG4gICAgY29uc3Qgd29ya2luZ0RpcmVjdG9yeSA9IHBhdGguam9pbihcbiAgICAgIHNlc3Npb24ub3V0ZGlyLFxuICAgICAgc3RhY2tNYW5pZmVzdC53b3JraW5nRGlyZWN0b3J5XG4gICAgKTtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMod29ya2luZ0RpcmVjdG9yeSkpIGZzLm1rZGlyU3luYyh3b3JraW5nRGlyZWN0b3J5KTtcblxuICAgIC8vIGNhbGwgY3VzdG9tIHN5bnRoZXNpcyBvbiBjaGlsZCBub2RlcyAobGVhZnMgZmlyc3QpXG4gICAgdGhpcy5zdGFjay5ub2RlXG4gICAgICAuZmluZEFsbChDb25zdHJ1Y3RPcmRlci5QT1NUT1JERVIpXG4gICAgICAuZm9yRWFjaCgobm9kZSkgPT4gZ2V0Q3VzdG9tU3ludGhlc2lzKG5vZGUpPy5vblN5bnRoZXNpemUoc2Vzc2lvbikpO1xuXG4gICAgLy8gY29sbGVjdCBBbm5vdGF0aW9ucyBpbnRvIE1hbmlmZXN0XG4gICAgY29uc3QgYW5ub3RhdGlvbnMgPSB0aGlzLnN0YWNrLm5vZGVcbiAgICAgIC5maW5kQWxsKClcbiAgICAgIC5tYXAoKG5vZGUpID0+ICh7XG4gICAgICAgIG5vZGUsXG4gICAgICAgIG1ldGFkYXRhczogbm9kZS5ub2RlLm1ldGFkYXRhLmZpbHRlcihpc0Fubm90YXRpb25NZXRhZGF0YSksXG4gICAgICB9KSlcbiAgICAgIC5tYXA8U3RhY2tBbm5vdGF0aW9uW10+KCh7IG5vZGUsIG1ldGFkYXRhcyB9KSA9PlxuICAgICAgICBtZXRhZGF0YXMubWFwKChtZXRhZGF0YSkgPT4gKHtcbiAgICAgICAgICBjb25zdHJ1Y3RQYXRoOiBub2RlLm5vZGUucGF0aCxcbiAgICAgICAgICBsZXZlbDogbWV0YWRhdGEudHlwZSBhcyBBbm5vdGF0aW9uTWV0YWRhdGFFbnRyeVR5cGUsXG4gICAgICAgICAgbWVzc2FnZTogbWV0YWRhdGEuZGF0YSxcbiAgICAgICAgICBzdGFja3RyYWNlOiBtZXRhZGF0YS50cmFjZSxcbiAgICAgICAgfSkpXG4gICAgICApXG4gICAgICAucmVkdWNlKChsaXN0LCBtZXRhZGF0YXMpID0+IFsuLi5saXN0LCAuLi5tZXRhZGF0YXNdLCBbXSk7IC8vIEFycmF5LmZsYXQoKVxuXG4gICAgLy8gaXQgaXMgcmVhZG9ubHkgYnV0IHRoaXMgaXMgdGhlIHBsYWNlIHdoZXJlIHdlIGFyZSBhbGxvd2VkIHRvIHdyaXRlIHRvIGl0XG4gICAgKHN0YWNrTWFuaWZlc3QuYW5ub3RhdGlvbnMgYXMgYW55KSA9IGFubm90YXRpb25zO1xuXG4gICAgLy8gYWJvcnQgaWYgb25lIG9yIG1vcmUgZXJyb3IgYW5ub3RhdGlvbnMgaGF2ZSBiZWVuIGVuY291bnRlcmVkXG4gICAgaWYgKFxuICAgICAgIXRoaXMuY29udGludWVPbkVycm9yQW5ub3RhdGlvbnMgJiZcbiAgICAgIGFubm90YXRpb25zLnNvbWUoaXNFcnJvckFubm90YXRpb24pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFbmNvdW50ZXJlZCBBbm5vdGF0aW9ucyB3aXRoIGxldmVsIFwiRVJST1JcIjpcXG4ke2Fubm90YXRpb25zXG4gICAgICAgICAgLmZpbHRlcihpc0Vycm9yQW5ub3RhdGlvbilcbiAgICAgICAgICAubWFwKChhKSA9PiBgWyR7YS5jb25zdHJ1Y3RQYXRofV0gJHthLm1lc3NhZ2V9YClcbiAgICAgICAgICAuam9pbihcIlxcblwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHRmQ29uZmlnID0gdGhpcy5zdGFjay50b1RlcnJhZm9ybSgpO1xuXG4gICAgZnMud3JpdGVGaWxlU3luYyhcbiAgICAgIHBhdGguam9pbihzZXNzaW9uLm91dGRpciwgc3RhY2tNYW5pZmVzdC5zeW50aGVzaXplZFN0YWNrUGF0aCksXG4gICAgICBzdHJpbmdpZnkodGZDb25maWcsIHsgc3BhY2U6IDIgfSlcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogSW52b2tlIGFzcGVjdHMgb24gdGhlIGdpdmVuIGNvbnN0cnVjdCB0cmVlLlxuICpcbiAqIG9yaWdpbmFsbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvYmxvYi9kY2FlM2VlYWQwZGJmOWFjYjFlZDgwYmE5NWJiMTA0YzY0Y2IxYmQ3L3BhY2thZ2VzL0Bhd3MtY2RrL2NvcmUvbGliL3ByaXZhdGUvc3ludGhlc2lzLnRzI0w5OS1MMTM3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VBc3BlY3RzKHJvb3Q6IElDb25zdHJ1Y3QpIHtcbiAgY29uc3QgaW52b2tlZEJ5UGF0aDogeyBbbm9kZVBhdGg6IHN0cmluZ106IElBc3BlY3RbXSB9ID0ge307XG5cbiAgbGV0IG5lc3RlZEFzcGVjdFdhcm5pbmcgPSBmYWxzZTtcbiAgcmVjdXJzZShyb290LCBbXSk7XG5cbiAgZnVuY3Rpb24gcmVjdXJzZShjb25zdHJ1Y3Q6IElDb25zdHJ1Y3QsIGluaGVyaXRlZEFzcGVjdHM6IElBc3BlY3RbXSkge1xuICAgIGNvbnN0IG5vZGUgPSBjb25zdHJ1Y3Qubm9kZTtcbiAgICBjb25zdCBhc3BlY3RzID0gQXNwZWN0cy5vZihjb25zdHJ1Y3QpO1xuICAgIGNvbnN0IGFsbEFzcGVjdHNIZXJlID0gWy4uLihpbmhlcml0ZWRBc3BlY3RzID8/IFtdKSwgLi4uYXNwZWN0cy5hbGxdO1xuICAgIGNvbnN0IG5vZGVBc3BlY3RzQ291bnQgPSBhc3BlY3RzLmFsbC5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBhc3BlY3Qgb2YgYWxsQXNwZWN0c0hlcmUpIHtcbiAgICAgIGxldCBpbnZva2VkID0gaW52b2tlZEJ5UGF0aFtub2RlLnBhdGhdO1xuICAgICAgaWYgKCFpbnZva2VkKSB7XG4gICAgICAgIGludm9rZWQgPSBpbnZva2VkQnlQYXRoW25vZGUucGF0aF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludm9rZWQuaW5jbHVkZXMoYXNwZWN0KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYXNwZWN0LnZpc2l0KGNvbnN0cnVjdCk7XG5cbiAgICAgIC8vIGlmIGFuIGFzcGVjdCB3YXMgYWRkZWQgdG8gdGhlIG5vZGUgd2hpbGUgaW52b2tpbmcgYW5vdGhlciBhc3BlY3QgaXQgd2lsbCBub3QgYmUgaW52b2tlZCwgZW1pdCBhIHdhcm5pbmdcbiAgICAgIC8vIHRoZSBgbmVzdGVkQXNwZWN0V2FybmluZ2AgZmxhZyBpcyB1c2VkIHRvIHByZXZlbnQgdGhlIHdhcm5pbmcgZnJvbSBiZWluZyBlbWl0dGVkIGZvciBldmVyeSBjaGlsZFxuICAgICAgaWYgKCFuZXN0ZWRBc3BlY3RXYXJuaW5nICYmIG5vZGVBc3BlY3RzQ291bnQgIT09IGFzcGVjdHMuYWxsLmxlbmd0aCkge1xuICAgICAgICBBbm5vdGF0aW9ucy5vZihjb25zdHJ1Y3QpLmFkZFdhcm5pbmcoXG4gICAgICAgICAgXCJXZSBkZXRlY3RlZCBhbiBBc3BlY3Qgd2FzIGFkZGVkIHZpYSBhbm90aGVyIEFzcGVjdCwgYW5kIHdpbGwgbm90IGJlIGFwcGxpZWRcIlxuICAgICAgICApO1xuICAgICAgICBuZXN0ZWRBc3BlY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFyayBhcyBpbnZva2VkIGZvciB0aGlzIG5vZGVcbiAgICAgIGludm9rZWQucHVzaChhc3BlY3QpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY29uc3RydWN0Lm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIHJlY3Vyc2UoY2hpbGQsIGFsbEFzcGVjdHNIZXJlKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgYW5ub3RhdGlvbk1ldGFkYXRhRW50cnlUeXBlcyA9IFtcbiAgQW5ub3RhdGlvbk1ldGFkYXRhRW50cnlUeXBlLklORk8sXG4gIEFubm90YXRpb25NZXRhZGF0YUVudHJ5VHlwZS5XQVJOLFxuICBBbm5vdGF0aW9uTWV0YWRhdGFFbnRyeVR5cGUuRVJST1IsXG5dIGFzIHN0cmluZ1tdO1xuXG5mdW5jdGlvbiBpc0Fubm90YXRpb25NZXRhZGF0YShtZXRhZGF0YTogTWV0YWRhdGFFbnRyeSk6IGJvb2xlYW4ge1xuICByZXR1cm4gYW5ub3RhdGlvbk1ldGFkYXRhRW50cnlUeXBlcy5pbmNsdWRlcyhtZXRhZGF0YS50eXBlKTtcbn1cblxuZnVuY3Rpb24gaXNFcnJvckFubm90YXRpb24oYW5ub3RhdGlvbjogU3RhY2tBbm5vdGF0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiBhbm5vdGF0aW9uLmxldmVsID09PSBBbm5vdGF0aW9uTWV0YWRhdGFFbnRyeVR5cGUuRVJST1I7XG59XG5cbi8vIG9yaWdpbmFsbHkgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvYmxvYi9kY2FlM2VlYWQwZGJmOWFjYjFlZDgwYmE5NWJiMTA0YzY0Y2IxYmQ3L3BhY2thZ2VzLyU0MGF3cy1jZGsvY29yZS9saWIvcHJpdmF0ZS9zeW50aGVzaXMudHMjTDUyXG5jb25zdCBDVVNUT01fU1lOVEhFU0lTX1NZTSA9IFN5bWJvbC5mb3IoXCJjZGt0Zi9jdXN0b21TeW50aGVzaXNcIik7XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciBjb25zdHJ1Y3RzIHRoYXQgd2FudCB0byBkbyBzb21ldGhpbmcgY3VzdG9tIGR1cmluZyBzeW50aGVzaXNcbiAqXG4gKiBUaGlzIGZlYXR1cmUgaXMgaW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgQ0RLVEYgb25seTsgM3JkIHBhcnR5XG4gKiBsaWJyYXJ5IGF1dGhvcnMgYW5kIENESyB1c2VycyBzaG91bGQgbm90IHVzZSB0aGlzIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIElDdXN0b21TeW50aGVzaXMge1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN0cnVjdCBpcyBzeW50aGVzaXplZFxuICAgKi9cbiAgb25TeW50aGVzaXplKHNlc3Npb246IElTeW50aGVzaXNTZXNzaW9uKTogdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEN1c3RvbVN5bnRoZXNpcyhcbiAgY29uc3RydWN0OiBJQ29uc3RydWN0LFxuICBzeW50aGVzaXM6IElDdXN0b21TeW50aGVzaXNcbik6IHZvaWQge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29uc3RydWN0LCBDVVNUT01fU1lOVEhFU0lTX1NZTSwge1xuICAgIHZhbHVlOiBzeW50aGVzaXMsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDdXN0b21TeW50aGVzaXMoXG4gIGNvbnN0cnVjdDogSUNvbnN0cnVjdFxuKTogSUN1c3RvbVN5bnRoZXNpcyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoY29uc3RydWN0IGFzIGFueSlbQ1VTVE9NX1NZTlRIRVNJU19TWU1dO1xufVxuIl19