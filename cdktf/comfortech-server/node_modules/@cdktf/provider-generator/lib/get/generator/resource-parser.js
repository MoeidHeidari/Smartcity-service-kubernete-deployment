"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceParser = void 0;
const codemaker_1 = require("codemaker");
const provider_schema_1 = require("./provider-schema");
const models_1 = require("./models");
const loop_detection_1 = require("./loop-detection");
const isReservedClassName = (className) => {
    return ["string"].includes(className.toLowerCase());
};
class Parser {
    constructor(classNames) {
        this.classNames = classNames;
        this.structs = new Array();
    }
    uniqueClassName(className) {
        if (this.classNames.includes(className)) {
            className = `${className}A`;
        }
        this.classNames.push(className);
        return className;
    }
    resourceFrom(provider, type, schema, terraformSchemaType) {
        let baseName = type;
        if (baseName.startsWith(`${provider}_`)) {
            baseName = baseName.substr(provider.length + 1);
        }
        const isProvider = terraformSchemaType === "provider";
        if (isProvider) {
            baseName = `${provider}_${baseName}`;
            if (!("attributes" in schema.block)) {
                schema.block = { attributes: {}, block_types: {} };
            }
            // somehow missing from provider schema
            schema.block.attributes["alias"] = {
                type: "string",
                description: "Alias name",
                optional: true,
                computed: false,
            };
        }
        if (isReservedClassName(baseName)) {
            baseName = `${baseName}_resource`;
        }
        const className = this.uniqueClassName(codemaker_1.toPascalCase(baseName));
        // avoid naming collision - see https://github.com/hashicorp/terraform-cdk/issues/299
        const configStructName = this.uniqueClassName(`${className}Config`);
        const fileName = baseName === "index"
            ? "index-resource.ts"
            : `${codemaker_1.toSnakeCase(baseName).replace(/_/g, "-")}.ts`;
        const filePath = `providers/${codemaker_1.toSnakeCase(provider)}/${fileName}`;
        const attributes = this.renderAttributesForBlock(new models_1.Scope({
            name: baseName,
            isProvider,
            parent: isProvider
                ? undefined
                : new models_1.Scope({ name: provider, isProvider: true }),
        }), schema.block);
        function getStructAttribute(attributes, path) {
            var _a;
            const [first, ...rest] = path.split(".");
            const attribute = attributes.find((att) => {
                return att.terraformName === first;
            });
            if (!attribute)
                throw new Error(`Expected to find recursive attribute at path: ${path}`);
            if (!attribute.type.struct)
                throw new Error(`Expected to find struct type attribute at path: ${path} but got ${attribute.type.typeName}`);
            if (rest.length === 0)
                return attribute;
            return getStructAttribute((_a = attribute.type.struct) === null || _a === void 0 ? void 0 : _a.attributes, rest.join("."));
        }
        // Introduce recursion for some attributes
        const recursiveAttributePaths = loop_detection_1.detectAttributeLoops(attributes);
        Object.entries(recursiveAttributePaths).forEach(([attributePath, structPath]) => {
            // TODO: build this to be a bit more defensive (e.g. remove ! operator)
            const recursionTargetStructAttribute = getStructAttribute(attributes, structPath);
            const parts = attributePath.split(".");
            const attributeName = parts.pop();
            const parentAttribute = getStructAttribute(attributes, parts.join("."));
            const indexToReplace = parentAttribute.type.struct.attributes.findIndex((att) => att.terraformName === attributeName);
            if (indexToReplace === -1)
                throw new Error("Can't find attribute at path " + attributePath);
            const previousAttribute = parentAttribute.type.struct.attributes[indexToReplace];
            parentAttribute.type.struct.attributes[indexToReplace] =
                recursionTargetStructAttribute; // introduce recursion
            // ugly, pls c̶a̶l̶l̶ refactor me maybe
            // we store all structs in this.structs – now we need to dispose all structs that are part of previousAttribute
            const disposeStructs = (attr) => {
                if (attr.type.struct) {
                    attr.type.struct.attributes.forEach(disposeStructs);
                    this.structs = this.structs.filter((s) => s !== attr.type.struct);
                }
            };
            disposeStructs(previousAttribute);
        });
        const resourceModel = new models_1.ResourceModel({
            terraformType: type,
            baseName,
            fileName,
            filePath,
            className,
            schema,
            provider,
            attributes,
            terraformSchemaType,
            structs: this.structs,
            configStructName,
        });
        return resourceModel;
    }
    renderAttributeType(scope, attributeType, parentKind) {
        const parent = scope[scope.length - 1];
        const level = scope.length;
        const isComputed = !!scope.find((e) => e.isComputed === true);
        const isOptional = parent.isOptional;
        const isRequired = parent.isRequired;
        if (typeof attributeType === "string") {
            switch (attributeType) {
                case "bool":
                    return new models_1.AttributeTypeModel("boolean", {
                        isComputed,
                        isOptional,
                        isRequired,
                        level,
                    });
                case "string":
                    return new models_1.AttributeTypeModel("string", {
                        isComputed,
                        isOptional,
                        isRequired,
                        level,
                    });
                case "number":
                    return new models_1.AttributeTypeModel("number", {
                        isComputed,
                        isOptional,
                        isRequired,
                        level,
                    });
                case "dynamic":
                    return new models_1.AttributeTypeModel("any", {
                        isComputed,
                        isOptional,
                        isRequired,
                        level,
                        isMap: true,
                    });
                default:
                    throw new Error(`invalid primitive type ${attributeType}`);
            }
        }
        if (Array.isArray(attributeType)) {
            if (attributeType.length !== 2) {
                throw new Error(`unexpected array`);
            }
            const [kind, type] = attributeType;
            if (kind === "set" || kind === "list") {
                const attrType = this.renderAttributeType(scope, type, kind);
                attrType.isList = kind === "list";
                attrType.isSet = kind === "set";
                attrType.isComputed = isComputed;
                attrType.isOptional = isOptional;
                attrType.isRequired = isRequired;
                attrType.level = level;
                return attrType;
            }
            if (kind === "map") {
                const valueType = this.renderAttributeType(scope, type, kind);
                valueType.isMap = true;
                valueType.isComputed = isComputed;
                valueType.isOptional = isOptional;
                valueType.isRequired = isRequired;
                valueType.level = level;
                return valueType;
            }
            if (kind === "object") {
                const objAttributes = type;
                const attributes = {};
                for (const [name, type] of Object.entries(objAttributes)) {
                    attributes[name] = { type };
                }
                const struct = this.addAnonymousStruct(scope, attributes, parentKind !== null && parentKind !== void 0 ? parentKind : kind);
                const model = new models_1.AttributeTypeModel(struct.name, {
                    struct,
                    isComputed,
                    isOptional,
                    isRequired,
                    level,
                });
                return model;
            }
        }
        if (provider_schema_1.isAttributeNestedType(attributeType)) {
            let isList = undefined;
            let isSet = undefined;
            let isMap = undefined;
            switch (attributeType.nesting_mode) {
                case "list":
                    isList = true;
                    break;
                case "set":
                    isSet = true;
                    break;
                case "map":
                    isMap = true;
                    break;
                case "single":
                    break;
                default: {
                    throw new Error(`nested_type with nesting_mode "${attributeType.nesting_mode}" not supported (attribute scope: ${scope
                        .map((s) => s.fullName)
                        .join(",")}`);
                }
            }
            const struct = this.addAnonymousStruct(scope, attributeType.attributes, attributeType.nesting_mode);
            const model = new models_1.AttributeTypeModel(struct.name, {
                struct,
                isComputed,
                isOptional,
                isRequired,
                level,
                isList,
                isSet,
                isMap,
                isNested: true,
            });
            return model;
        }
        throw new Error(`unknown type ${JSON.stringify(attributeType)}`);
    }
    renderAttributesForBlock(parentType, block) {
        const attributes = new Array();
        for (const [terraformAttributeName, att] of Object.entries(block.attributes || {})) {
            const type = this.renderAttributeType([
                parentType,
                new models_1.Scope({
                    name: terraformAttributeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                    isComputed: !!att.computed,
                    isOptional: !!att.optional,
                    isRequired: !!att.required,
                    isNestedType: provider_schema_1.isNestedTypeAttribute(att),
                }),
            ], att.type || att.nested_type);
            const name = codemaker_1.toCamelCase(terraformAttributeName);
            attributes.push(new models_1.AttributeModel({
                terraformFullName: parentType.fullName(terraformAttributeName),
                description: att.description,
                name,
                storageName: `_${name}`,
                computed: !!att.computed,
                optional: !!att.optional,
                terraformName: terraformAttributeName,
                type,
                provider: parentType.isProvider,
                required: !!att.required,
            }));
        }
        for (const [blockTypeName, blockType] of Object.entries(block.block_types || {})) {
            // create a struct for this block
            const blockAttributes = this.renderAttributesForBlock(new models_1.Scope({
                name: `${parentType.name}_${blockTypeName}`,
                parent: parentType,
                isProvider: parentType.isProvider,
                inBlockType: true,
            }), blockType.block);
            const blockStruct = this.addStruct([
                parentType,
                new models_1.Scope({
                    name: blockTypeName,
                    parent: parentType,
                    isProvider: parentType.isProvider,
                }),
            ], blockAttributes, blockType.nesting_mode, (blockType.nesting_mode === "list" ||
                blockType.nesting_mode === "set") &&
                blockType.max_items === 1);
            // define the attribute
            attributes.push(attributeForBlockType(blockTypeName, blockType, blockStruct, parentType.isProvider, parentType));
        }
        return attributes;
        function attributeForBlockType(terraformName, blockType, struct, isProvider, parent) {
            const name = codemaker_1.toCamelCase(terraformName);
            let optional;
            let required;
            switch (blockType.nesting_mode) {
                case "single":
                    optional = !struct.attributes.some((x) => !x.optional);
                    required = !struct.attributes.some((x) => !x.required);
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.AttributeTypeModel(struct.name, {
                            struct,
                            isOptional: optional,
                            isRequired: required,
                            isSingleItem: true,
                            isBlock: true,
                        }),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
                case "map":
                    return new models_1.AttributeModel({
                        name,
                        terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.AttributeTypeModel(struct.name, {
                            struct,
                            isMap: true,
                            isBlock: true,
                        }),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional: false,
                        computed: false,
                        provider: isProvider,
                        required: false,
                    });
                case "list":
                case "set":
                    optional =
                        blockType.min_items === undefined ? true : blockType.min_items < 1;
                    required =
                        blockType.min_items === undefined ? false : blockType.min_items > 0;
                    return new models_1.AttributeModel({
                        name,
                        terraformName: terraformName,
                        terraformFullName: parent.fullName(terraformName),
                        type: new models_1.AttributeTypeModel(struct.name, {
                            struct,
                            isList: blockType.nesting_mode === "list",
                            isSet: blockType.nesting_mode === "set",
                            isOptional: optional,
                            isRequired: required,
                            isSingleItem: blockType.max_items === 1,
                            isBlock: true,
                        }),
                        description: `${terraformName} block`,
                        storageName: `_${name}`,
                        optional,
                        computed: false,
                        provider: isProvider,
                        required,
                    });
            }
        }
    }
    addAnonymousStruct(scope, attrs, nesting_mode) {
        const attributes = new Array();
        const parent = scope[scope.length - 1];
        for (const [terraformName, att] of Object.entries(attrs)) {
            // nested types support computed, optional and required on attribute level
            // if parent is computed, child always is computed as well
            const computed = !!parent.isComputed || (parent.isNestedType && !!att.computed);
            const optional = parent.isNestedType
                ? !!att.optional
                : !!parent.isOptional;
            const required = parent.isNestedType
                ? !!att.required
                : !!parent.isRequired;
            const name = codemaker_1.toCamelCase(terraformName);
            attributes.push(new models_1.AttributeModel({
                name,
                storageName: `_${name}`,
                computed: computed,
                description: att.description,
                optional: optional,
                terraformName,
                terraformFullName: parent.fullName(terraformName),
                type: this.renderAttributeType([
                    ...scope,
                    new models_1.Scope({
                        name: terraformName,
                        parent,
                        isProvider: parent.isProvider,
                        isComputed: computed,
                        isOptional: optional,
                        isRequired: required,
                        isNestedType: parent.isNestedType,
                    }),
                ], att.type || att.nested_type),
                provider: parent.isProvider,
                required: required,
            }));
        }
        return this.addStruct(scope, attributes, nesting_mode);
    }
    addStruct(scope, attributes, nesting_mode, isSingleItem = false) {
        const name = this.uniqueClassName(codemaker_1.toPascalCase(scope.map((x) => codemaker_1.toSnakeCase(x.name)).join("_")));
        const parent = scope[scope.length - 1];
        // blockType.nesting_mode => list/set & blockType.max_items === 1,
        const isClass = (parent.isComputed && !parent.isOptional) || isSingleItem;
        const isAnonymous = true;
        const s = new models_1.Struct(name, attributes, isClass, isAnonymous, isSingleItem, nesting_mode);
        this.structs.push(s);
        return s;
    }
}
class ResourceParser {
    constructor() {
        this.uniqueClassnames = [];
        this.resources = {};
    }
    parse(provider, type, schema, terraformType) {
        if (this.resources[type]) {
            return this.resources[type];
        }
        const parser = new Parser(this.uniqueClassnames);
        const resource = parser.resourceFrom(provider, type, schema, terraformType);
        this.resources[type] = resource;
        return resource;
    }
    // Used by convert to determine the right name for a class
    getClassNameForResource(terraformType) {
        const resource = this.resources[terraformType];
        return resource ? resource.className : "";
    }
}
exports.ResourceParser = ResourceParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzb3VyY2UtcGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicmVzb3VyY2UtcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlDQUFtRTtBQUNuRSx1REFTMkI7QUFDM0IscUNBTWtCO0FBQ2xCLHFEQUF3RDtBQUV4RCxNQUFNLG1CQUFtQixHQUFHLENBQUMsU0FBaUIsRUFBVyxFQUFFO0lBQ3pELE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDdEQsQ0FBQyxDQUFDO0FBRUYsTUFBTSxNQUFNO0lBR1YsWUFBb0IsVUFBb0I7UUFBcEIsZUFBVSxHQUFWLFVBQVUsQ0FBVTtRQUZoQyxZQUFPLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztJQUVLLENBQUM7SUFFcEMsZUFBZSxDQUFDLFNBQWlCO1FBQ3ZDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDdkMsU0FBUyxHQUFHLEdBQUcsU0FBUyxHQUFHLENBQUM7U0FDN0I7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNoQyxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBRU0sWUFBWSxDQUNqQixRQUFnQixFQUNoQixJQUFZLEVBQ1osTUFBYyxFQUNkLG1CQUEyQjtRQUUzQixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsUUFBUSxHQUFHLENBQUMsRUFBRTtZQUN2QyxRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsTUFBTSxVQUFVLEdBQUcsbUJBQW1CLEtBQUssVUFBVSxDQUFDO1FBQ3RELElBQUksVUFBVSxFQUFFO1lBQ2QsUUFBUSxHQUFH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LEdBQUcsUUFBUSxDQUFDO1FBQ2hDLE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRCwwREFBMEQ7SUFDbkQsdUJBQXVCLENBQUMsYUFBcUI7UUFDbEQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUMvQyxPQUFPLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0lBQzVDLENBQUM7Q0FDRjtBQXpCRCx3Q0F5QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB0b0NhbWVsQ2FzZSwgdG9QYXNjYWxDYXNlLCB0b1NuYWtlQ2FzZSB9IGZyb20gXCJjb2RlbWFrZXJcIjtcbmltcG9ydCB7XG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlTmVzdGVkVHlwZSxcbiAgQXR0cmlidXRlVHlwZSxcbiAgQmxvY2ssXG4gIEJsb2NrVHlwZSxcbiAgaXNBdHRyaWJ1dGVOZXN0ZWRUeXBlLFxuICBpc05lc3RlZFR5cGVBdHRyaWJ1dGUsXG4gIFNjaGVtYSxcbn0gZnJvbSBcIi4vcHJvdmlkZXItc2NoZW1hXCI7XG5pbXBvcnQge1xuICBSZXNvdXJjZU1vZGVsLFxuICBBdHRyaWJ1dGVUeXBlTW9kZWwsXG4gIFN0cnVjdCxcbiAgU2NvcGUsXG4gIEF0dHJpYnV0ZU1vZGVsLFxufSBmcm9tIFwiLi9tb2RlbHNcIjtcbmltcG9ydCB7IGRldGVjdEF0dHJpYnV0ZUxvb3BzIH0gZnJvbSBcIi4vbG9vcC1kZXRlY3Rpb25cIjtcblxuY29uc3QgaXNSZXNlcnZlZENsYXNzTmFtZSA9IChjbGFzc05hbWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gW1wic3RyaW5nXCJdLmluY2x1ZGVzKGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpKTtcbn07XG5cbmNsYXNzIFBhcnNlciB7XG4gIHByaXZhdGUgc3RydWN0cyA9IG5ldyBBcnJheTxTdHJ1Y3Q+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjbGFzc05hbWVzOiBzdHJpbmdbXSkge31cblxuICBwcml2YXRlIHVuaXF1ZUNsYXNzTmFtZShjbGFzc05hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKHRoaXMuY2xhc3NOYW1lcy5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICBjbGFzc05hbWUgPSBgJHtjbGFzc05hbWV9QWA7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfVxuXG4gIHB1YmxpYyByZXNvdXJjZUZyb20oXG4gICAgcHJvdmlkZXI6IHN0cmluZyxcbiAgICB0eXBlOiBzdHJpbmcsXG4gICAgc2NoZW1hOiBTY2hlbWEsXG4gICAgdGVycmFmb3JtU2NoZW1hVHlwZTogc3RyaW5nXG4gICk6IFJlc291cmNlTW9kZWwge1xuICAgIGxldCBiYXNlTmFtZSA9IHR5cGU7XG4gICAgaWYgKGJhc2VOYW1lLnN0YXJ0c1dpdGgoYCR7cHJvdmlkZXJ9X2ApKSB7XG4gICAgICBiYXNlTmFtZSA9IGJhc2VOYW1lLnN1YnN0cihwcm92aWRlci5sZW5ndGggKyAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1Byb3ZpZGVyID0gdGVycmFmb3JtU2NoZW1hVHlwZSA9PT0gXCJwcm92aWRlclwiO1xuICAgIGlmIChpc1Byb3ZpZGVyKSB7XG4gICAgICBiYXNlTmFtZSA9IGAke3Byb3ZpZGVyfV8ke2Jhc2VOYW1lfWA7XG4gICAgICBpZiAoIShcImF0dHJpYnV0ZXNcIiBpbiBzY2hlbWEuYmxvY2spKSB7XG4gICAgICAgIHNjaGVtYS5ibG9jayA9IHsgYXR0cmlidXRlczoge30sIGJsb2NrX3R5cGVzOiB7fSB9O1xuICAgICAgfVxuICAgICAgLy8gc29tZWhvdyBtaXNzaW5nIGZyb20gcHJvdmlkZXIgc2NoZW1hXG4gICAgICBzY2hlbWEuYmxvY2suYXR0cmlidXRlc1tcImFsaWFzXCJdID0ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJBbGlhcyBuYW1lXCIsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpc1Jlc2VydmVkQ2xhc3NOYW1lKGJhc2VOYW1lKSkge1xuICAgICAgYmFzZU5hbWUgPSBgJHtiYXNlTmFtZX1fcmVzb3VyY2VgO1xuICAgIH1cblxuICAgIGNvbnN0IGNsYXNzTmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKHRvUGFzY2FsQ2FzZShiYXNlTmFtZSkpO1xuICAgIC8vIGF2b2lkIG5hbWluZyBjb2xsaXNpb24gLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2hhc2hpY29ycC90ZXJyYWZvcm0tY2RrL2lzc3Vlcy8yOTlcbiAgICBjb25zdCBjb25maWdTdHJ1Y3ROYW1lID0gdGhpcy51bmlxdWVDbGFzc05hbWUoYCR7Y2xhc3NOYW1lfUNvbmZpZ2ApO1xuICAgIGNvbnN0IGZpbGVOYW1lID1cbiAgICAgIGJhc2VOYW1lID09PSBcImluZGV4XCJcbiAgICAgICAgPyBcImluZGV4LXJlc291cmNlLnRzXCJcbiAgICAgICAgOiBgJHt0b1NuYWtlQ2FzZShiYXNlTmFtZSkucmVwbGFjZSgvXy9nLCBcIi1cIil9LnRzYDtcbiAgICBjb25zdCBmaWxlUGF0aCA9IGBwcm92aWRlcnMvJHt0b1NuYWtlQ2FzZShwcm92aWRlcil9LyR7ZmlsZU5hbWV9YDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gdGhpcy5yZW5kZXJBdHRyaWJ1dGVzRm9yQmxvY2soXG4gICAgICBuZXcgU2NvcGUoe1xuICAgICAgICBuYW1lOiBiYXNlTmFtZSxcbiAgICAgICAgaXNQcm92aWRlcixcbiAgICAgICAgcGFyZW50OiBpc1Byb3ZpZGVyXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IG5ldyBTY29wZSh7IG5hbWU6IHByb3ZpZGVyLCBpc1Byb3ZpZGVyOiB0cnVlIH0pLFxuICAgICAgfSksXG4gICAgICBzY2hlbWEuYmxvY2tcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gZ2V0U3RydWN0QXR0cmlidXRlKFxuICAgICAgYXR0cmlidXRlczogQXR0cmlidXRlTW9kZWxbXSxcbiAgICAgIHBhdGg6IHN0cmluZ1xuICAgICk6IEF0dHJpYnV0ZU1vZGVsIHtcbiAgICAgIGNvbnN0IFtmaXJzdCwgLi4ucmVzdF0gPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZmluZCgoYXR0KSA9PiB7XG4gICAgICAgIHJldHVybiBhdHQudGVycmFmb3JtTmFtZSA9PT0gZmlyc3Q7XG4gICAgICB9KTtcbiAgICAgIGlmICghYXR0cmlidXRlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIHRvIGZpbmQgcmVjdXJzaXZlIGF0dHJpYnV0ZSBhdCBwYXRoOiAke3BhdGh9YFxuICAgICAgICApO1xuICAgICAgaWYgKCFhdHRyaWJ1dGUudHlwZS5zdHJ1Y3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgdG8gZmluZCBzdHJ1Y3QgdHlwZSBhdHRyaWJ1dGUgYXQgcGF0aDogJHtwYXRofSBidXQgZ290ICR7YXR0cmlidXRlLnR5cGUudHlwZU5hbWV9YFxuICAgICAgICApO1xuICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSByZXR1cm4gYXR0cmlidXRlO1xuICAgICAgcmV0dXJuIGdldFN0cnVjdEF0dHJpYnV0ZShcbiAgICAgICAgYXR0cmlidXRlLnR5cGUuc3RydWN0Py5hdHRyaWJ1dGVzLFxuICAgICAgICByZXN0LmpvaW4oXCIuXCIpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEludHJvZHVjZSByZWN1cnNpb24gZm9yIHNvbWUgYXR0cmlidXRlc1xuICAgIGNvbnN0IHJlY3Vyc2l2ZUF0dHJpYnV0ZVBhdGhzID0gZGV0ZWN0QXR0cmlidXRlTG9vcHMoYXR0cmlidXRlcyk7XG5cbiAgICBPYmplY3QuZW50cmllcyhyZWN1cnNpdmVBdHRyaWJ1dGVQYXRocykuZm9yRWFjaChcbiAgICAgIChbYXR0cmlidXRlUGF0aCwgc3RydWN0UGF0aF0pID0+IHtcbiAgICAgICAgLy8gVE9ETzogYnVpbGQgdGhpcyB0byBiZSBhIGJpdCBtb3JlIGRlZmVuc2l2ZSAoZS5nLiByZW1vdmUgISBvcGVyYXRvcilcbiAgICAgICAgY29uc3QgcmVjdXJzaW9uVGFyZ2V0U3RydWN0QXR0cmlidXRlID0gZ2V0U3RydWN0QXR0cmlidXRlKFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgc3RydWN0UGF0aFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IGF0dHJpYnV0ZVBhdGguc3BsaXQoXCIuXCIpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gcGFydHMucG9wKCk7XG4gICAgICAgIGNvbnN0IHBhcmVudEF0dHJpYnV0ZSA9IGdldFN0cnVjdEF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBwYXJ0cy5qb2luKFwiLlwiKSk7XG4gICAgICAgIGNvbnN0IGluZGV4VG9SZXBsYWNlID1cbiAgICAgICAgICBwYXJlbnRBdHRyaWJ1dGUudHlwZS5zdHJ1Y3QhLmF0dHJpYnV0ZXMuZmluZEluZGV4KFxuICAgICAgICAgICAgKGF0dCkgPT4gYXR0LnRlcnJhZm9ybU5hbWUgPT09IGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoaW5kZXhUb1JlcGxhY2UgPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGZpbmQgYXR0cmlidXRlIGF0IHBhdGggXCIgKyBhdHRyaWJ1dGVQYXRoKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBdHRyaWJ1dGUgPVxuICAgICAgICAgIHBhcmVudEF0dHJpYnV0ZS50eXBlLnN0cnVjdCEuYXR0cmlidXRlc1tpbmRleFRvUmVwbGFjZV07XG5cbiAgICAgICAgcGFyZW50QXR0cmlidXRlLnR5cGUuc3RydWN0IS5hdHRyaWJ1dGVzW2luZGV4VG9SZXBsYWNlXSA9XG4gICAgICAgICAgcmVjdXJzaW9uVGFyZ2V0U3RydWN0QXR0cmlidXRlOyAvLyBpbnRyb2R1Y2UgcmVjdXJzaW9uXG5cbiAgICAgICAgLy8gdWdseSwgcGxzIGPMtmHMtmzMtmzMtiByZWZhY3RvciBtZSBtYXliZVxuICAgICAgICAvLyB3ZSBzdG9yZSBhbGwgc3RydWN0cyBpbiB0aGlzLnN0cnVjdHMg4oCTIG5vdyB3ZSBuZWVkIHRvIGRpc3Bvc2UgYWxsIHN0cnVjdHMgdGhhdCBhcmUgcGFydCBvZiBwcmV2aW91c0F0dHJpYnV0ZVxuICAgICAgICBjb25zdCBkaXNwb3NlU3RydWN0cyA9IChhdHRyOiBBdHRyaWJ1dGVNb2RlbCkgPT4ge1xuICAgICAgICAgIGlmIChhdHRyLnR5cGUuc3RydWN0KSB7XG4gICAgICAgICAgICBhdHRyLnR5cGUuc3RydWN0LmF0dHJpYnV0ZXMuZm9yRWFjaChkaXNwb3NlU3RydWN0cyk7XG4gICAgICAgICAgICB0aGlzLnN0cnVjdHMgPSB0aGlzLnN0cnVjdHMuZmlsdGVyKChzKSA9PiBzICE9PSBhdHRyLnR5cGUuc3RydWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZGlzcG9zZVN0cnVjdHMocHJldmlvdXNBdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCByZXNvdXJjZU1vZGVsID0gbmV3IFJlc291cmNlTW9kZWwoe1xuICAgICAgdGVycmFmb3JtVHlwZTogdHlwZSxcbiAgICAgIGJhc2VOYW1lLFxuICAgICAgZmlsZU5hbWUsXG4gICAgICBmaWxlUGF0aCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHRlcnJhZm9ybVNjaGVtYVR5cGUsXG4gICAgICBzdHJ1Y3RzOiB0aGlzLnN0cnVjdHMsXG4gICAgICBjb25maWdTdHJ1Y3ROYW1lLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc291cmNlTW9kZWw7XG4gIH1cblxuICBwcml2YXRlIHJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgc2NvcGU6IFNjb3BlW10sXG4gICAgYXR0cmlidXRlVHlwZTogQXR0cmlidXRlVHlwZSB8IEF0dHJpYnV0ZU5lc3RlZFR5cGUsXG4gICAgcGFyZW50S2luZD86IHN0cmluZ1xuICApOiBBdHRyaWJ1dGVUeXBlTW9kZWwge1xuICAgIGNvbnN0IHBhcmVudCA9IHNjb3BlW3Njb3BlLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxldmVsID0gc2NvcGUubGVuZ3RoO1xuICAgIGNvbnN0IGlzQ29tcHV0ZWQgPSAhIXNjb3BlLmZpbmQoKGUpID0+IGUuaXNDb21wdXRlZCA9PT0gdHJ1ZSk7XG4gICAgY29uc3QgaXNPcHRpb25hbCA9IHBhcmVudC5pc09wdGlvbmFsO1xuICAgIGNvbnN0IGlzUmVxdWlyZWQgPSBwYXJlbnQuaXNSZXF1aXJlZDtcblxuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3dpdGNoIChhdHRyaWJ1dGVUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVUeXBlTW9kZWwoXCJib29sZWFuXCIsIHtcbiAgICAgICAgICAgIGlzQ29tcHV0ZWQsXG4gICAgICAgICAgICBpc09wdGlvbmFsLFxuICAgICAgICAgICAgaXNSZXF1aXJlZCxcbiAgICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVUeXBlTW9kZWwoXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgaXNDb21wdXRlZCxcbiAgICAgICAgICAgIGlzT3B0aW9uYWwsXG4gICAgICAgICAgICBpc1JlcXVpcmVkLFxuICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVR5cGVNb2RlbChcIm51bWJlclwiLCB7XG4gICAgICAgICAgICBpc0NvbXB1dGVkLFxuICAgICAgICAgICAgaXNPcHRpb25hbCxcbiAgICAgICAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBcImR5bmFtaWNcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVR5cGVNb2RlbChcImFueVwiLCB7XG4gICAgICAgICAgICBpc0NvbXB1dGVkLFxuICAgICAgICAgICAgaXNPcHRpb25hbCxcbiAgICAgICAgICAgIGlzUmVxdWlyZWQsXG4gICAgICAgICAgICBsZXZlbCxcbiAgICAgICAgICAgIGlzTWFwOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcmltaXRpdmUgdHlwZSAke2F0dHJpYnV0ZVR5cGV9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cmlidXRlVHlwZSkpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVUeXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgYXJyYXlgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW2tpbmQsIHR5cGVdID0gYXR0cmlidXRlVHlwZTtcblxuICAgICAgaWYgKGtpbmQgPT09IFwic2V0XCIgfHwga2luZCA9PT0gXCJsaXN0XCIpIHtcbiAgICAgICAgY29uc3QgYXR0clR5cGUgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgdHlwZSBhcyBBdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgIGtpbmRcbiAgICAgICAgKTtcbiAgICAgICAgYXR0clR5cGUuaXNMaXN0ID0ga2luZCA9PT0gXCJsaXN0XCI7XG4gICAgICAgIGF0dHJUeXBlLmlzU2V0ID0ga2luZCA9PT0gXCJzZXRcIjtcbiAgICAgICAgYXR0clR5cGUuaXNDb21wdXRlZCA9IGlzQ29tcHV0ZWQ7XG4gICAgICAgIGF0dHJUeXBlLmlzT3B0aW9uYWwgPSBpc09wdGlvbmFsO1xuICAgICAgICBhdHRyVHlwZS5pc1JlcXVpcmVkID0gaXNSZXF1aXJlZDtcbiAgICAgICAgYXR0clR5cGUubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgcmV0dXJuIGF0dHJUeXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2luZCA9PT0gXCJtYXBcIikge1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgdHlwZSBhcyBBdHRyaWJ1dGVUeXBlLFxuICAgICAgICAgIGtpbmRcbiAgICAgICAgKTtcbiAgICAgICAgdmFsdWVUeXBlLmlzTWFwID0gdHJ1ZTtcbiAgICAgICAgdmFsdWVUeXBlLmlzQ29tcHV0ZWQgPSBpc0NvbXB1dGVkO1xuICAgICAgICB2YWx1ZVR5cGUuaXNPcHRpb25hbCA9IGlzT3B0aW9uYWw7XG4gICAgICAgIHZhbHVlVHlwZS5pc1JlcXVpcmVkID0gaXNSZXF1aXJlZDtcbiAgICAgICAgdmFsdWVUeXBlLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIHJldHVybiB2YWx1ZVR5cGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IG9iakF0dHJpYnV0ZXMgPSB0eXBlIGFzIHsgW25hbWU6IHN0cmluZ106IEF0dHJpYnV0ZVR5cGUgfTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlczogeyBbbmFtZTogc3RyaW5nXTogQXR0cmlidXRlIH0gPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqQXR0cmlidXRlcykpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW25hbWVdID0geyB0eXBlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RydWN0ID0gdGhpcy5hZGRBbm9ueW1vdXNTdHJ1Y3QoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICBwYXJlbnRLaW5kID8/IGtpbmRcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBuZXcgQXR0cmlidXRlVHlwZU1vZGVsKHN0cnVjdC5uYW1lLCB7XG4gICAgICAgICAgc3RydWN0LFxuICAgICAgICAgIGlzQ29tcHV0ZWQsXG4gICAgICAgICAgaXNPcHRpb25hbCxcbiAgICAgICAgICBpc1JlcXVpcmVkLFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0F0dHJpYnV0ZU5lc3RlZFR5cGUoYXR0cmlidXRlVHlwZSkpIHtcbiAgICAgIGxldCBpc0xpc3QgPSB1bmRlZmluZWQ7XG4gICAgICBsZXQgaXNTZXQgPSB1bmRlZmluZWQ7XG4gICAgICBsZXQgaXNNYXAgPSB1bmRlZmluZWQ7XG4gICAgICBzd2l0Y2ggKGF0dHJpYnV0ZVR5cGUubmVzdGluZ19tb2RlKSB7XG4gICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgICAgaXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIGlzU2V0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICAgIGlzTWFwID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNpbmdsZVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYG5lc3RlZF90eXBlIHdpdGggbmVzdGluZ19tb2RlIFwiJHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICAgICAgIH1cIiBub3Qgc3VwcG9ydGVkIChhdHRyaWJ1dGUgc2NvcGU6ICR7c2NvcGVcbiAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy5mdWxsTmFtZSlcbiAgICAgICAgICAgICAgLmpvaW4oXCIsXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3QgPSB0aGlzLmFkZEFub255bW91c1N0cnVjdChcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIGF0dHJpYnV0ZVR5cGUuYXR0cmlidXRlcyxcbiAgICAgICAgYXR0cmlidXRlVHlwZS5uZXN0aW5nX21vZGVcbiAgICAgICk7XG4gICAgICBjb25zdCBtb2RlbCA9IG5ldyBBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0Lm5hbWUsIHtcbiAgICAgICAgc3RydWN0LFxuICAgICAgICBpc0NvbXB1dGVkLFxuICAgICAgICBpc09wdGlvbmFsLFxuICAgICAgICBpc1JlcXVpcmVkLFxuICAgICAgICBsZXZlbCxcbiAgICAgICAgaXNMaXN0LFxuICAgICAgICBpc1NldCxcbiAgICAgICAgaXNNYXAsXG4gICAgICAgIGlzTmVzdGVkOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGVUeXBlKX1gKTtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXJBdHRyaWJ1dGVzRm9yQmxvY2socGFyZW50VHlwZTogU2NvcGUsIGJsb2NrOiBCbG9jaykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgQXJyYXk8QXR0cmlidXRlTW9kZWw+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFt0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lLCBhdHRdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgYmxvY2suYXR0cmlidXRlcyB8fCB7fVxuICAgICkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnJlbmRlckF0dHJpYnV0ZVR5cGUoXG4gICAgICAgIFtcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgICAgICBuYW1lOiB0ZXJyYWZvcm1BdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgICAgaXNDb21wdXRlZDogISFhdHQuY29tcHV0ZWQsXG4gICAgICAgICAgICBpc09wdGlvbmFsOiAhIWF0dC5vcHRpb25hbCxcbiAgICAgICAgICAgIGlzUmVxdWlyZWQ6ICEhYXR0LnJlcXVpcmVkLFxuICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBpc05lc3RlZFR5cGVBdHRyaWJ1dGUoYXR0KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgXSxcbiAgICAgICAgYXR0LnR5cGUgfHwgYXR0Lm5lc3RlZF90eXBlXG4gICAgICApO1xuICAgICAgY29uc3QgbmFtZSA9IHRvQ2FtZWxDYXNlKHRlcnJhZm9ybUF0dHJpYnV0ZU5hbWUpO1xuXG4gICAgICBhdHRyaWJ1dGVzLnB1c2goXG4gICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudFR5cGUuZnVsbE5hbWUodGVycmFmb3JtQXR0cmlidXRlTmFtZSksXG4gICAgICAgICAgZGVzY3JpcHRpb246IGF0dC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgIGNvbXB1dGVkOiAhIWF0dC5jb21wdXRlZCxcbiAgICAgICAgICBvcHRpb25hbDogISFhdHQub3B0aW9uYWwsXG4gICAgICAgICAgdGVycmFmb3JtTmFtZTogdGVycmFmb3JtQXR0cmlidXRlTmFtZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHByb3ZpZGVyOiBwYXJlbnRUeXBlLmlzUHJvdmlkZXIsXG4gICAgICAgICAgcmVxdWlyZWQ6ICEhYXR0LnJlcXVpcmVkLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtibG9ja1R5cGVOYW1lLCBibG9ja1R5cGVdIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgYmxvY2suYmxvY2tfdHlwZXMgfHwge31cbiAgICApKSB7XG4gICAgICAvLyBjcmVhdGUgYSBzdHJ1Y3QgZm9yIHRoaXMgYmxvY2tcbiAgICAgIGNvbnN0IGJsb2NrQXR0cmlidXRlcyA9IHRoaXMucmVuZGVyQXR0cmlidXRlc0ZvckJsb2NrKFxuICAgICAgICBuZXcgU2NvcGUoe1xuICAgICAgICAgIG5hbWU6IGAke3BhcmVudFR5cGUubmFtZX1fJHtibG9ja1R5cGVOYW1lfWAsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRUeXBlLFxuICAgICAgICAgIGlzUHJvdmlkZXI6IHBhcmVudFR5cGUuaXNQcm92aWRlcixcbiAgICAgICAgICBpbkJsb2NrVHlwZTogdHJ1ZSxcbiAgICAgICAgfSksXG4gICAgICAgIGJsb2NrVHlwZS5ibG9ja1xuICAgICAgKTtcblxuICAgICAgY29uc3QgYmxvY2tTdHJ1Y3QgPSB0aGlzLmFkZFN0cnVjdChcbiAgICAgICAgW1xuICAgICAgICAgIHBhcmVudFR5cGUsXG4gICAgICAgICAgbmV3IFNjb3BlKHtcbiAgICAgICAgICAgIG5hbWU6IGJsb2NrVHlwZU5hbWUsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFR5cGUsXG4gICAgICAgICAgICBpc1Byb3ZpZGVyOiBwYXJlbnRUeXBlLmlzUHJvdmlkZXIsXG4gICAgICAgICAgfSksXG4gICAgICAgIF0sXG4gICAgICAgIGJsb2NrQXR0cmlidXRlcyxcbiAgICAgICAgYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSxcbiAgICAgICAgKGJsb2NrVHlwZS5uZXN0aW5nX21vZGUgPT09IFwibGlzdFwiIHx8XG4gICAgICAgICAgYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICBibG9ja1R5cGUubWF4X2l0ZW1zID09PSAxXG4gICAgICApO1xuXG4gICAgICAvLyBkZWZpbmUgdGhlIGF0dHJpYnV0ZVxuICAgICAgYXR0cmlidXRlcy5wdXNoKFxuICAgICAgICBhdHRyaWJ1dGVGb3JCbG9ja1R5cGUoXG4gICAgICAgICAgYmxvY2tUeXBlTmFtZSxcbiAgICAgICAgICBibG9ja1R5cGUsXG4gICAgICAgICAgYmxvY2tTdHJ1Y3QsXG4gICAgICAgICAgcGFyZW50VHlwZS5pc1Byb3ZpZGVyLFxuICAgICAgICAgIHBhcmVudFR5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICAgIGZ1bmN0aW9uIGF0dHJpYnV0ZUZvckJsb2NrVHlwZShcbiAgICAgIHRlcnJhZm9ybU5hbWU6IHN0cmluZyxcbiAgICAgIGJsb2NrVHlwZTogQmxvY2tUeXBlLFxuICAgICAgc3RydWN0OiBTdHJ1Y3QsXG4gICAgICBpc1Byb3ZpZGVyOiBib29sZWFuLFxuICAgICAgcGFyZW50OiBTY29wZVxuICAgICk6IEF0dHJpYnV0ZU1vZGVsIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0b0NhbWVsQ2FzZSh0ZXJyYWZvcm1OYW1lKTtcbiAgICAgIGxldCBvcHRpb25hbDogYm9vbGVhbjtcbiAgICAgIGxldCByZXF1aXJlZDogYm9vbGVhbjtcbiAgICAgIHN3aXRjaCAoYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSkge1xuICAgICAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICAgICAgb3B0aW9uYWwgPSAhc3RydWN0LmF0dHJpYnV0ZXMuc29tZSgoeCkgPT4gIXgub3B0aW9uYWwpO1xuICAgICAgICAgIHJlcXVpcmVkID0gIXN0cnVjdC5hdHRyaWJ1dGVzLnNvbWUoKHgpID0+ICF4LnJlcXVpcmVkKTtcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU1vZGVsKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1OYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudC5mdWxsTmFtZSh0ZXJyYWZvcm1OYW1lKSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0Lm5hbWUsIHtcbiAgICAgICAgICAgICAgc3RydWN0LFxuICAgICAgICAgICAgICBpc09wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgICAgaXNSZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgICAgICAgICAgIGlzU2luZ2xlSXRlbTogdHJ1ZSxcbiAgICAgICAgICAgICAgaXNCbG9jazogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3RlcnJhZm9ybU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZU1vZGVsKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1OYW1lLFxuICAgICAgICAgICAgdGVycmFmb3JtRnVsbE5hbWU6IHBhcmVudC5mdWxsTmFtZSh0ZXJyYWZvcm1OYW1lKSxcbiAgICAgICAgICAgIHR5cGU6IG5ldyBBdHRyaWJ1dGVUeXBlTW9kZWwoc3RydWN0Lm5hbWUsIHtcbiAgICAgICAgICAgICAgc3RydWN0LFxuICAgICAgICAgICAgICBpc01hcDogdHJ1ZSxcbiAgICAgICAgICAgICAgaXNCbG9jazogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3RlcnJhZm9ybU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICAgICAgY29tcHV0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IGlzUHJvdmlkZXIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgY2FzZSBcImxpc3RcIjpcbiAgICAgICAgY2FzZSBcInNldFwiOlxuICAgICAgICAgIG9wdGlvbmFsID1cbiAgICAgICAgICAgIGJsb2NrVHlwZS5taW5faXRlbXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBibG9ja1R5cGUubWluX2l0ZW1zIDwgMTtcbiAgICAgICAgICByZXF1aXJlZCA9XG4gICAgICAgICAgICBibG9ja1R5cGUubWluX2l0ZW1zID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGJsb2NrVHlwZS5taW5faXRlbXMgPiAwO1xuICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlTW9kZWwoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHRlcnJhZm9ybU5hbWU6IHRlcnJhZm9ybU5hbWUsXG4gICAgICAgICAgICB0ZXJyYWZvcm1GdWxsTmFtZTogcGFyZW50LmZ1bGxOYW1lKHRlcnJhZm9ybU5hbWUpLFxuICAgICAgICAgICAgdHlwZTogbmV3IEF0dHJpYnV0ZVR5cGVNb2RlbChzdHJ1Y3QubmFtZSwge1xuICAgICAgICAgICAgICBzdHJ1Y3QsXG4gICAgICAgICAgICAgIGlzTGlzdDogYmxvY2tUeXBlLm5lc3RpbmdfbW9kZSA9PT0gXCJsaXN0XCIsXG4gICAgICAgICAgICAgIGlzU2V0OiBibG9ja1R5cGUubmVzdGluZ19tb2RlID09PSBcInNldFwiLFxuICAgICAgICAgICAgICBpc09wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgICAgICAgICAgaXNSZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgICAgICAgICAgIGlzU2luZ2xlSXRlbTogYmxvY2tUeXBlLm1heF9pdGVtcyA9PT0gMSxcbiAgICAgICAgICAgICAgaXNCbG9jazogdHJ1ZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke3RlcnJhZm9ybU5hbWV9IGJsb2NrYCxcbiAgICAgICAgICAgIHN0b3JhZ2VOYW1lOiBgXyR7bmFtZX1gLFxuICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICBjb21wdXRlZDogZmFsc2UsXG4gICAgICAgICAgICBwcm92aWRlcjogaXNQcm92aWRlcixcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcml2YXRlIGFkZEFub255bW91c1N0cnVjdChcbiAgICBzY29wZTogU2NvcGVbXSxcbiAgICBhdHRyczogeyBbbmFtZTogc3RyaW5nXTogQXR0cmlidXRlIH0sXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmdcbiAgKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG5ldyBBcnJheTxBdHRyaWJ1dGVNb2RlbD4oKTtcbiAgICBjb25zdCBwYXJlbnQgPSBzY29wZVtzY29wZS5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGNvbnN0IFt0ZXJyYWZvcm1OYW1lLCBhdHRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJzKSkge1xuICAgICAgLy8gbmVzdGVkIHR5cGVzIHN1cHBvcnQgY29tcHV0ZWQsIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBvbiBhdHRyaWJ1dGUgbGV2ZWxcbiAgICAgIC8vIGlmIHBhcmVudCBpcyBjb21wdXRlZCwgY2hpbGQgYWx3YXlzIGlzIGNvbXB1dGVkIGFzIHdlbGxcbiAgICAgIGNvbnN0IGNvbXB1dGVkID1cbiAgICAgICAgISFwYXJlbnQuaXNDb21wdXRlZCB8fCAocGFyZW50LmlzTmVzdGVkVHlwZSAmJiAhIWF0dC5jb21wdXRlZCk7XG4gICAgICBjb25zdCBvcHRpb25hbCA9IHBhcmVudC5pc05lc3RlZFR5cGVcbiAgICAgICAgPyAhIWF0dC5vcHRpb25hbFxuICAgICAgICA6ICEhcGFyZW50LmlzT3B0aW9uYWw7XG4gICAgICBjb25zdCByZXF1aXJlZCA9IHBhcmVudC5pc05lc3RlZFR5cGVcbiAgICAgICAgPyAhIWF0dC5yZXF1aXJlZFxuICAgICAgICA6ICEhcGFyZW50LmlzUmVxdWlyZWQ7XG4gICAgICBjb25zdCBuYW1lID0gdG9DYW1lbENhc2UodGVycmFmb3JtTmFtZSk7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2goXG4gICAgICAgIG5ldyBBdHRyaWJ1dGVNb2RlbCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBzdG9yYWdlTmFtZTogYF8ke25hbWV9YCxcbiAgICAgICAgICBjb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgZGVzY3JpcHRpb246IGF0dC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICAgICAgdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICB0ZXJyYWZvcm1GdWxsTmFtZTogcGFyZW50LmZ1bGxOYW1lKHRlcnJhZm9ybU5hbWUpLFxuICAgICAgICAgIHR5cGU6IHRoaXMucmVuZGVyQXR0cmlidXRlVHlwZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgLi4uc2NvcGUsXG4gICAgICAgICAgICAgIG5ldyBTY29wZSh7XG4gICAgICAgICAgICAgICAgbmFtZTogdGVycmFmb3JtTmFtZSxcbiAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgaXNQcm92aWRlcjogcGFyZW50LmlzUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgaXNDb21wdXRlZDogY29tcHV0ZWQsXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgaXNSZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgaXNOZXN0ZWRUeXBlOiBwYXJlbnQuaXNOZXN0ZWRUeXBlLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBhdHQudHlwZSB8fCBhdHQubmVzdGVkX3R5cGVcbiAgICAgICAgICApLFxuICAgICAgICAgIHByb3ZpZGVyOiBwYXJlbnQuaXNQcm92aWRlcixcbiAgICAgICAgICByZXF1aXJlZDogcmVxdWlyZWQsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZFN0cnVjdChzY29wZSwgYXR0cmlidXRlcywgbmVzdGluZ19tb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3RydWN0KFxuICAgIHNjb3BlOiBTY29wZVtdLFxuICAgIGF0dHJpYnV0ZXM6IEF0dHJpYnV0ZU1vZGVsW10sXG4gICAgbmVzdGluZ19tb2RlOiBzdHJpbmcsXG4gICAgaXNTaW5nbGVJdGVtID0gZmFsc2VcbiAgKSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMudW5pcXVlQ2xhc3NOYW1lKFxuICAgICAgdG9QYXNjYWxDYXNlKHNjb3BlLm1hcCgoeCkgPT4gdG9TbmFrZUNhc2UoeC5uYW1lKSkuam9pbihcIl9cIikpXG4gICAgKTtcbiAgICBjb25zdCBwYXJlbnQgPSBzY29wZVtzY29wZS5sZW5ndGggLSAxXTtcbiAgICAvLyBibG9ja1R5cGUubmVzdGluZ19tb2RlID0+IGxpc3Qvc2V0ICYgYmxvY2tUeXBlLm1heF9pdGVtcyA9PT0gMSxcbiAgICBjb25zdCBpc0NsYXNzID0gKHBhcmVudC5pc0NvbXB1dGVkICYmICFwYXJlbnQuaXNPcHRpb25hbCkgfHwgaXNTaW5nbGVJdGVtO1xuICAgIGNvbnN0IGlzQW5vbnltb3VzID0gdHJ1ZTtcbiAgICBjb25zdCBzID0gbmV3IFN0cnVjdChcbiAgICAgIG5hbWUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgaXNDbGFzcyxcbiAgICAgIGlzQW5vbnltb3VzLFxuICAgICAgaXNTaW5nbGVJdGVtLFxuICAgICAgbmVzdGluZ19tb2RlXG4gICAgKTtcbiAgICB0aGlzLnN0cnVjdHMucHVzaChzKTtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VQYXJzZXIge1xuICBwcml2YXRlIHVuaXF1ZUNsYXNzbmFtZXM6IHN0cmluZ1tdID0gW107XG4gIHByaXZhdGUgcmVzb3VyY2VzOiBSZWNvcmQ8c3RyaW5nLCBSZXNvdXJjZU1vZGVsPiA9IHt9O1xuXG4gIHB1YmxpYyBwYXJzZShcbiAgICBwcm92aWRlcjogc3RyaW5nLFxuICAgIHR5cGU6IHN0cmluZyxcbiAgICBzY2hlbWE6IFNjaGVtYSxcbiAgICB0ZXJyYWZvcm1UeXBlOiBzdHJpbmdcbiAgKTogUmVzb3VyY2VNb2RlbCB7XG4gICAgaWYgKHRoaXMucmVzb3VyY2VzW3R5cGVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXNbdHlwZV07XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLnVuaXF1ZUNsYXNzbmFtZXMpO1xuICAgIGNvbnN0IHJlc291cmNlID0gcGFyc2VyLnJlc291cmNlRnJvbShwcm92aWRlciwgdHlwZSwgc2NoZW1hLCB0ZXJyYWZvcm1UeXBlKTtcbiAgICB0aGlzLnJlc291cmNlc1t0eXBlXSA9IHJlc291cmNlO1xuICAgIHJldHVybiByZXNvdXJjZTtcbiAgfVxuXG4gIC8vIFVzZWQgYnkgY29udmVydCB0byBkZXRlcm1pbmUgdGhlIHJpZ2h0IG5hbWUgZm9yIGEgY2xhc3NcbiAgcHVibGljIGdldENsYXNzTmFtZUZvclJlc291cmNlKHRlcnJhZm9ybVR5cGU6IHN0cmluZykge1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5yZXNvdXJjZXNbdGVycmFmb3JtVHlwZV07XG4gICAgcmV0dXJuIHJlc291cmNlID8gcmVzb3VyY2UuY2xhc3NOYW1lIDogXCJcIjtcbiAgfVxufVxuIl19