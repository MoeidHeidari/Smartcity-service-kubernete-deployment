"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineGoModuleName = exports.ConstructsMaker = exports.ConstructsMakerProviderTarget = exports.ConstructsMakerModuleTarget = exports.ConstructsMakerTarget = exports.generateJsiiLanguage = exports.LANGUAGES = exports.Language = void 0;
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const codemaker_1 = require("codemaker");
const util_1 = require("../util");
const srcmak = __importStar(require("jsii-srcmak"));
const config_1 = require("../config");
const provider_schema_1 = require("./generator/provider-schema");
const provider_generator_1 = require("./generator/provider-generator");
const module_generator_1 = require("./generator/module-generator");
const config_2 = require("../config");
var Language;
(function (Language) {
    Language["TYPESCRIPT"] = "typescript";
    Language["PYTHON"] = "python";
    Language["CSHARP"] = "csharp";
    Language["JAVA"] = "java";
    Language["GO"] = "go";
})(Language = exports.Language || (exports.Language = {}));
exports.LANGUAGES = [
    Language.TYPESCRIPT,
    Language.PYTHON,
    Language.JAVA,
    Language.CSHARP,
    Language.GO,
];
async function generateJsiiLanguage(code, opts) {
    await util_1.mkdtemp(async (staging) => {
        // this is not typescript, so we generate in a staging directory and
        // use jsii-srcmak to compile and extract the language-specific source
        // into our project.
        await code.save(staging);
        await srcmak.srcmak(staging, opts);
    });
}
exports.generateJsiiLanguage = generateJsiiLanguage;
class ConstructsMakerTarget {
    constructor(constraint, targetLanguage) {
        this.constraint = constraint;
        this.targetLanguage = targetLanguage;
        if (this.constraint instanceof config_1.TerraformModuleConstraint) {
            this.fileName = `${this.typesPath(this.constraint.fileName)}.ts`;
        }
        else {
            this.fileName = `${this.typesPath(this.constraint.name)}.ts`;
        }
    }
    static from(constraint, targetLanguage) {
        if (constraint instanceof config_1.TerraformModuleConstraint) {
            return new ConstructsMakerModuleTarget(constraint, targetLanguage);
        }
        else {
            return new ConstructsMakerProviderTarget(constraint, targetLanguage);
        }
    }
    get version() {
        return this.constraint.version;
    }
    get source() {
        return this.constraint.source;
    }
    get name() {
        return this.constraint.name;
    }
    get fqn() {
        return this.constraint.fqn;
    }
    get namespace() {
        return this.constraint.namespace;
    }
    get moduleKey() {
        return this.fqn.replace(/\//gi, "_");
    }
}
exports.ConstructsMakerTarget = ConstructsMakerTarget;
class ConstructsMakerModuleTarget extends ConstructsMakerTarget {
    get isModule() {
        return true;
    }
    get isProvider() {
        return false;
    }
    get srcMakName() {
        switch (this.targetLanguage) {
            case Language.GO:
                return this.name.replace(/-/gi, "_");
            case Language.JAVA:
            case Language.CSHARP:
            case Language.PYTHON:
            default:
                return this.simplifiedName;
        }
    }
    get trackingPayload() {
        return {
            name: this.name,
            fullName: this.fqn,
            version: this.version,
            type: "module",
        };
    }
    typesPath(name) {
        return `modules/${name}`;
    }
    get simplifiedName() {
        var _a, _b;
        return ((_b = (_a = this.namespace) === null || _a === void 0 ? void 0 : _a.replace(/\//gi, ".").replace(/-/gi, "_")) !== null && _b !== void 0 ? _b : this.name);
    }
}
exports.ConstructsMakerModuleTarget = ConstructsMakerModuleTarget;
class ConstructsMakerProviderTarget extends ConstructsMakerTarget {
    get isModule() {
        return false;
    }
    get isProvider() {
        return true;
    }
    get srcMakName() {
        switch (this.targetLanguage) {
            case Language.JAVA:
                // "null" is a reserved keyword and can't be used as a package name
                return this.isNullProvider ? "nullprovider" : this.simplifiedName;
            case Language.CSHARP:
                // "null" is a reserved keyword and can't be used as a namespace
                return this.isNullProvider ? "Providers.Null" : this.simplifiedName;
            case Language.PYTHON:
                return this.simplifiedName;
            case Language.GO:
                return this.name.replace(/-/gi, "_");
            default:
                return this.constraint.fqn;
        }
    }
    get trackingPayload() {
        return {
            name: this.name,
            fullName: this.source,
            version: this.version,
            type: "provider",
        };
    }
    typesPath(name) {
        return `providers/${name}/index`;
    }
    get isNullProvider() {
        return this.constraint.name === "null";
    }
    get simplifiedName() {
        return this.name.replace(/\//gi, ".").replace(/-/gi, "_");
    }
}
exports.ConstructsMakerProviderTarget = ConstructsMakerProviderTarget;
class ConstructsMaker {
    constructor(options, constraints, reportTelemetry = () => { }) {
        this.options = options;
        this.constraints = constraints;
        this.reportTelemetry = reportTelemetry;
        this.codeMakerOutdir = path.resolve(this.options.codeMakerOutput);
        fs.mkdirpSync(this.codeMakerOutdir);
        this.code = new codemaker_1.CodeMaker();
        this.targets = this.constraints.map((constraint) => ConstructsMakerTarget.from(constraint, this.options.targetLanguage));
        this.versions = {};
    }
    async generateTypescript(target) {
        const endSchemaReadTimer = config_2.logTimespan(`Reading Schema for ${target.name}`);
        const schema = await provider_schema_1.readSchema([target]);
        endSchemaReadTimer();
        const endTSTimer = config_2.logTimespan(`Generate Typescript for ${target.name}`);
        if (target instanceof ConstructsMakerModuleTarget) {
            target.spec = schema.moduleSchema[target.moduleKey];
            new module_generator_1.ModuleGenerator(this.code, [target]);
        }
        if (target instanceof ConstructsMakerProviderTarget) {
            const generator = new provider_generator_1.TerraformProviderGenerator(this.code, schema.providerSchema);
            generator.generate(target);
            this.versions = { ...this.versions, ...generator.versions };
        }
        endTSTimer();
    }
    // emits a versions.json file with a map of the used version for each provider fqpn
    emitVersionsFile() {
        const filePath = "versions.json";
        this.code.openFile(filePath);
        this.code.line(JSON.stringify(this.versions, null, 2));
        this.code.closeFile(filePath);
        return filePath;
    }
    async generate() {
        var _a;
        const endGenerateTimer = config_2.logTimespan("Generate TS");
        await Promise.all(this.targets.map((target) => this.generateTypescript(target)));
        endGenerateTimer();
        this.emitVersionsFile();
        if (this.isJavascriptTarget) {
            await this.save();
        }
        if (!this.isJavascriptTarget || this.options.outputJsii) {
            for (const target of this.targets) {
                // these are the module dependencies we compile against
                const deps = ["@types/node", "constructs", "cdktf"];
                const opts = {
                    entrypoint: target.fileName,
                    deps: deps.map((dep) => path.dirname(require.resolve(`${dep}/package.json`))),
                    moduleKey: target.moduleKey,
                };
                // used for testing.
                if (this.options.outputJsii) {
                    opts.jsii = { path: this.options.outputJsii };
                }
                if (this.isPythonTarget) {
                    opts.python = {
                        outdir: this.codeMakerOutdir,
                        moduleName: target.srcMakName,
                    };
                }
                if (this.isJavaTarget) {
                    opts.java = {
                        outdir: ".",
                        package: `imports.${target.srcMakName}`,
                    };
                }
                if (this.isCsharpTarget) {
                    opts.csharp = {
                        outdir: this.codeMakerOutdir,
                        namespace: target.srcMakName,
                    };
                }
                if (this.isGoTarget) {
                    // TODO: check if needed for modules somehow
                    // const targetType = target.isProvider ? 'provider' : 'module';
                    // jsii-srcmac will produce a folder inside this dir named after "packageName"
                    // so this results in e.g. .gen/hashicorp/random
                    const outdir = path.join(this.codeMakerOutdir, (_a = target.namespace) !== null && _a !== void 0 ? _a : "");
                    opts.golang = {
                        outdir,
                        moduleName: await exports.determineGoModuleName(outdir),
                        packageName: target.srcMakName,
                    };
                }
                if (process.env.NODE_OPTIONS &&
                    !process.env.NODE_OPTIONS.includes(`--max-old-space-size`)) {
                    config_1.logger.warn(`found NODE_OPTIONS environment variable without a setting for --max-old-space-size.
The provider generation needs a substantial amount of memory (~13GB) for some providers and languages.
So cdktf-cli sets it to NODE_OPTIONS="--max-old-space-size=16384" by default. As your environment already contains
a NODE_OPTIONS variable, we won't override it. Hence, the provider generation might fail with an out of memory error.`);
                }
                else {
                    // increase memory to allow generating large providers (i.e. aws or azurerm for Go)
                    // srcmak is going to spawn a childprocess (for jsii-pacmak) which is going to be affected by this env var
                    process.env.NODE_OPTIONS = "--max-old-space-size=16384";
                }
                const jsiiTimer = config_2.logTimespan("JSII");
                await generateJsiiLanguage(this.code, opts);
                jsiiTimer();
            }
        }
        for (const target of this.targets) {
            await this.reportTelemetry({
                payload: target.trackingPayload,
                language: target.targetLanguage,
            });
        }
    }
    async save(outdir = this.codeMakerOutdir) {
        await this.code.save(outdir);
    }
    get isJavascriptTarget() {
        return this.options.targetLanguage === Language.TYPESCRIPT;
    }
    get isPythonTarget() {
        return this.options.targetLanguage === Language.PYTHON;
    }
    get isJavaTarget() {
        return this.options.targetLanguage === Language.JAVA;
    }
    get isCsharpTarget() {
        return this.options.targetLanguage === Language.CSHARP;
    }
    get isGoTarget() {
        return this.options.targetLanguage === Language.GO;
    }
}
exports.ConstructsMaker = ConstructsMaker;
/**
 * searches for the closest `go.mod` file and returns the nested go module name for `dir`
 * e.g. (/dir/.gen/) => cdk.tf/stack/.gen if the parent dir of .gen has a go.mod for "module cdk.tf/stack"
 *
 * @param dir the directory to start the search from (searches upwards)
 * @returns the package name for `dir`
 * @throws an Error if no go.mod was found
 */
exports.determineGoModuleName = async (dir) => {
    let previousDir;
    let currentDir = path.resolve(dir);
    do {
        let files = [];
        try {
            files = await fs.readdir(currentDir);
        }
        catch (e) {
            // directory might not exist yet, but we still walk upwards from there, so ignore 'ENOENT'
            if (e.code !== "ENOENT") {
                throw e;
            }
        }
        if (files.includes("go.mod")) {
            const file = path.resolve(currentDir, "go.mod");
            const gomod = await fs.readFile(file);
            const match = /^module\s*(\S*)\s*$/m.exec(gomod.toString());
            if (match && match[1]) {
                const childdir = path.relative(currentDir, dir).replace(/\\/g, "/"); // replace '\' with '/' for windows paths
                return childdir.length > 0 ? `${match[1]}/${childdir}` : match[1];
            }
            throw new Error(`Could not determine the root Go module name. Found ${file} but failed to regex match the module name directive`);
        }
        // go up one directory. As dirname('/') will return '/' we cancel the loop
        // as soon as the dir does not change anymore.
        previousDir = currentDir;
        currentDir = path.dirname(currentDir);
    } while (currentDir !== previousDir);
    throw new Error(`Could not determine the root Go module name. No go.mod found in ${dir} and any parent directories`);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RydWN0cy1tYWtlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnN0cnVjdHMtbWFrZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQiwyQ0FBNkI7QUFDN0IseUNBQXNDO0FBQ3RDLGtDQUFrQztBQUNsQyxvREFBc0M7QUFDdEMsc0NBSW1CO0FBQ25CLGlFQUF5RTtBQUN6RSx1RUFBNEU7QUFDNUUsbUVBQStEO0FBRS9ELHNDQUF3QztBQUV4QyxJQUFZLFFBTVg7QUFORCxXQUFZLFFBQVE7SUFDbEIscUNBQXlCLENBQUE7SUFDekIsNkJBQWlCLENBQUE7SUFDakIsNkJBQWlCLENBQUE7SUFDakIseUJBQWEsQ0FBQTtJQUNiLHFCQUFTLENBQUE7QUFDWCxDQUFDLEVBTlcsUUFBUSxHQUFSLGdCQUFRLEtBQVIsZ0JBQVEsUUFNbkI7QUFFWSxRQUFBLFNBQVMsR0FBRztJQUN2QixRQUFRLENBQUMsVUFBVTtJQUNuQixRQUFRLENBQUMsTUFBTTtJQUNmLFFBQVEsQ0FBQyxJQUFJO0lBQ2IsUUFBUSxDQUFDLE1BQU07SUFDZixRQUFRLENBQUMsRUFBRTtDQUNaLENBQUM7QUFFSyxLQUFLLFVBQVUsb0JBQW9CLENBQ3hDLElBQWUsRUFDZixJQUFvQjtJQUVwQixNQUFNLGNBQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUU7UUFDOUIsb0VBQW9FO1FBQ3BFLHNFQUFzRTtRQUN0RSxvQkFBb0I7UUFDcEIsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pCLE1BQU0sTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDckMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBWEQsb0RBV0M7QUFZRCxNQUFzQixxQkFBcUI7SUFHekMsWUFDa0IsVUFBeUMsRUFDekMsY0FBd0I7UUFEeEIsZUFBVSxHQUFW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QzlDLFdBQVcsR0FBRyxVQUFVLENBQUM7UUFDekIsVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDdkMsUUFBUSxVQUFVLEtBQUssV0FBVyxFQUFFO0lBRXJDLE1BQU0sSUFBSSxLQUFLLENBQ2IsbUVBQW1FLEdBQUcsNkJBQTZCLENBQ3BHLENBQUM7QUFDSixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IENvZGVNYWtlciB9IGZyb20gXCJjb2RlbWFrZXJcIjtcbmltcG9ydCB7IG1rZHRlbXAgfSBmcm9tIFwiLi4vdXRpbFwiO1xuaW1wb3J0ICogYXMgc3JjbWFrIGZyb20gXCJqc2lpLXNyY21ha1wiO1xuaW1wb3J0IHtcbiAgVGVycmFmb3JtTW9kdWxlQ29uc3RyYWludCxcbiAgVGVycmFmb3JtRGVwZW5kZW5jeUNvbnN0cmFpbnQsXG4gIGxvZ2dlcixcbn0gZnJvbSBcIi4uL2NvbmZpZ1wiO1xuaW1wb3J0IHsgUHJvdmlkZXJTY2hlbWEsIHJlYWRTY2hlbWEgfSBmcm9tIFwiLi9nZW5lcmF0b3IvcHJvdmlkZXItc2NoZW1hXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IE1vZHVsZUdlbmVyYXRvciB9IGZyb20gXCIuL2dlbmVyYXRvci9tb2R1bGUtZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBNb2R1bGVTY2hlbWEgfSBmcm9tIFwiLi9nZW5lcmF0b3IvbW9kdWxlLXNjaGVtYVwiO1xuaW1wb3J0IHsgbG9nVGltZXNwYW4gfSBmcm9tIFwiLi4vY29uZmlnXCI7XG5cbmV4cG9ydCBlbnVtIExhbmd1YWdlIHtcbiAgVFlQRVNDUklQVCA9IFwidHlwZXNjcmlwdFwiLFxuICBQWVRIT04gPSBcInB5dGhvblwiLFxuICBDU0hBUlAgPSBcImNzaGFycFwiLFxuICBKQVZBID0gXCJqYXZhXCIsXG4gIEdPID0gXCJnb1wiLFxufVxuXG5leHBvcnQgY29uc3QgTEFOR1VBR0VTID0gW1xuICBMYW5ndWFnZS5UWVBFU0NSSVBULFxuICBMYW5ndWFnZS5QWVRIT04sXG4gIExhbmd1YWdlLkpBVkEsXG4gIExhbmd1YWdlLkNTSEFSUCxcbiAgTGFuZ3VhZ2UuR08sXG5dO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVKc2lpTGFuZ3VhZ2UoXG4gIGNvZGU6IENvZGVNYWtlcixcbiAgb3B0czogc3JjbWFrLk9wdGlvbnNcbikge1xuICBhd2FpdCBta2R0ZW1wKGFzeW5jIChzdGFnaW5nKSA9PiB7XG4gICAgLy8gdGhpcyBpcyBub3QgdHlwZXNjcmlwdCwgc28gd2UgZ2VuZXJhdGUgaW4gYSBzdGFnaW5nIGRpcmVjdG9yeSBhbmRcbiAgICAvLyB1c2UganNpaS1zcmNtYWsgdG8gY29tcGlsZSBhbmQgZXh0cmFjdCB0aGUgbGFuZ3VhZ2Utc3BlY2lmaWMgc291cmNlXG4gICAgLy8gaW50byBvdXIgcHJvamVjdC5cbiAgICBhd2FpdCBjb2RlLnNhdmUoc3RhZ2luZyk7XG4gICAgYXdhaXQgc3JjbWFrLnNyY21hayhzdGFnaW5nLCBvcHRzKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0T3B0aW9ucyB7XG4gIHJlYWRvbmx5IHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZTtcbiAgcmVhZG9ubHkgY29kZU1ha2VyT3V0cHV0OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYXRoIHRvIGNvcHkgdGhlIG91dHB1dCAuanNpaSBmaWxlLlxuICAgKiBAZGVmYXVsdCAtIGpzaWkgZmlsZSBpcyBub3QgZW1pdHRlZFxuICAgKi9cbiAgcmVhZG9ubHkgb3V0cHV0SnNpaT86IHN0cmluZztcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbnN0cnVjdHNNYWtlclRhcmdldCB7XG4gIHB1YmxpYyByZWFkb25seSBmaWxlTmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBjb25zdHJhaW50OiBUZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlXG4gICkge1xuICAgIGlmICh0aGlzLmNvbnN0cmFpbnQgaW5zdGFuY2VvZiBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KSB7XG4gICAgICB0aGlzLmZpbGVOYW1lID0gYCR7dGhpcy50eXBlc1BhdGgodGhpcy5jb25zdHJhaW50LmZpbGVOYW1lKX0udHNgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbGVOYW1lID0gYCR7dGhpcy50eXBlc1BhdGgodGhpcy5jb25zdHJhaW50Lm5hbWUpfS50c2A7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHN0YXRpYyBmcm9tKFxuICAgIGNvbnN0cmFpbnQ6IFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50LFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApIHtcbiAgICBpZiAoY29uc3RyYWludCBpbnN0YW5jZW9mIFRlcnJhZm9ybU1vZHVsZUNvbnN0cmFpbnQpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0c01ha2VyTW9kdWxlVGFyZ2V0KGNvbnN0cmFpbnQsIHRhcmdldExhbmd1YWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldChjb25zdHJhaW50LCB0YXJnZXRMYW5ndWFnZSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQudmVyc2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQuc291cmNlO1xuICB9XG5cbiAgcHVibGljIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQubmFtZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZnFuKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cmFpbnQuZnFuO1xuICB9XG5cbiAgcHVibGljIGdldCBuYW1lc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5uYW1lc3BhY2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG1vZHVsZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5mcW4ucmVwbGFjZSgvXFwvL2dpLCBcIl9cIik7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgZ2V0IHNyY01ha05hbWUoKTogc3RyaW5nO1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0IGlzTW9kdWxlKCk6IGJvb2xlYW47XG4gIHB1YmxpYyBhYnN0cmFjdCBnZXQgaXNQcm92aWRlcigpOiBib29sZWFuO1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0IHRyYWNraW5nUGF5bG9hZCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0IHNpbXBsaWZpZWROYW1lKCk6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgdHlwZXNQYXRoKG5hbWU6IHN0cmluZyk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdHNNYWtlck1vZHVsZVRhcmdldCBleHRlbmRzIENvbnN0cnVjdHNNYWtlclRhcmdldCB7XG4gIHB1YmxpYyBzcGVjPzogTW9kdWxlU2NoZW1hO1xuXG4gIHB1YmxpYyBnZXQgaXNNb2R1bGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHVibGljIGdldCBzcmNNYWtOYW1lKCk6IHN0cmluZyB7XG4gICAgc3dpdGNoICh0aGlzLnRhcmdldExhbmd1YWdlKSB7XG4gICAgICBjYXNlIExhbmd1YWdlLkdPOlxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lLnJlcGxhY2UoLy0vZ2ksIFwiX1wiKTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuQ1NIQVJQOlxuICAgICAgY2FzZSBMYW5ndWFnZS5QWVRIT046XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0IHRyYWNraW5nUGF5bG9hZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgZnVsbE5hbWU6IHRoaXMuZnFuLFxuICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIixcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHR5cGVzUGF0aChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgbW9kdWxlcy8ke25hbWV9YDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc2ltcGxpZmllZE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5uYW1lc3BhY2U/LnJlcGxhY2UoL1xcLy9naSwgXCIuXCIpLnJlcGxhY2UoLy0vZ2ksIFwiX1wiKSA/PyB0aGlzLm5hbWVcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCBleHRlbmRzIENvbnN0cnVjdHNNYWtlclRhcmdldCB7XG4gIHB1YmxpYyBzcGVjPzogUHJvdmlkZXJTY2hlbWE7XG5cbiAgcHVibGljIGdldCBpc01vZHVsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZ2V0IGlzUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHNyY01ha05hbWUoKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHRoaXMudGFyZ2V0TGFuZ3VhZ2UpIHtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgICAgLy8gXCJudWxsXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGFuZCBjYW4ndCBiZSB1c2VkIGFzIGEgcGFja2FnZSBuYW1lXG4gICAgICAgIHJldHVybiB0aGlzLmlzTnVsbFByb3ZpZGVyID8gXCJudWxscHJvdmlkZXJcIiA6IHRoaXMuc2ltcGxpZmllZE5hbWU7XG4gICAgICBjYXNlIExhbmd1YWdlLkNTSEFSUDpcbiAgICAgICAgLy8gXCJudWxsXCIgaXMgYSByZXNlcnZlZCBrZXl3b3JkIGFuZCBjYW4ndCBiZSB1c2VkIGFzIGEgbmFtZXNwYWNlXG4gICAgICAgIHJldHVybiB0aGlzLmlzTnVsbFByb3ZpZGVyID8gXCJQcm92aWRlcnMuTnVsbFwiIDogdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuUFlUSE9OOlxuICAgICAgICByZXR1cm4gdGhpcy5zaW1wbGlmaWVkTmFtZTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuR086XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUucmVwbGFjZSgvLS9naSwgXCJfXCIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5mcW47XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGdldCB0cmFja2luZ1BheWxvYWQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIGZ1bGxOYW1lOiB0aGlzLnNvdXJjZSxcbiAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgIHR5cGU6IFwicHJvdmlkZXJcIixcbiAgICB9O1xuICB9XG5cbiAgcHJvdGVjdGVkIHR5cGVzUGF0aChuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgcHJvdmlkZXJzLyR7bmFtZX0vaW5kZXhgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNOdWxsUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RyYWludC5uYW1lID09PSBcIm51bGxcIjtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXQgc2ltcGxpZmllZE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lLnJlcGxhY2UoL1xcLy9naSwgXCIuXCIpLnJlcGxhY2UoLy0vZ2ksIFwiX1wiKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29uc3RydWN0c01ha2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlTWFrZXJPdXRkaXI6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSBjb2RlOiBDb2RlTWFrZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0czogQ29uc3RydWN0c01ha2VyVGFyZ2V0W107XG4gIHByaXZhdGUgdmVyc2lvbnM6IHsgW3Byb3ZpZGVyTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcHRpb25zOiBHZXRPcHRpb25zLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uc3RyYWludHM6IFRlcnJhZm9ybURlcGVuZGVuY3lDb25zdHJhaW50W10sXG4gICAgcHJpdmF0ZSByZWFkb25seSByZXBvcnRUZWxlbWV0cnk6IChwYXJhbXM6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9XG4gICkge1xuICAgIHRoaXMuY29kZU1ha2VyT3V0ZGlyID0gcGF0aC5yZXNvbHZlKHRoaXMub3B0aW9ucy5jb2RlTWFrZXJPdXRwdXQpO1xuICAgIGZzLm1rZGlycFN5bmModGhpcy5jb2RlTWFrZXJPdXRkaXIpO1xuICAgIHRoaXMuY29kZSA9IG5ldyBDb2RlTWFrZXIoKTtcbiAgICB0aGlzLnRhcmdldHMgPSB0aGlzLmNvbnN0cmFpbnRzLm1hcCgoY29uc3RyYWludCkgPT5cbiAgICAgIENvbnN0cnVjdHNNYWtlclRhcmdldC5mcm9tKGNvbnN0cmFpbnQsIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSlcbiAgICApO1xuICAgIHRoaXMudmVyc2lvbnMgPSB7fTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlc2NyaXB0KHRhcmdldDogQ29uc3RydWN0c01ha2VyVGFyZ2V0KSB7XG4gICAgY29uc3QgZW5kU2NoZW1hUmVhZFRpbWVyID0gbG9nVGltZXNwYW4oYFJlYWRpbmcgU2NoZW1hIGZvciAke3RhcmdldC5uYW1lfWApO1xuICAgIGNvbnN0IHNjaGVtYSA9IGF3YWl0IHJlYWRTY2hlbWEoW3RhcmdldF0pO1xuICAgIGVuZFNjaGVtYVJlYWRUaW1lcigpO1xuXG4gICAgY29uc3QgZW5kVFNUaW1lciA9IGxvZ1RpbWVzcGFuKGBHZW5lcmF0ZSBUeXBlc2NyaXB0IGZvciAke3RhcmdldC5uYW1lfWApO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RzTWFrZXJNb2R1bGVUYXJnZXQpIHtcbiAgICAgIHRhcmdldC5zcGVjID0gc2NoZW1hLm1vZHVsZVNjaGVtYVt0YXJnZXQubW9kdWxlS2V5XTtcbiAgICAgIG5ldyBNb2R1bGVHZW5lcmF0b3IodGhpcy5jb2RlLCBbdGFyZ2V0XSk7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0KSB7XG4gICAgICBjb25zdCBnZW5lcmF0b3IgPSBuZXcgVGVycmFmb3JtUHJvdmlkZXJHZW5lcmF0b3IoXG4gICAgICAgIHRoaXMuY29kZSxcbiAgICAgICAgc2NoZW1hLnByb3ZpZGVyU2NoZW1hXG4gICAgICApO1xuICAgICAgZ2VuZXJhdG9yLmdlbmVyYXRlKHRhcmdldCk7XG5cbiAgICAgIHRoaXMudmVyc2lvbnMgPSB7IC4uLnRoaXMudmVyc2lvbnMsIC4uLmdlbmVyYXRvci52ZXJzaW9ucyB9O1xuICAgIH1cblxuICAgIGVuZFRTVGltZXIoKTtcbiAgfVxuXG4gIC8vIGVtaXRzIGEgdmVyc2lvbnMuanNvbiBmaWxlIHdpdGggYSBtYXAgb2YgdGhlIHVzZWQgdmVyc2lvbiBmb3IgZWFjaCBwcm92aWRlciBmcXBuXG4gIHByaXZhdGUgZW1pdFZlcnNpb25zRmlsZSgpIHtcbiAgICBjb25zdCBmaWxlUGF0aCA9IFwidmVyc2lvbnMuanNvblwiO1xuICAgIHRoaXMuY29kZS5vcGVuRmlsZShmaWxlUGF0aCk7XG4gICAgdGhpcy5jb2RlLmxpbmUoSlNPTi5zdHJpbmdpZnkodGhpcy52ZXJzaW9ucywgbnVsbCwgMikpO1xuICAgIHRoaXMuY29kZS5jbG9zZUZpbGUoZmlsZVBhdGgpO1xuICAgIHJldHVybiBmaWxlUGF0aDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBlbmRHZW5lcmF0ZVRpbWVyID0gbG9nVGltZXNwYW4oXCJHZW5lcmF0ZSBUU1wiKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMudGFyZ2V0cy5tYXAoKHRhcmdldCkgPT4gdGhpcy5nZW5lcmF0ZVR5cGVzY3JpcHQodGFyZ2V0KSlcbiAgICApO1xuICAgIGVuZEdlbmVyYXRlVGltZXIoKTtcblxuICAgIHRoaXMuZW1pdFZlcnNpb25zRmlsZSgpO1xuXG4gICAgaWYgKHRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0KSB7XG4gICAgICBhd2FpdCB0aGlzLnNhdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNKYXZhc2NyaXB0VGFyZ2V0IHx8IHRoaXMub3B0aW9ucy5vdXRwdXRKc2lpKSB7XG4gICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0aGlzLnRhcmdldHMpIHtcbiAgICAgICAgLy8gdGhlc2UgYXJlIHRoZSBtb2R1bGUgZGVwZW5kZW5jaWVzIHdlIGNvbXBpbGUgYWdhaW5zdFxuICAgICAgICBjb25zdCBkZXBzID0gW1wiQHR5cGVzL25vZGVcIiwgXCJjb25zdHJ1Y3RzXCIsIFwiY2RrdGZcIl07XG4gICAgICAgIGNvbnN0IG9wdHM6IHNyY21hay5PcHRpb25zID0ge1xuICAgICAgICAgIGVudHJ5cG9pbnQ6IHRhcmdldC5maWxlTmFtZSxcbiAgICAgICAgICBkZXBzOiBkZXBzLm1hcCgoZGVwKSA9PlxuICAgICAgICAgICAgcGF0aC5kaXJuYW1lKHJlcXVpcmUucmVzb2x2ZShgJHtkZXB9L3BhY2thZ2UuanNvbmApKVxuICAgICAgICAgICksXG4gICAgICAgICAgbW9kdWxlS2V5OiB0YXJnZXQubW9kdWxlS2V5LFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHVzZWQgZm9yIHRlc3RpbmcuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3V0cHV0SnNpaSkge1xuICAgICAgICAgIG9wdHMuanNpaSA9IHsgcGF0aDogdGhpcy5vcHRpb25zLm91dHB1dEpzaWkgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzUHl0aG9uVGFyZ2V0KSB7XG4gICAgICAgICAgb3B0cy5weXRob24gPSB7XG4gICAgICAgICAgICBvdXRkaXI6IHRoaXMuY29kZU1ha2VyT3V0ZGlyLFxuICAgICAgICAgICAgbW9kdWxlTmFtZTogdGFyZ2V0LnNyY01ha05hbWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSmF2YVRhcmdldCkge1xuICAgICAgICAgIG9wdHMuamF2YSA9IHtcbiAgICAgICAgICAgIG91dGRpcjogXCIuXCIsIC8vIGdlbmVyYXRlZCBqYXZhIGZpbGVzIGFyZW4ndCBwYWNrYWdlZCwgc28ganVzdCBpbmNsdWRlIGRpcmVjdGx5IGluIGFwcFxuICAgICAgICAgICAgcGFja2FnZTogYGltcG9ydHMuJHt0YXJnZXQuc3JjTWFrTmFtZX1gLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NzaGFycFRhcmdldCkge1xuICAgICAgICAgIG9wdHMuY3NoYXJwID0ge1xuICAgICAgICAgICAgb3V0ZGlyOiB0aGlzLmNvZGVNYWtlck91dGRpcixcbiAgICAgICAgICAgIG5hbWVzcGFjZTogdGFyZ2V0LnNyY01ha05hbWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzR29UYXJnZXQpIHtcbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiBuZWVkZWQgZm9yIG1vZHVsZXMgc29tZWhvd1xuICAgICAgICAgIC8vIGNvbnN0IHRhcmdldFR5cGUgPSB0YXJnZXQuaXNQcm92aWRlciA/ICdwcm92aWRlcicgOiAnbW9kdWxlJztcblxuICAgICAgICAgIC8vIGpzaWktc3JjbWFjIHdpbGwgcHJvZHVjZSBhIGZvbGRlciBpbnNpZGUgdGhpcyBkaXIgbmFtZWQgYWZ0ZXIgXCJwYWNrYWdlTmFtZVwiXG4gICAgICAgICAgLy8gc28gdGhpcyByZXN1bHRzIGluIGUuZy4gLmdlbi9oYXNoaWNvcnAvcmFuZG9tXG4gICAgICAgICAgY29uc3Qgb3V0ZGlyID0gcGF0aC5qb2luKFxuICAgICAgICAgICAgdGhpcy5jb2RlTWFrZXJPdXRkaXIsXG4gICAgICAgICAgICB0YXJnZXQubmFtZXNwYWNlID8/IFwiXCJcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgb3B0cy5nb2xhbmcgPSB7XG4gICAgICAgICAgICBvdXRkaXIsXG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBhd2FpdCBkZXRlcm1pbmVHb01vZHVsZU5hbWUob3V0ZGlyKSwgLy8gZS5nLiBgZ2l0aHViLmNvbS9vcmcvdXNlcnByb2plY3QvLmdlbi9oYXNoaWNvcnBgXG4gICAgICAgICAgICBwYWNrYWdlTmFtZTogdGFyZ2V0LnNyY01ha05hbWUsIC8vIHBhY2thZ2Ugd2lsbCBiZSBuYW1lZCBlLmcuIHJhbmRvbSBmb3IgaGFzaGljb3JwL3JhbmRvbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9PUFRJT05TICYmXG4gICAgICAgICAgIXByb2Nlc3MuZW52Lk5PREVfT1BUSU9OUy5pbmNsdWRlcyhgLS1tYXgtb2xkLXNwYWNlLXNpemVgKVxuICAgICAgICApIHtcbiAgICAgICAgICBsb2dnZXIud2FybihgZm91bmQgTk9ERV9PUFRJT05TIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGhvdXQgYSBzZXR0aW5nIGZvciAtLW1heC1vbGQtc3BhY2Utc2l6ZS5cblRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG5lZWRzIGEgc3Vic3RhbnRpYWwgYW1vdW50IG9mIG1lbW9yeSAofjEzR0IpIGZvciBzb21lIHByb3ZpZGVycyBhbmQgbGFuZ3VhZ2VzLlxuU28gY2RrdGYtY2xpIHNldHMgaXQgdG8gTk9ERV9PUFRJT05TPVwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIiBieSBkZWZhdWx0LiBBcyB5b3VyIGVudmlyb25tZW50IGFscmVhZHkgY29udGFpbnNcbmEgTk9ERV9PUFRJT05TIHZhcmlhYmxlLCB3ZSB3b24ndCBvdmVycmlkZSBpdC4gSGVuY2UsIHRoZSBwcm92aWRlciBnZW5lcmF0aW9uIG1pZ2h0IGZhaWwgd2l0aCBhbiBvdXQgb2YgbWVtb3J5IGVycm9yLmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluY3JlYXNlIG1lbW9yeSB0byBhbGxvdyBnZW5lcmF0aW5nIGxhcmdlIHByb3ZpZGVycyAoaS5lLiBhd3Mgb3IgYXp1cmVybSBmb3IgR28pXG4gICAgICAgICAgLy8gc3JjbWFrIGlzIGdvaW5nIHRvIHNwYXduIGEgY2hpbGRwcm9jZXNzIChmb3IganNpaS1wYWNtYWspIHdoaWNoIGlzIGdvaW5nIHRvIGJlIGFmZmVjdGVkIGJ5IHRoaXMgZW52IHZhclxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfT1BUSU9OUyA9IFwiLS1tYXgtb2xkLXNwYWNlLXNpemU9MTYzODRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGpzaWlUaW1lciA9IGxvZ1RpbWVzcGFuKFwiSlNJSVwiKTtcbiAgICAgICAgYXdhaXQgZ2VuZXJhdGVKc2lpTGFuZ3VhZ2UodGhpcy5jb2RlLCBvcHRzKTtcbiAgICAgICAganNpaVRpbWVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGhpcy50YXJnZXRzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgIHBheWxvYWQ6IHRhcmdldC50cmFja2luZ1BheWxvYWQsXG4gICAgICAgIGxhbmd1YWdlOiB0YXJnZXQudGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNhdmUob3V0ZGlyID0gdGhpcy5jb2RlTWFrZXJPdXRkaXIpIHtcbiAgICBhd2FpdCB0aGlzLmNvZGUuc2F2ZShvdXRkaXIpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNKYXZhc2NyaXB0VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLlRZUEVTQ1JJUFQ7XG4gIH1cblxuICBwcml2YXRlIGdldCBpc1B5dGhvblRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRhcmdldExhbmd1YWdlID09PSBMYW5ndWFnZS5QWVRIT047XG4gIH1cblxuICBwcml2YXRlIGdldCBpc0phdmFUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuSkFWQTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzQ3NoYXJwVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGFyZ2V0TGFuZ3VhZ2UgPT09IExhbmd1YWdlLkNTSEFSUDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzR29UYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy50YXJnZXRMYW5ndWFnZSA9PT0gTGFuZ3VhZ2UuR087XG4gIH1cbn1cblxuLyoqXG4gKiBzZWFyY2hlcyBmb3IgdGhlIGNsb3Nlc3QgYGdvLm1vZGAgZmlsZSBhbmQgcmV0dXJucyB0aGUgbmVzdGVkIGdvIG1vZHVsZSBuYW1lIGZvciBgZGlyYFxuICogZS5nLiAoL2Rpci8uZ2VuLykgPT4gY2RrLnRmL3N0YWNrLy5nZW4gaWYgdGhlIHBhcmVudCBkaXIgb2YgLmdlbiBoYXMgYSBnby5tb2QgZm9yIFwibW9kdWxlIGNkay50Zi9zdGFja1wiXG4gKlxuICogQHBhcmFtIGRpciB0aGUgZGlyZWN0b3J5IHRvIHN0YXJ0IHRoZSBzZWFyY2ggZnJvbSAoc2VhcmNoZXMgdXB3YXJkcylcbiAqIEByZXR1cm5zIHRoZSBwYWNrYWdlIG5hbWUgZm9yIGBkaXJgXG4gKiBAdGhyb3dzIGFuIEVycm9yIGlmIG5vIGdvLm1vZCB3YXMgZm91bmRcbiAqL1xuZXhwb3J0IGNvbnN0IGRldGVybWluZUdvTW9kdWxlTmFtZSA9IGFzeW5jIChkaXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gIGxldCBwcmV2aW91c0RpcjtcbiAgbGV0IGN1cnJlbnREaXIgPSBwYXRoLnJlc29sdmUoZGlyKTtcblxuICBkbyB7XG4gICAgbGV0IGZpbGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBmaWxlcyA9IGF3YWl0IGZzLnJlYWRkaXIoY3VycmVudERpcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gZGlyZWN0b3J5IG1pZ2h0IG5vdCBleGlzdCB5ZXQsIGJ1dCB3ZSBzdGlsbCB3YWxrIHVwd2FyZHMgZnJvbSB0aGVyZSwgc28gaWdub3JlICdFTk9FTlQnXG4gICAgICBpZiAoZS5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWxlcy5pbmNsdWRlcyhcImdvLm1vZFwiKSkge1xuICAgICAgY29uc3QgZmlsZSA9IHBhdGgucmVzb2x2ZShjdXJyZW50RGlyLCBcImdvLm1vZFwiKTtcbiAgICAgIGNvbnN0IGdvbW9kID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZSk7XG4gICAgICBjb25zdCBtYXRjaCA9IC9ebW9kdWxlXFxzKihcXFMqKVxccyokL20uZXhlYyhnb21vZC50b1N0cmluZygpKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBjb25zdCBjaGlsZGRpciA9IHBhdGgucmVsYXRpdmUoY3VycmVudERpciwgZGlyKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTsgLy8gcmVwbGFjZSAnXFwnIHdpdGggJy8nIGZvciB3aW5kb3dzIHBhdGhzXG4gICAgICAgIHJldHVybiBjaGlsZGRpci5sZW5ndGggPiAwID8gYCR7bWF0Y2hbMV19LyR7Y2hpbGRkaXJ9YCA6IG1hdGNoWzFdO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gRm91bmQgJHtmaWxlfSBidXQgZmFpbGVkIHRvIHJlZ2V4IG1hdGNoIHRoZSBtb2R1bGUgbmFtZSBkaXJlY3RpdmVgXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBnbyB1cCBvbmUgZGlyZWN0b3J5LiBBcyBkaXJuYW1lKCcvJykgd2lsbCByZXR1cm4gJy8nIHdlIGNhbmNlbCB0aGUgbG9vcFxuICAgIC8vIGFzIHNvb24gYXMgdGhlIGRpciBkb2VzIG5vdCBjaGFuZ2UgYW55bW9yZS5cbiAgICBwcmV2aW91c0RpciA9IGN1cnJlbnREaXI7XG4gICAgY3VycmVudERpciA9IHBhdGguZGlybmFtZShjdXJyZW50RGlyKTtcbiAgfSB3aGlsZSAoY3VycmVudERpciAhPT0gcHJldmlvdXNEaXIpO1xuXG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgQ291bGQgbm90IGRldGVybWluZSB0aGUgcm9vdCBHbyBtb2R1bGUgbmFtZS4gTm8gZ28ubW9kIGZvdW5kIGluICR7ZGlyfSBhbmQgYW55IHBhcmVudCBkaXJlY3Rvcmllc2BcbiAgKTtcbn07XG4iXX0=