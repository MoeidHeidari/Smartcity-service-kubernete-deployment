"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegistryModule = exports.convertProject = exports.getTerraformConfigFromDir = exports.convert = exports.convertToTypescript = exports.parseProviderRequirements = exports.getParsedHcl = exports.CODE_MARKER = void 0;
const hcl2json_1 = require("@cdktf/hcl2json");
const provider_generator_1 = require("@cdktf/provider-generator");
Object.defineProperty(exports, "isRegistryModule", { enumerable: true, get: function () { return provider_generator_1.isRegistryModule; } });
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const path = __importStar(require("path"));
const glob = __importStar(require("glob"));
const fs = __importStar(require("fs"));
const graphology_1 = require("graphology");
const rosetta = __importStar(require("jsii-rosetta"));
const schema_1 = require("./schema");
const expressions_1 = require("./expressions");
const generation_1 = require("./generation");
const iteration_1 = require("./iteration");
const provider_1 = require("./provider");
const utils_1 = require("./utils");
var utils_2 = require("./utils");
Object.defineProperty(exports, "setLogger", { enumerable: true, get: function () { return utils_2.setLogger; } });
exports.CODE_MARKER = "// define resources here";
async function getParsedHcl(hcl) {
    utils_1.logger.debug(`Parsing HCL: ${hcl}`);
    // Get the JSON representation of the HCL
    let json;
    try {
        json = await hcl2json_1.parse("terraform.tf", hcl);
    }
    catch (err) {
        utils_1.logger.error(`Failed to parse HCL: ${err}`);
        throw new Error(`Error: Could not parse HCL, this means either that the HCL passed is invalid or that you found a bug. If the HCL seems valid, please file a bug under https://cdk.tf/bugs/new/convert`);
    }
    // Ensure the JSON representation matches the expected structure
    let plan;
    try {
        plan = schema_1.schema.parse(json);
    }
    catch (err) {
        throw new Error(`Error: HCL-JSON does not conform to schema. This is not expected, please file a bug under https://cdk.tf/bugs/new/convert
Please include this information:
${JSON.stringify(err.errors)}`);
    }
    return plan;
}
exports.getParsedHcl = getParsedHcl;
async function parseProviderRequirements(hcl) {
    utils_1.logger.debug("Parsing provider requirements");
    const plan = await getParsedHcl(hcl);
    return provider_1.getProviderRequirements(plan);
}
exports.parseProviderRequirements = parseProviderRequirements;
async function convertToTypescript(hcl, providerSchema) {
    var _a, _b, _c;
    utils_1.logger.debug("Converting to typescript");
    const plan = await getParsedHcl(hcl);
    utils_1.logger.debug(`Parsed HCL: ${JSON.stringify(plan, null, 2)}`);
    // Each key in the scope needs to be unique, therefore we save them in a set
    // Each variable needs to be unique as well, we save them in a record so we can identify if two variables are the same
    const scope = {
        providerSchema,
        providerGenerator: Object.keys(providerSchema.provider_schemas || {}).reduce((carry, fqpn) => {
            const providerGenerator = new provider_generator_1.TerraformProviderGenerator(new provider_generator_1.CodeMaker(), providerSchema);
            providerGenerator.buildResourceModels(fqpn);
            return { ...carry, [fqpn]: providerGenerator };
        }, {}),
        constructs: new Set(),
        variables: {},
    };
    const graph = new graphology_1.DirectedGraph();
    // Get all items in the JSON as a map of id to function that generates the AST
    // We will use this to construct the nodes for a dependency graph
    // We need to use a function here because the same node has different representation based on if it's referenced by another one
    const nodeMap = {
        ...iteration_1.forEachProvider(scope, plan.provider, generation_1.provider),
        ...iteration_1.forEachGlobal(scope, "var", plan.variable, generation_1.variable),
        // locals are a special case
        ...iteration_1.forEachGlobal(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, generation_1.local),
        ...iteration_1.forEachGlobal(scope, "out", plan.output, generation_1.output),
        ...iteration_1.forEachGlobal(scope, "module", plan.module, generation_1.modules),
        ...iteration_1.forEachNamespaced(scope, plan.resource, generation_1.resource),
        ...iteration_1.forEachNamespaced(scope, plan.data, generation_1.resource, "data"),
    };
    // Add all nodes to the dependency graph so we can detect if an edge is added for an unknown link
    Object.entries(nodeMap).forEach(([key, value]) => {
        utils_1.logger.debug(`Adding node '${key}' to graph`);
        graph.addNode(key, { code: value });
    });
    // Finding references becomes easier of the to be referenced ids are already known
    const nodeIds = Object.keys(nodeMap);
    async function addEdges(id, value) {
        (await expressions_1.findUsedReferences(nodeIds, value)).forEach((ref) => {
            if (!graph.hasDirectedEdge(ref.referencee.id, id) &&
                graph.hasNode(ref.referencee.id) // in case the referencee is a dynamic variable
            ) {
                if (!graph.hasNode(id)) {
                    throw new Error(`The dependency graph is expected to link from ${ref.referencee.id} to ${id} but ${id} does not exist. 
            These nodes exist: ${graph.nodes().join("\n")}`);
                }
                utils_1.logger.debug(`Adding edge from ${ref.referencee.id} to ${id}`);
                graph.addDirectedEdge(ref.referencee.id, id, { ref });
            }
        });
    }
    // We recursively inspect each resource value to find references to other values
    // We add these to a dependency graph so that the programming code has the right order
    async function addGlobalEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addProviderEdges(_scope, _key, id, value) {
        await addEdges(id, value);
    }
    async function addNamespacedEdges(_scope, _type, _key, id, value) {
        await addEdges(id, value);
    }
    await Promise.all(Object.values({
        ...iteration_1.forEachProvider(scope, plan.provider, addProviderEdges),
        ...iteration_1.forEachGlobal(scope, "var", plan.variable, addGlobalEdges),
        // locals are a special case
        ...iteration_1.forEachGlobal(scope, "local", Array.isArray(plan.locals)
            ? plan.locals.reduce((carry, locals) => ({ ...carry, ...locals }), {})
            : {}, addGlobalEdges),
        ...iteration_1.forEachGlobal(scope, "out", plan.output, addGlobalEdges),
        ...iteration_1.forEachGlobal(scope, "module", plan.module, addGlobalEdges),
        ...iteration_1.forEachNamespaced(scope, plan.resource, addNamespacedEdges),
        ...iteration_1.forEachNamespaced(scope, plan.data, addNamespacedEdges, "data"),
    }).map((addEdgesToGraph) => addEdgesToGraph(graph)));
    utils_1.logger.debug(`Graph: ${JSON.stringify(graph, null, 2)}`);
    utils_1.logger.debug(`Starting to assemble the typescript code`);
    // We traverse the dependency graph to get the unordered JSON nodes into an ordered array
    // where no node is referenced before it's defined
    // As we check that the nodes on both ends of an edge exist we can be sure
    // that no infinite loop exists, there can be no stray dependency on a node
    const expressions = [];
    let nodesToVisit = [...nodeIds];
    // This ensures we detect cycles and don't end up in an endless loop
    let nodesVisitedThisIteration = 0;
    do {
        nodesVisitedThisIteration = 0;
        // Find next nodes to visit
        const nodeExpressionGenerators = graph.mapNodes((nodeId, { code }) => {
            if (!nodesToVisit.includes(nodeId)) {
                return undefined;
            }
            const unresolvedDependencies = graph
                .inNeighbors(nodeId)
                .filter((item) => nodesToVisit.includes(item));
            if (unresolvedDependencies.length === 0) {
                nodesToVisit = nodesToVisit.filter((id) => nodeId !== id);
                nodesVisitedThisIteration = nodesVisitedThisIteration + 1;
                utils_1.logger.debug(`Visiting node ${nodeId}`);
                return code;
            }
            return undefined;
        });
        // Generate the code for the nodes
        for (const code of nodeExpressionGenerators) {
            if (code) {
                expressions.push(...(await code(graph)));
            }
        }
        utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    } while (nodesToVisit.length > 0 && nodesVisitedThisIteration != 0);
    utils_1.logger.debug(`${nodesToVisit.length} unvisited nodes: ${nodesToVisit.join(", ")}`);
    const backendExpressions = (await Promise.all(((_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.map((terraform) => generation_1.backendToExpression(scope, terraform.backend, nodeIds))) || [Promise.resolve([])])).reduce((carry, item) => [...carry, ...item], []);
    utils_1.logger.debug(`Using these backend expressions: ${JSON.stringify(backendExpressions, null, 2)}`);
    // We collect all module sources
    const moduleRequirements = [
        ...new Set(Object.values(plan.module || {}).reduce((carry, moduleBlock) => [
            ...carry,
            ...moduleBlock.reduce((arr, { source, version }) => [
                ...arr,
                version ? `${source}@${version}` : source,
            ], []),
        ], []) || []),
    ];
    utils_1.logger.debug(`Found these modules: ${JSON.stringify(moduleRequirements, null, 2)}`);
    // Variables, Outputs, and Backends are defined in the CDKTF project so we need to import from it
    // If none are used we don't want to leave a stray import
    const hasBackend = (_b = plan.terraform) === null || _b === void 0 ? void 0 : _b.some((tf) => Object.keys(tf.backend || {}).length > 0);
    const hasPlanOrOutputOrTerraformRemoteState = Object.keys({
        ...plan.variable,
        ...plan.output,
        ...(((_c = plan.data) === null || _c === void 0 ? void 0 : _c.terraform_remote_state) || {}),
    }).length > 0;
    const cdktfImports = hasBackend || hasPlanOrOutputOrTerraformRemoteState ? [generation_1.cdktfImport] : [];
    if (Object.keys(plan.variable || {}).length > 0 && expressions.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `Terraform Variables are not always the best fit for getting inputs in the context of Terraform CDK.
You can read more about this at https://cdk.tf/variables`);
    }
    const providerRequirements = provider_1.getProviderRequirements(plan);
    utils_1.logger.debug(`Found these provider requirements: ${JSON.stringify(providerRequirements, null, 2)}`);
    const providers = generation_1.providerImports(Object.keys(providerRequirements));
    if (providers.length > 0) {
        providers[0] = t.addComment(providers[0], "leading", `Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.`);
    }
    utils_1.logger.debug(`Using these providers: ${JSON.stringify(providers, null, 2)}`);
    // We add a comment if there are providers with missing schema information
    const providersLackingSchema = Object.keys(providerRequirements).filter((providerName) => !Object.keys(providerSchema.provider_schemas || {}).some((schemaName) => schemaName.endsWith(providerName)));
    utils_1.logger.debug(`${providersLackingSchema.length} providers lack schema information: ${providersLackingSchema.join(", ")}`);
    if (providersLackingSchema.length > 0) {
        expressions[0] = t.addComment(expressions[0], "leading", `The following providers are missing schema information and might need manual adjustments to synthesize correctly: ${providersLackingSchema.join(", ")}.
For a more precise conversion please use the --provider flag in convert.`);
    }
    // We split up the generated code so that users can have more control over what to insert where
    return {
        all: await generation_1.gen([
            ...cdktfImports,
            ...providers,
            ...generation_1.moduleImports(plan.module),
            ...(backendExpressions || []),
            ...expressions,
        ]),
        imports: await generation_1.gen([
            ...cdktfImports,
            ...providers,
            ...generation_1.moduleImports(plan.module),
        ]),
        code: await generation_1.gen([...(backendExpressions || []), ...expressions]),
        providers: Object.entries(providerRequirements).map(([source, version]) => version === "*" ? source : `${source}@${version}`),
        modules: moduleRequirements,
        // We track some usage data to make it easier to understand what is used
        stats: {
            numberOfModules: moduleRequirements.length,
            numberOfProviders: Object.keys(providerRequirements).length,
            resources: iteration_1.resourceStats(plan.resource || {}),
            data: iteration_1.resourceStats(plan.data || {}),
            convertedLines: hcl.split("\n").length,
        },
    };
}
exports.convertToTypescript = convertToTypescript;
const translations = {
    typescript: (file) => file.contents,
    python: (file) => rosetta.translateTypeScript(file, new rosetta.PythonVisitor()).translation,
    java: (file) => rosetta.translateTypeScript(file, new rosetta.JavaVisitor()).translation,
    csharp: (file) => rosetta.translateTypeScript(file, new rosetta.CSharpVisitor()).translation,
};
async function convert(hcl, { language, providerSchema }) {
    const fileName = "terraform.tf";
    const translater = translations[language];
    if (!translater) {
        throw new Error("Unsupported language used: " + language);
    }
    const tsCode = await convertToTypescript(hcl, providerSchema);
    return {
        ...tsCode,
        all: translater({ fileName, contents: tsCode.all }),
        imports: translater({ fileName, contents: tsCode.imports }),
        code: translater({ fileName, contents: tsCode.code }),
        stats: { ...tsCode.stats, language },
    };
}
exports.convert = convert;
function getTerraformConfigFromDir(importPath) {
    const absPath = path.resolve(importPath);
    const fileContents = glob
        .sync("./*.tf", { cwd: absPath })
        .map((p) => fs.readFileSync(path.resolve(absPath, p), "utf8"));
    return fileContents.join("\n");
}
exports.getTerraformConfigFromDir = getTerraformConfigFromDir;
async function convertProject(combinedHcl, { language, providerSchema }) {
    if (language !== "typescript") {
        throw new Error("Unsupported language used: " + language);
    }
    const { imports, code, providers, modules: tfModules, stats, } = await convert(combinedHcl, {
        language,
        providerSchema,
    });
    return {
        code: (inputMainFile) => {
            const importMainFile = [imports, inputMainFile].join("\n");
            const outputMainFile = importMainFile.replace(exports.CODE_MARKER, code);
            return prettier_1.default.format(outputMainFile, { parser: "babel" });
        },
        cdktfJson: (inputCdktfJson) => {
            const cdktfJson = { ...inputCdktfJson };
            cdktfJson.terraformProviders = providers;
            cdktfJson.terraformModules = tfModules;
            return cdktfJson;
        },
        stats,
    };
}
exports.convertProject = convertProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOENBQXdDO0FBQ3hDLGtFQUttQztBQTJkMUIsaUdBL2RQLHFDQUFnQixPQStkTztBQTFkekIsZ0RBQWtDO0FBQ2xDLHdEQUFnQztBQUNoQywyQ0FBNkI7QUFDN0IsMkNBQTZCO0FBQzdCLHVDQUF5QjtBQUN6QiwyQ0FBMkM7QUFDM0Msc0RBQXdDO0FBR3hDLHFDQUFrQztBQUNsQywrQ0FBbUQ7QUFDbkQsNkNBWXNCO0FBRXRCLDJDQUtxQjtBQUNyQix5Q0FBcUQ7QUFDckQsbUNBQWlDO0FBRWpDLGlDQUFvQztBQUEzQixrR0FBQSxTQUFTLE9BQUE7QUFFTCxRQUFBLFdBQVcsR0FBRywwQkFBMEIsQ0FBQztBQUUvQyxLQUFLLFVBQVUsWUFBWSxDQUFDLEdBQVc7SUFDNUMsY0FBTSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNwQyx5Q0FBeUM7SUFDekMsSUFBSSxJQUE2QixDQUFDO0lBQ2xDLElBQUk7UUFDRixJQUFJLEdBQUcsTUFBTSxnQkFBSyxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUN6QztJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osY0FBTSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUM1QyxNQUFNLElBQUksS0FBSyxDQUNiLHVMQUF1TCxDQUN4TCxDQUFDO0tBQ0g7SUFFRCxnRUFBZ0U7SUFDaEUsSUFBSSxJQUE0QixDQUFDO0lBQ2pDLElBQUk7UUFDRixJQUFJLEdBQUcsZUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMzQjtJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osTUFBTSxJQUFJLEtBQUssQ0FBQzs7RUFFbEIsSUFBSSxDQUFDLFNBQVMsQ0FBRSxHQUFrQixD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O1lBQzNELE1BQU0sY0FBYyxHQUFHLGNBQWMsQ0FBQyxPQUFPLENBQUMsbUJBQVcsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNqRSxPQUFPLGtCQUFRLENBQUMsTUFBTSxDQUFDLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzlELENBQUM7UUFDRCxTQUFTLEVBQUUsQ0FBQyxjQUF5QixFQUFFLEVBQUU7WUFDdkMsTUFBTSxTQUFTLEdBQUcsRUFBRSxHQUFHLGNBQWMsRUFBRSxDQUFDO1lBQ3hDLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxTQUFTLENBQUM7WUFDekMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztZQUN2QyxPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO1FBQ0QsS0FBSztLQUNOLENBQUM7QUFDSixDQUFDO0FBakNELHdDQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIkBjZGt0Zi9oY2wyanNvblwiO1xuaW1wb3J0IHtcbiAgaXNSZWdpc3RyeU1vZHVsZSxcbiAgUHJvdmlkZXJTY2hlbWEsXG4gIFRlcnJhZm9ybVByb3ZpZGVyR2VuZXJhdG9yLFxuICBDb2RlTWFrZXIsXG59IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgKiBhcyB0IGZyb20gXCJAYmFiZWwvdHlwZXNcIjtcbmltcG9ydCBwcmV0dGllciBmcm9tIFwicHJldHRpZXJcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIGdsb2IgZnJvbSBcImdsb2JcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgRGlyZWN0ZWRHcmFwaCB9IGZyb20gXCJncmFwaG9sb2d5XCI7XG5pbXBvcnQgKiBhcyByb3NldHRhIGZyb20gXCJqc2lpLXJvc2V0dGFcIjtcbmltcG9ydCAqIGFzIHogZnJvbSBcInpvZFwiO1xuXG5pbXBvcnQgeyBzY2hlbWEgfSBmcm9tIFwiLi9zY2hlbWFcIjtcbmltcG9ydCB7IGZpbmRVc2VkUmVmZXJlbmNlcyB9IGZyb20gXCIuL2V4cHJlc3Npb25zXCI7XG5pbXBvcnQge1xuICBiYWNrZW5kVG9FeHByZXNzaW9uLFxuICBjZGt0ZkltcG9ydCxcbiAgZ2VuLFxuICBsb2NhbCxcbiAgbW9kdWxlSW1wb3J0cyxcbiAgbW9kdWxlcyxcbiAgb3V0cHV0LFxuICBwcm92aWRlcixcbiAgcHJvdmlkZXJJbXBvcnRzLFxuICByZXNvdXJjZSxcbiAgdmFyaWFibGUsXG59IGZyb20gXCIuL2dlbmVyYXRpb25cIjtcbmltcG9ydCB7IFRlcnJhZm9ybVJlc291cmNlQmxvY2ssIFNjb3BlIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7XG4gIGZvckVhY2hQcm92aWRlcixcbiAgZm9yRWFjaEdsb2JhbCxcbiAgZm9yRWFjaE5hbWVzcGFjZWQsXG4gIHJlc291cmNlU3RhdHMsXG59IGZyb20gXCIuL2l0ZXJhdGlvblwiO1xuaW1wb3J0IHsgZ2V0UHJvdmlkZXJSZXF1aXJlbWVudHMgfSBmcm9tIFwiLi9wcm92aWRlclwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IHsgc2V0TG9nZ2VyIH0gZnJvbSBcIi4vdXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IENPREVfTUFSS0VSID0gXCIvLyBkZWZpbmUgcmVzb3VyY2VzIGhlcmVcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBhcnNlZEhjbChoY2w6IHN0cmluZykge1xuICBsb2dnZXIuZGVidWcoYFBhcnNpbmcgSENMOiAke2hjbH1gKTtcbiAgLy8gR2V0IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBIQ0xcbiAgbGV0IGpzb246IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICB0cnkge1xuICAgIGpzb24gPSBhd2FpdCBwYXJzZShcInRlcnJhZm9ybS50ZlwiLCBoY2wpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSBIQ0w6ICR7ZXJyfWApO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFcnJvcjogQ291bGQgbm90IHBhcnNlIEhDTCwgdGhpcyBtZWFucyBlaXRoZXIgdGhhdCB0aGUgSENMIHBhc3NlZCBpcyBpbnZhbGlkIG9yIHRoYXQgeW91IGZvdW5kIGEgYnVnLiBJZiB0aGUgSENMIHNlZW1zIHZhbGlkLCBwbGVhc2UgZmlsZSBhIGJ1ZyB1bmRlciBodHRwczovL2Nkay50Zi9idWdzL25ldy9jb252ZXJ0YFxuICAgICk7XG4gIH1cblxuICAvLyBFbnN1cmUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgc3RydWN0dXJlXG4gIGxldCBwbGFuOiB6LmluZmVyPHR5cGVvZiBzY2hlbWE+O1xuICB0cnkge1xuICAgIHBsYW4gPSBzY2hlbWEucGFyc2UoanNvbik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3I6IEhDTC1KU09OIGRvZXMgbm90IGNvbmZvcm0gdG8gc2NoZW1hLiBUaGlzIGlzIG5vdCBleHBlY3RlZCwgcGxlYXNlIGZpbGUgYSBidWcgdW5kZXIgaHR0cHM6Ly9jZGsudGYvYnVncy9uZXcvY29udmVydFxuUGxlYXNlIGluY2x1ZGUgdGhpcyBpbmZvcm1hdGlvbjpcbiR7SlNPTi5zdHJpbmdpZnkoKGVyciBhcyB6LlpvZEVycm9yKS5lcnJvcnMpfWApO1xuICB9XG5cbiAgcmV0dXJuIHBsYW47XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVByb3ZpZGVyUmVxdWlyZW1lbnRzKGhjbDogc3RyaW5nKSB7XG4gIGxvZ2dlci5kZWJ1ZyhcIlBhcnNpbmcgcHJvdmlkZXIgcmVxdWlyZW1lbnRzXCIpO1xuICBjb25zdCBwbGFuID0gYXdhaXQgZ2V0UGFyc2VkSGNsKGhjbCk7XG4gIHJldHVybiBnZXRQcm92aWRlclJlcXVpcmVtZW50cyhwbGFuKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb1R5cGVzY3JpcHQoXG4gIGhjbDogc3RyaW5nLFxuICBwcm92aWRlclNjaGVtYTogUHJvdmlkZXJTY2hlbWFcbikge1xuICBsb2dnZXIuZGVidWcoXCJDb252ZXJ0aW5nIHRvIHR5cGVzY3JpcHRcIik7XG4gIGNvbnN0IHBsYW4gPSBhd2FpdCBnZXRQYXJzZWRIY2woaGNsKTtcblxuICBsb2dnZXIuZGVidWcoYFBhcnNlZCBIQ0w6ICR7SlNPTi5zdHJpbmdpZnkocGxhbiwgbnVsbCwgMil9YCk7XG5cbiAgLy8gRWFjaCBrZXkgaW4gdGhlIHNjb3BlIG5lZWRzIHRvIGJlIHVuaXF1ZSwgdGhlcmVmb3JlIHdlIHNhdmUgdGhlbSBpbiBhIHNldFxuICAvLyBFYWNoIHZhcmlhYmxlIG5lZWRzIHRvIGJlIHVuaXF1ZSBhcyB3ZWxsLCB3ZSBzYXZlIHRoZW0gaW4gYSByZWNvcmQgc28gd2UgY2FuIGlkZW50aWZ5IGlmIHR3byB2YXJpYWJsZXMgYXJlIHRoZSBzYW1lXG4gIGNvbnN0IHNjb3BlOiBTY29wZSA9IHtcbiAgICBwcm92aWRlclNjaGVtYSxcbiAgICBwcm92aWRlckdlbmVyYXRvcjogT2JqZWN0LmtleXMoXG4gICAgICBwcm92aWRlclNjaGVtYS5wcm92aWRlcl9zY2hlbWFzIHx8IHt9XG4gICAgKS5yZWR1Y2UoKGNhcnJ5LCBmcXBuKSA9PiB7XG4gICAgICBjb25zdCBwcm92aWRlckdlbmVyYXRvciA9IG5ldyBUZXJyYWZvcm1Qcm92aWRlckdlbmVyYXRvcihcbiAgICAgICAgbmV3IENvZGVNYWtlcigpLFxuICAgICAgICBwcm92aWRlclNjaGVtYVxuICAgICAgKTtcbiAgICAgIHByb3ZpZGVyR2VuZXJhdG9yLmJ1aWxkUmVzb3VyY2VNb2RlbHMoZnFwbik7XG4gICAgICByZXR1cm4geyAuLi5jYXJyeSwgW2ZxcG5dOiBwcm92aWRlckdlbmVyYXRvciB9O1xuICAgIH0sIHt9KSxcbiAgICBjb25zdHJ1Y3RzOiBuZXcgU2V0PHN0cmluZz4oKSxcbiAgICB2YXJpYWJsZXM6IHt9LFxuICB9O1xuXG4gIGNvbnN0IGdyYXBoID0gbmV3IERpcmVjdGVkR3JhcGg8e1xuICAgIGNvZGU6IChcbiAgICAgIGc6IERpcmVjdGVkR3JhcGg8YW55PlxuICAgICkgPT4gUHJvbWlzZTxBcnJheTx0LlN0YXRlbWVudCB8IHQuVmFyaWFibGVEZWNsYXJhdGlvbj4+O1xuICB9PigpO1xuXG4gIC8vIEdldCBhbGwgaXRlbXMgaW4gdGhlIEpTT04gYXMgYSBtYXAgb2YgaWQgdG8gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIEFTVFxuICAvLyBXZSB3aWxsIHVzZSB0aGlzIHRvIGNvbnN0cnVjdCB0aGUgbm9kZXMgZm9yIGEgZGVwZW5kZW5jeSBncmFwaFxuICAvLyBXZSBuZWVkIHRvIHVzZSBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZSB0aGUgc2FtZSBub2RlIGhhcyBkaWZmZXJlbnQgcmVwcmVzZW50YXRpb24gYmFzZWQgb24gaWYgaXQncyByZWZlcmVuY2VkIGJ5IGFub3RoZXIgb25lXG4gIGNvbnN0IG5vZGVNYXA6IFJlY29yZDxcbiAgICBzdHJpbmcsXG4gICAgKGc6IHR5cGVvZiBncmFwaCkgPT4gUHJvbWlzZTxBcnJheTx0LlN0YXRlbWVudCB8IHQuVmFyaWFibGVEZWNsYXJhdGlvbj4+XG4gID4gPSB7XG4gICAgLi4uZm9yRWFjaFByb3ZpZGVyKHNjb3BlLCBwbGFuLnByb3ZpZGVyLCBwcm92aWRlciksXG4gICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJ2YXJcIiwgcGxhbi52YXJpYWJsZSwgdmFyaWFibGUpLFxuICAgIC8vIGxvY2FscyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAuLi5mb3JFYWNoR2xvYmFsKFxuICAgICAgc2NvcGUsXG4gICAgICBcImxvY2FsXCIsXG4gICAgICBBcnJheS5pc0FycmF5KHBsYW4ubG9jYWxzKVxuICAgICAgICA/IHBsYW4ubG9jYWxzLnJlZHVjZSgoY2FycnksIGxvY2FscykgPT4gKHsgLi4uY2FycnksIC4uLmxvY2FscyB9KSwge30pXG4gICAgICAgIDoge30sXG4gICAgICBsb2NhbFxuICAgICksXG4gICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJvdXRcIiwgcGxhbi5vdXRwdXQsIG91dHB1dCksXG4gICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJtb2R1bGVcIiwgcGxhbi5tb2R1bGUsIG1vZHVsZXMpLFxuICAgIC4uLmZvckVhY2hOYW1lc3BhY2VkKHNjb3BlLCBwbGFuLnJlc291cmNlLCByZXNvdXJjZSksXG4gICAgLi4uZm9yRWFjaE5hbWVzcGFjZWQoc2NvcGUsIHBsYW4uZGF0YSwgcmVzb3VyY2UsIFwiZGF0YVwiKSxcbiAgfTtcblxuICAvLyBBZGQgYWxsIG5vZGVzIHRvIHRoZSBkZXBlbmRlbmN5IGdyYXBoIHNvIHdlIGNhbiBkZXRlY3QgaWYgYW4gZWRnZSBpcyBhZGRlZCBmb3IgYW4gdW5rbm93biBsaW5rXG4gIE9iamVjdC5lbnRyaWVzKG5vZGVNYXApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGxvZ2dlci5kZWJ1ZyhgQWRkaW5nIG5vZGUgJyR7a2V5fScgdG8gZ3JhcGhgKTtcbiAgICBncmFwaC5hZGROb2RlKGtleSwgeyBjb2RlOiB2YWx1ZSB9KTtcbiAgfSk7XG5cbiAgLy8gRmluZGluZyByZWZlcmVuY2VzIGJlY29tZXMgZWFzaWVyIG9mIHRoZSB0byBiZSByZWZlcmVuY2VkIGlkcyBhcmUgYWxyZWFkeSBrbm93blxuICBjb25zdCBub2RlSWRzID0gT2JqZWN0LmtleXMobm9kZU1hcCk7XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZEVkZ2VzKGlkOiBzdHJpbmcsIHZhbHVlOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrKSB7XG4gICAgKGF3YWl0IGZpbmRVc2VkUmVmZXJlbmNlcyhub2RlSWRzLCB2YWx1ZSkpLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAhZ3JhcGguaGFzRGlyZWN0ZWRFZGdlKHJlZi5yZWZlcmVuY2VlLmlkLCBpZCkgJiZcbiAgICAgICAgZ3JhcGguaGFzTm9kZShyZWYucmVmZXJlbmNlZS5pZCkgLy8gaW4gY2FzZSB0aGUgcmVmZXJlbmNlZSBpcyBhIGR5bmFtaWMgdmFyaWFibGVcbiAgICAgICkge1xuICAgICAgICBpZiAoIWdyYXBoLmhhc05vZGUoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZXBlbmRlbmN5IGdyYXBoIGlzIGV4cGVjdGVkIHRvIGxpbmsgZnJvbSAke1xuICAgICAgICAgICAgICByZWYucmVmZXJlbmNlZS5pZFxuICAgICAgICAgICAgfSB0byAke2lkfSBidXQgJHtpZH0gZG9lcyBub3QgZXhpc3QuIFxuICAgICAgICAgICAgVGhlc2Ugbm9kZXMgZXhpc3Q6ICR7Z3JhcGgubm9kZXMoKS5qb2luKFwiXFxuXCIpfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBBZGRpbmcgZWRnZSBmcm9tICR7cmVmLnJlZmVyZW5jZWUuaWR9IHRvICR7aWR9YCk7XG4gICAgICAgIGdyYXBoLmFkZERpcmVjdGVkRWRnZShyZWYucmVmZXJlbmNlZS5pZCwgaWQsIHsgcmVmIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2UgcmVjdXJzaXZlbHkgaW5zcGVjdCBlYWNoIHJlc291cmNlIHZhbHVlIHRvIGZpbmQgcmVmZXJlbmNlcyB0byBvdGhlciB2YWx1ZXNcbiAgLy8gV2UgYWRkIHRoZXNlIHRvIGEgZGVwZW5kZW5jeSBncmFwaCBzbyB0aGF0IHRoZSBwcm9ncmFtbWluZyBjb2RlIGhhcyB0aGUgcmlnaHQgb3JkZXJcbiAgYXN5bmMgZnVuY3Rpb24gYWRkR2xvYmFsRWRnZXMoXG4gICAgX3Njb3BlOiBTY29wZSxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhd2FpdCBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZFByb3ZpZGVyRWRnZXMoXG4gICAgX3Njb3BlOiBTY29wZSxcbiAgICBfa2V5OiBzdHJpbmcsXG4gICAgaWQ6IHN0cmluZyxcbiAgICB2YWx1ZTogVGVycmFmb3JtUmVzb3VyY2VCbG9ja1xuICApIHtcbiAgICBhd2FpdCBhZGRFZGdlcyhpZCwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGFkZE5hbWVzcGFjZWRFZGdlcyhcbiAgICBfc2NvcGU6IFNjb3BlLFxuICAgIF90eXBlOiBzdHJpbmcsXG4gICAgX2tleTogc3RyaW5nLFxuICAgIGlkOiBzdHJpbmcsXG4gICAgdmFsdWU6IFRlcnJhZm9ybVJlc291cmNlQmxvY2tcbiAgKSB7XG4gICAgYXdhaXQgYWRkRWRnZXMoaWQsIHZhbHVlKTtcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIE9iamVjdC52YWx1ZXMoe1xuICAgICAgLi4uZm9yRWFjaFByb3ZpZGVyKHNjb3BlLCBwbGFuLnByb3ZpZGVyLCBhZGRQcm92aWRlckVkZ2VzKSxcbiAgICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwidmFyXCIsIHBsYW4udmFyaWFibGUsIGFkZEdsb2JhbEVkZ2VzKSxcbiAgICAgIC8vIGxvY2FscyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgIC4uLmZvckVhY2hHbG9iYWwoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBcImxvY2FsXCIsXG4gICAgICAgIEFycmF5LmlzQXJyYXkocGxhbi5sb2NhbHMpXG4gICAgICAgICAgPyBwbGFuLmxvY2Fscy5yZWR1Y2UoKGNhcnJ5LCBsb2NhbHMpID0+ICh7IC4uLmNhcnJ5LCAuLi5sb2NhbHMgfSksIHt9KVxuICAgICAgICAgIDoge30sXG4gICAgICAgIGFkZEdsb2JhbEVkZ2VzXG4gICAgICApLFxuICAgICAgLi4uZm9yRWFjaEdsb2JhbChzY29wZSwgXCJvdXRcIiwgcGxhbi5vdXRwdXQsIGFkZEdsb2JhbEVkZ2VzKSxcbiAgICAgIC4uLmZvckVhY2hHbG9iYWwoc2NvcGUsIFwibW9kdWxlXCIsIHBsYW4ubW9kdWxlLCBhZGRHbG9iYWxFZGdlcyksXG4gICAgICAuLi5mb3JFYWNoTmFtZXNwYWNlZChzY29wZSwgcGxhbi5yZXNvdXJjZSwgYWRkTmFtZXNwYWNlZEVkZ2VzKSxcbiAgICAgIC4uLmZvckVhY2hOYW1lc3BhY2VkKHNjb3BlLCBwbGFuLmRhdGEsIGFkZE5hbWVzcGFjZWRFZGdlcywgXCJkYXRhXCIpLFxuICAgIH0pLm1hcCgoYWRkRWRnZXNUb0dyYXBoKSA9PiBhZGRFZGdlc1RvR3JhcGgoZ3JhcGgpKVxuICApO1xuXG4gIGxvZ2dlci5kZWJ1ZyhgR3JhcGg6ICR7SlNPTi5zdHJpbmdpZnkoZ3JhcGgsIG51bGwsIDIpfWApO1xuICBsb2dnZXIuZGVidWcoYFN0YXJ0aW5nIHRvIGFzc2VtYmxlIHRoZSB0eXBlc2NyaXB0IGNvZGVgKTtcbiAgLy8gV2UgdHJhdmVyc2UgdGhlIGRlcGVuZGVuY3kgZ3JhcGggdG8gZ2V0IHRoZSB1bm9yZGVyZWQgSlNPTiBub2RlcyBpbnRvIGFuIG9yZGVyZWQgYXJyYXlcbiAgLy8gd2hlcmUgbm8gbm9kZSBpcyByZWZlcmVuY2VkIGJlZm9yZSBpdCdzIGRlZmluZWRcbiAgLy8gQXMgd2UgY2hlY2sgdGhhdCB0aGUgbm9kZXMgb24gYm90aCBlbmRzIG9mIGFuIGVkZ2UgZXhpc3Qgd2UgY2FuIGJlIHN1cmVcbiAgLy8gdGhhdCBubyBpbmZpbml0ZSBsb29wIGV4aXN0cywgdGhlcmUgY2FuIGJlIG5vIHN0cmF5IGRlcGVuZGVuY3kgb24gYSBub2RlXG4gIGNvbnN0IGV4cHJlc3Npb25zOiB0LlN0YXRlbWVudFtdID0gW107XG4gIGxldCBub2Rlc1RvVmlzaXQgPSBbLi4ubm9kZUlkc107XG4gIC8vIFRoaXMgZW5zdXJlcyB3ZSBkZXRlY3QgY3ljbGVzIGFuZCBkb24ndCBlbmQgdXAgaW4gYW4gZW5kbGVzcyBsb29wXG4gIGxldCBub2Rlc1Zpc2l0ZWRUaGlzSXRlcmF0aW9uID0gMDtcbiAgZG8ge1xuICAgIG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gPSAwO1xuXG4gICAgLy8gRmluZCBuZXh0IG5vZGVzIHRvIHZpc2l0XG4gICAgY29uc3Qgbm9kZUV4cHJlc3Npb25HZW5lcmF0b3JzID0gZ3JhcGgubWFwTm9kZXMoKG5vZGVJZCwgeyBjb2RlIH0pID0+IHtcbiAgICAgIGlmICghbm9kZXNUb1Zpc2l0LmluY2x1ZGVzKG5vZGVJZCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW5yZXNvbHZlZERlcGVuZGVuY2llcyA9IGdyYXBoXG4gICAgICAgIC5pbk5laWdoYm9ycyhub2RlSWQpXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0pID0+IG5vZGVzVG9WaXNpdC5pbmNsdWRlcyhpdGVtKSk7XG5cbiAgICAgIGlmICh1bnJlc29sdmVkRGVwZW5kZW5jaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2Rlc1RvVmlzaXQgPSBub2Rlc1RvVmlzaXQuZmlsdGVyKChpZCkgPT4gbm9kZUlkICE9PSBpZCk7XG4gICAgICAgIG5vZGVzVmlzaXRlZFRoaXNJdGVyYXRpb24gPSBub2Rlc1Zpc2l0ZWRUaGlzSXRlcmF0aW9uICsgMTtcblxuICAgICAgICBsb2dnZXIuZGVidWcoYFZpc2l0aW5nIG5vZGUgJHtub2RlSWR9YCk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBjb2RlIGZvciB0aGUgbm9kZXNcbiAgICBmb3IgKGNvbnN0IGNvZGUgb2Ygbm9kZUV4cHJlc3Npb25HZW5lcmF0b3JzKSB7XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICBleHByZXNzaW9ucy5wdXNoKC4uLihhd2FpdCBjb2RlKGdyYXBoKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGAke25vZGVzVG9WaXNpdC5sZW5ndGh9IHVudmlzaXRlZCBub2RlczogJHtub2Rlc1RvVmlzaXQuam9pbihcIiwgXCIpfWBcbiAgICApO1xuICB9IHdoaWxlIChub2Rlc1RvVmlzaXQubGVuZ3RoID4gMCAmJiBub2Rlc1Zpc2l0ZWRUaGlzSXRlcmF0aW9uICE9IDApO1xuXG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgJHtub2Rlc1RvVmlzaXQubGVuZ3RofSB1bnZpc2l0ZWQgbm9kZXM6ICR7bm9kZXNUb1Zpc2l0LmpvaW4oXCIsIFwiKX1gXG4gICk7XG5cbiAgY29uc3QgYmFja2VuZEV4cHJlc3Npb25zID0gKFxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgcGxhbi50ZXJyYWZvcm0/Lm1hcCgodGVycmFmb3JtKSA9PlxuICAgICAgICBiYWNrZW5kVG9FeHByZXNzaW9uKHNjb3BlLCB0ZXJyYWZvcm0uYmFja2VuZCwgbm9kZUlkcylcbiAgICAgICkgfHwgW1Byb21pc2UucmVzb2x2ZShbXSldXG4gICAgKVxuICApLnJlZHVjZSgoY2FycnksIGl0ZW0pID0+IFsuLi5jYXJyeSwgLi4uaXRlbV0sIFtdKTtcblxuICBsb2dnZXIuZGVidWcoXG4gICAgYFVzaW5nIHRoZXNlIGJhY2tlbmQgZXhwcmVzc2lvbnM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICBiYWNrZW5kRXhwcmVzc2lvbnMsXG4gICAgICBudWxsLFxuICAgICAgMlxuICAgICl9YFxuICApO1xuXG4gIC8vIFdlIGNvbGxlY3QgYWxsIG1vZHVsZSBzb3VyY2VzXG4gIGNvbnN0IG1vZHVsZVJlcXVpcmVtZW50cyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgT2JqZWN0LnZhbHVlcyhwbGFuLm1vZHVsZSB8fCB7fSkucmVkdWNlKFxuICAgICAgICAoY2FycnksIG1vZHVsZUJsb2NrKSA9PiBbXG4gICAgICAgICAgLi4uY2FycnksXG4gICAgICAgICAgLi4ubW9kdWxlQmxvY2sucmVkdWNlKFxuICAgICAgICAgICAgKGFyciwgeyBzb3VyY2UsIHZlcnNpb24gfSkgPT4gW1xuICAgICAgICAgICAgICAuLi5hcnIsXG4gICAgICAgICAgICAgIHZlcnNpb24gPyBgJHtzb3VyY2V9QCR7dmVyc2lvbn1gIDogc291cmNlLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtdIGFzIHN0cmluZ1tdXG4gICAgICAgICAgKSxcbiAgICAgICAgXSxcbiAgICAgICAgW10gYXMgc3RyaW5nW11cbiAgICAgICkgfHwgW11cbiAgICApLFxuICBdO1xuXG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgRm91bmQgdGhlc2UgbW9kdWxlczogJHtKU09OLnN0cmluZ2lmeShtb2R1bGVSZXF1aXJlbWVudHMsIG51bGwsIDIpfWBcbiAgKTtcblxuICAvLyBWYXJpYWJsZXMsIE91dHB1dHMsIGFuZCBCYWNrZW5kcyBhcmUgZGVmaW5lZCBpbiB0aGUgQ0RLVEYgcHJvamVjdCBzbyB3ZSBuZWVkIHRvIGltcG9ydCBmcm9tIGl0XG4gIC8vIElmIG5vbmUgYXJlIHVzZWQgd2UgZG9uJ3Qgd2FudCB0byBsZWF2ZSBhIHN0cmF5IGltcG9ydFxuICBjb25zdCBoYXNCYWNrZW5kID0gcGxhbi50ZXJyYWZvcm0/LnNvbWUoXG4gICAgKHRmKSA9PiBPYmplY3Qua2V5cyh0Zi5iYWNrZW5kIHx8IHt9KS5sZW5ndGggPiAwXG4gICk7XG4gIGNvbnN0IGhhc1BsYW5Pck91dHB1dE9yVGVycmFmb3JtUmVtb3RlU3RhdGUgPVxuICAgIE9iamVjdC5rZXlzKHtcbiAgICAgIC4uLnBsYW4udmFyaWFibGUsXG4gICAgICAuLi5wbGFuLm91dHB1dCxcbiAgICAgIC4uLihwbGFuLmRhdGE/LnRlcnJhZm9ybV9yZW1vdGVfc3RhdGUgfHwge30pLFxuICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgY29uc3QgY2RrdGZJbXBvcnRzID1cbiAgICBoYXNCYWNrZW5kIHx8IGhhc1BsYW5Pck91dHB1dE9yVGVycmFmb3JtUmVtb3RlU3RhdGUgPyBbY2RrdGZJbXBvcnRdIDogW107XG5cbiAgaWYgKE9iamVjdC5rZXlzKHBsYW4udmFyaWFibGUgfHwge30pLmxlbmd0aCA+IDAgJiYgZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xuICAgIGV4cHJlc3Npb25zWzBdID0gdC5hZGRDb21tZW50KFxuICAgICAgZXhwcmVzc2lvbnNbMF0sXG4gICAgICBcImxlYWRpbmdcIixcbiAgICAgIGBUZXJyYWZvcm0gVmFyaWFibGVzIGFyZSBub3QgYWx3YXlzIHRoZSBiZXN0IGZpdCBmb3IgZ2V0dGluZyBpbnB1dHMgaW4gdGhlIGNvbnRleHQgb2YgVGVycmFmb3JtIENESy5cbllvdSBjYW4gcmVhZCBtb3JlIGFib3V0IHRoaXMgYXQgaHR0cHM6Ly9jZGsudGYvdmFyaWFibGVzYFxuICAgICk7XG4gIH1cblxuICBjb25zdCBwcm92aWRlclJlcXVpcmVtZW50cyA9IGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzKHBsYW4pO1xuICBsb2dnZXIuZGVidWcoXG4gICAgYEZvdW5kIHRoZXNlIHByb3ZpZGVyIHJlcXVpcmVtZW50czogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgIHByb3ZpZGVyUmVxdWlyZW1lbnRzLFxuICAgICAgbnVsbCxcbiAgICAgIDJcbiAgICApfWBcbiAgKTtcblxuICBjb25zdCBwcm92aWRlcnMgPSBwcm92aWRlckltcG9ydHMoT2JqZWN0LmtleXMocHJvdmlkZXJSZXF1aXJlbWVudHMpKTtcbiAgaWYgKHByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgcHJvdmlkZXJzWzBdID0gdC5hZGRDb21tZW50KFxuICAgICAgcHJvdmlkZXJzWzBdLFxuICAgICAgXCJsZWFkaW5nXCIsXG4gICAgICBgUHJvdmlkZXIgYmluZGluZ3MgYXJlIGdlbmVyYXRlZCBieSBydW5uaW5nIGNka3RmIGdldC5cblNlZSBodHRwczovL2Nkay50Zi9wcm92aWRlci1nZW5lcmF0aW9uIGZvciBtb3JlIGRldGFpbHMuYFxuICAgICk7XG4gIH1cblxuICBsb2dnZXIuZGVidWcoYFVzaW5nIHRoZXNlIHByb3ZpZGVyczogJHtKU09OLnN0cmluZ2lmeShwcm92aWRlcnMsIG51bGwsIDIpfWApO1xuXG4gIC8vIFdlIGFkZCBhIGNvbW1lbnQgaWYgdGhlcmUgYXJlIHByb3ZpZGVycyB3aXRoIG1pc3Npbmcgc2NoZW1hIGluZm9ybWF0aW9uXG4gIGNvbnN0IHByb3ZpZGVyc0xhY2tpbmdTY2hlbWEgPSBPYmplY3Qua2V5cyhwcm92aWRlclJlcXVpcmVtZW50cykuZmlsdGVyKFxuICAgIChwcm92aWRlck5hbWUpID0+XG4gICAgICAhT2JqZWN0LmtleXMocHJvdmlkZXJTY2hlbWEucHJvdmlkZXJfc2NoZW1hcyB8fCB7fSkuc29tZSgoc2NoZW1hTmFtZSkgPT5cbiAgICAgICAgc2NoZW1hTmFtZS5lbmRzV2l0aChwcm92aWRlck5hbWUpXG4gICAgICApXG4gICk7XG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgJHtcbiAgICAgIHByb3ZpZGVyc0xhY2tpbmdTY2hlbWEubGVuZ3RoXG4gICAgfSBwcm92aWRlcnMgbGFjayBzY2hlbWEgaW5mb3JtYXRpb246ICR7cHJvdmlkZXJzTGFja2luZ1NjaGVtYS5qb2luKFwiLCBcIil9YFxuICApO1xuICBpZiAocHJvdmlkZXJzTGFja2luZ1NjaGVtYS5sZW5ndGggPiAwKSB7XG4gICAgZXhwcmVzc2lvbnNbMF0gPSB0LmFkZENvbW1lbnQoXG4gICAgICBleHByZXNzaW9uc1swXSxcbiAgICAgIFwibGVhZGluZ1wiLFxuICAgICAgYFRoZSBmb2xsb3dpbmcgcHJvdmlkZXJzIGFyZSBtaXNzaW5nIHNjaGVtYSBpbmZvcm1hdGlvbiBhbmQgbWlnaHQgbmVlZCBtYW51YWwgYWRqdXN0bWVudHMgdG8gc3ludGhlc2l6ZSBjb3JyZWN0bHk6ICR7cHJvdmlkZXJzTGFja2luZ1NjaGVtYS5qb2luKFxuICAgICAgICBcIiwgXCJcbiAgICAgICl9LlxuRm9yIGEgbW9yZSBwcmVjaXNlIGNvbnZlcnNpb24gcGxlYXNlIHVzZSB0aGUgLS1wcm92aWRlciBmbGFnIGluIGNvbnZlcnQuYFxuICAgICk7XG4gIH1cblxuICAvLyBXZSBzcGxpdCB1cCB0aGUgZ2VuZXJhdGVkIGNvZGUgc28gdGhhdCB1c2VycyBjYW4gaGF2ZSBtb3JlIGNvbnRyb2wgb3ZlciB3aGF0IHRvIGluc2VydCB3aGVyZVxuICByZXR1cm4ge1xuICAgIGFsbDogYXdhaXQgZ2VuKFtcbiAgICAgIC4uLmNka3RmSW1wb3J0cyxcbiAgICAgIC4uLnByb3ZpZGVycyxcbiAgICAgIC4uLm1vZHVsZUltcG9ydHMocGxhbi5tb2R1bGUpLFxuICAgICAgLi4uKGJhY2tlbmRFeHByZXNzaW9ucyB8fCBbXSksXG4gICAgICAuLi5leHByZXNzaW9ucyxcbiAgICBdKSxcbiAgICBpbXBvcnRzOiBhd2FpdCBnZW4oW1xuICAgICAgLi4uY2RrdGZJbXBvcnRzLFxuICAgICAgLi4ucHJvdmlkZXJzLFxuICAgICAgLi4ubW9kdWxlSW1wb3J0cyhwbGFuLm1vZHVsZSksXG4gICAgXSksXG4gICAgY29kZTogYXdhaXQgZ2VuKFsuLi4oYmFja2VuZEV4cHJlc3Npb25zIHx8IFtdKSwgLi4uZXhwcmVzc2lvbnNdKSxcbiAgICBwcm92aWRlcnM6IE9iamVjdC5lbnRyaWVzKHByb3ZpZGVyUmVxdWlyZW1lbnRzKS5tYXAoKFtzb3VyY2UsIHZlcnNpb25dKSA9PlxuICAgICAgdmVyc2lvbiA9PT0gXCIqXCIgPyBzb3VyY2UgOiBgJHtzb3VyY2V9QCR7dmVyc2lvbn1gXG4gICAgKSxcbiAgICBtb2R1bGVzOiBtb2R1bGVSZXF1aXJlbWVudHMsXG4gICAgLy8gV2UgdHJhY2sgc29tZSB1c2FnZSBkYXRhIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHVuZGVyc3RhbmQgd2hhdCBpcyB1c2VkXG4gICAgc3RhdHM6IHtcbiAgICAgIG51bWJlck9mTW9kdWxlczogbW9kdWxlUmVxdWlyZW1lbnRzLmxlbmd0aCxcbiAgICAgIG51bWJlck9mUHJvdmlkZXJzOiBPYmplY3Qua2V5cyhwcm92aWRlclJlcXVpcmVtZW50cykubGVuZ3RoLFxuICAgICAgcmVzb3VyY2VzOiByZXNvdXJjZVN0YXRzKHBsYW4ucmVzb3VyY2UgfHwge30pLFxuICAgICAgZGF0YTogcmVzb3VyY2VTdGF0cyhwbGFuLmRhdGEgfHwge30pLFxuICAgICAgY29udmVydGVkTGluZXM6IGhjbC5zcGxpdChcIlxcblwiKS5sZW5ndGgsXG4gICAgfSxcbiAgfTtcbn1cblxudHlwZSBGaWxlID0geyBjb250ZW50czogc3RyaW5nOyBmaWxlTmFtZTogc3RyaW5nIH07XG5jb25zdCB0cmFuc2xhdGlvbnMgPSB7XG4gIHR5cGVzY3JpcHQ6IChmaWxlOiBGaWxlKSA9PiBmaWxlLmNvbnRlbnRzLFxuICBweXRob246IChmaWxlOiBGaWxlKSA9PlxuICAgIHJvc2V0dGEudHJhbnNsYXRlVHlwZVNjcmlwdChmaWxlLCBuZXcgcm9zZXR0YS5QeXRob25WaXNpdG9yKCkpLnRyYW5zbGF0aW9uLFxuICBqYXZhOiAoZmlsZTogRmlsZSkgPT5cbiAgICByb3NldHRhLnRyYW5zbGF0ZVR5cGVTY3JpcHQoZmlsZSwgbmV3IHJvc2V0dGEuSmF2YVZpc2l0b3IoKSkudHJhbnNsYXRpb24sXG4gIGNzaGFycDogKGZpbGU6IEZpbGUpID0+XG4gICAgcm9zZXR0YS50cmFuc2xhdGVUeXBlU2NyaXB0KGZpbGUsIG5ldyByb3NldHRhLkNTaGFycFZpc2l0b3IoKSkudHJhbnNsYXRpb24sXG59O1xuXG50eXBlIENvbnZlcnRPcHRpb25zID0ge1xuICBsYW5ndWFnZToga2V5b2YgdHlwZW9mIHRyYW5zbGF0aW9ucztcbiAgcHJvdmlkZXJTY2hlbWE6IFByb3ZpZGVyU2NoZW1hO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnZlcnQoXG4gIGhjbDogc3RyaW5nLFxuICB7IGxhbmd1YWdlLCBwcm92aWRlclNjaGVtYSB9OiBDb252ZXJ0T3B0aW9uc1xuKSB7XG4gIGNvbnN0IGZpbGVOYW1lID0gXCJ0ZXJyYWZvcm0udGZcIjtcbiAgY29uc3QgdHJhbnNsYXRlciA9IHRyYW5zbGF0aW9uc1tsYW5ndWFnZV07XG5cbiAgaWYgKCF0cmFuc2xhdGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgbGFuZ3VhZ2UgdXNlZDogXCIgKyBsYW5ndWFnZSk7XG4gIH1cbiAgY29uc3QgdHNDb2RlID0gYXdhaXQgY29udmVydFRvVHlwZXNjcmlwdChoY2wsIHByb3ZpZGVyU2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50c0NvZGUsXG4gICAgYWxsOiB0cmFuc2xhdGVyKHsgZmlsZU5hbWUsIGNvbnRlbnRzOiB0c0NvZGUuYWxsIH0pLFxuICAgIGltcG9ydHM6IHRyYW5zbGF0ZXIoeyBmaWxlTmFtZSwgY29udGVudHM6IHRzQ29kZS5pbXBvcnRzIH0pLFxuICAgIGNvZGU6IHRyYW5zbGF0ZXIoeyBmaWxlTmFtZSwgY29udGVudHM6IHRzQ29kZS5jb2RlIH0pLFxuICAgIHN0YXRzOiB7IC4uLnRzQ29kZS5zdGF0cywgbGFuZ3VhZ2UgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlcnJhZm9ybUNvbmZpZ0Zyb21EaXIoaW1wb3J0UGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGFic1BhdGggPSBwYXRoLnJlc29sdmUoaW1wb3J0UGF0aCk7XG4gIGNvbnN0IGZpbGVDb250ZW50cyA9IGdsb2JcbiAgICAuc3luYyhcIi4vKi50ZlwiLCB7IGN3ZDogYWJzUGF0aCB9KVxuICAgIC5tYXAoKHApID0+IGZzLnJlYWRGaWxlU3luYyhwYXRoLnJlc29sdmUoYWJzUGF0aCwgcCksIFwidXRmOFwiKSk7XG5cbiAgcmV0dXJuIGZpbGVDb250ZW50cy5qb2luKFwiXFxuXCIpO1xufVxuXG50eXBlIENka3RmSnNvbiA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+ICYge1xuICB0ZXJyYWZvcm1Qcm92aWRlcnM6IGFueVtdO1xuICB0ZXJyYWZvcm1Nb2R1bGVzOiBhbnlbXTtcbn07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udmVydFByb2plY3QoXG4gIGNvbWJpbmVkSGNsOiBzdHJpbmcsXG4gIHsgbGFuZ3VhZ2UsIHByb3ZpZGVyU2NoZW1hIH06IENvbnZlcnRPcHRpb25zXG4pIHtcbiAgaWYgKGxhbmd1YWdlICE9PSBcInR5cGVzY3JpcHRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGxhbmd1YWdlIHVzZWQ6IFwiICsgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGltcG9ydHMsXG4gICAgY29kZSxcbiAgICBwcm92aWRlcnMsXG4gICAgbW9kdWxlczogdGZNb2R1bGVzLFxuICAgIHN0YXRzLFxuICB9ID0gYXdhaXQgY29udmVydChjb21iaW5lZEhjbCwge1xuICAgIGxhbmd1YWdlLFxuICAgIHByb3ZpZGVyU2NoZW1hLFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGNvZGU6IChpbnB1dE1haW5GaWxlOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGltcG9ydE1haW5GaWxlID0gW2ltcG9ydHMsIGlucHV0TWFpbkZpbGVdLmpvaW4oXCJcXG5cIik7XG4gICAgICBjb25zdCBvdXRwdXRNYWluRmlsZSA9IGltcG9ydE1haW5GaWxlLnJlcGxhY2UoQ09ERV9NQVJLRVIsIGNvZGUpO1xuICAgICAgcmV0dXJuIHByZXR0aWVyLmZvcm1hdChvdXRwdXRNYWluRmlsZSwgeyBwYXJzZXI6IFwiYmFiZWxcIiB9KTtcbiAgICB9LFxuICAgIGNka3RmSnNvbjogKGlucHV0Q2RrdGZKc29uOiBDZGt0Zkpzb24pID0+IHtcbiAgICAgIGNvbnN0IGNka3RmSnNvbiA9IHsgLi4uaW5wdXRDZGt0Zkpzb24gfTtcbiAgICAgIGNka3RmSnNvbi50ZXJyYWZvcm1Qcm92aWRlcnMgPSBwcm92aWRlcnM7XG4gICAgICBjZGt0Zkpzb24udGVycmFmb3JtTW9kdWxlcyA9IHRmTW9kdWxlcztcbiAgICAgIHJldHVybiBjZGt0Zkpzb247XG4gICAgfSxcbiAgICBzdGF0cyxcbiAgfTtcbn1cblxuZXhwb3J0IHsgaXNSZWdpc3RyeU1vZHVsZSB9O1xuIl19