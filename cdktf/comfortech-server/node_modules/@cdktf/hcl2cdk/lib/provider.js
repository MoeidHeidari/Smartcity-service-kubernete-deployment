"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProviderRequirements = exports.getTypeAtPath = exports.getAttributeTypeAtPath = exports.getBlockTypeAtPath = exports.getFullProviderName = void 0;
function getFullProviderName(schema, providerName) {
    return Object.keys(schema.provider_schemas || {}).find((name) => name.endsWith(providerName));
}
exports.getFullProviderName = getFullProviderName;
function getResourceAtPath(schema, path) {
    var _a;
    const parts = path.split(".");
    if (parts.length < 2) {
        // Too short to be a valid path
        return null;
    }
    const isDataSource = parts[0] === "data";
    if (isDataSource) {
        parts.shift();
    }
    const providerName = parts.shift();
    const resourceName = parts.shift();
    const fullProviderName = getFullProviderName(schema, providerName);
    const fullResourceName = `${providerName}_${resourceName}`;
    if (!fullProviderName) {
        // No provider found with that name
        return null;
    }
    const provider = (_a = schema.provider_schemas) === null || _a === void 0 ? void 0 : _a[fullProviderName];
    if (!provider) {
        // Could not find provider
        return null;
    }
    if (resourceName.endsWith("Provider")) {
        // This is a provider
        return { resource: provider.provider, parts };
    }
    const resources = isDataSource
        ? provider.data_source_schemas
        : provider.resource_schemas;
    const resource = resources[fullResourceName];
    if (!resource) {
        // Could not find resource
        return null;
    }
    if (parts.length === 0) {
        // No property specified
        return null;
    }
    return { resource, parts };
}
function getBlockTypeAtPath(schema, path) {
    const resourceSchema = getResourceAtPath(schema, path);
    if (!resourceSchema) {
        return null;
    }
    const { resource, parts } = resourceSchema;
    let currentSchema = resource;
    do {
        const part = parts.shift();
        if (!currentSchema ||
            !currentSchema.block ||
            !currentSchema.block.block_types ||
            !currentSchema.block.block_types.hasOwnProperty(part)) {
            // Found no block property with this name, there could be an attribute, but we don't care at this point
            return null;
        }
        currentSchema = currentSchema.block.block_types[part];
    } while (parts.length > 0);
    return currentSchema;
}
exports.getBlockTypeAtPath = getBlockTypeAtPath;
function getAttributeTypeAtPath(schema, path) {
    const resourceSchema = getResourceAtPath(schema, path);
    if (!resourceSchema) {
        return null;
    }
    const { resource, parts } = resourceSchema;
    const attributes = resource.block.attributes;
    if (parts.length !== 1) {
        // No property specified or the path is too deep
        return null;
    }
    const attributeName = parts[0];
    return attributes[attributeName];
}
exports.getAttributeTypeAtPath = getAttributeTypeAtPath;
// Resolves within a list of objects, e.g.
// "ingress": {
//   "type": [
//     "set",
//     [
//       "object",
//       {
//         "cidr_blocks": [
//           "list",
//           "string"
//         ],
function resolveAttribute(att, parts) {
    if (parts.length === 0) {
        return att.type;
    }
    let currentAtt = att.type;
    do {
        const part = parts.shift();
        if (Array.isArray(currentAtt) &&
            currentAtt.length === 2 &&
            (currentAtt[0] === "set" || currentAtt[0] === "list") &&
            Array.isArray(currentAtt[1]) &&
            currentAtt[1][0] === "object") {
            // We can go deeper into the set/list
            const x = currentAtt[1][1][part];
            currentAtt = x;
        }
        else {
            return null;
        }
    } while (parts.length > 0);
    if (parts.length === 0) {
        return currentAtt;
    }
    else {
        // We could not go deeper but the item path expects more parts, we have to return null
        return null;
    }
}
function getTypeAtPath(schema, path) {
    const resourceSchema = getResourceAtPath(schema, path);
    if (!resourceSchema) {
        return null;
    }
    const { resource, parts } = resourceSchema;
    let currentSchema = resource;
    do {
        const part = parts.shift();
        // Go into blocks if possible
        if (currentSchema &&
            currentSchema.block &&
            currentSchema.block.block_types &&
            currentSchema.block.block_types.hasOwnProperty(part)) {
            currentSchema = currentSchema.block.block_types[part];
            break;
        }
        // Go into attributes if possible
        if (currentSchema &&
            currentSchema.block &&
            currentSchema.block.attributes &&
            currentSchema.block.attributes.hasOwnProperty(part)) {
            return resolveAttribute(currentSchema.block.attributes[part], parts);
        }
        // No block or attribute found but parts left
        return null;
    } while (parts.length > 0);
    return currentSchema;
}
exports.getTypeAtPath = getTypeAtPath;
function getProviderRequirements(plan) {
    var _a;
    // In Terraform one can implicitly define the provider by using resources of that type
    const explicitProviders = Object.keys(plan.provider || {});
    const implicitProviders = Object.keys({ ...plan.resource, ...plan.data })
        .filter((type) => type !== "terraform_remote_state")
        .map((type) => type.split("_")[0]);
    const providerRequirements = Array.from(new Set([...explicitProviders, ...implicitProviders])).reduce((carry, req) => ({ ...carry, [req]: "*" }), {});
    (_a = plan.terraform) === null || _a === void 0 ? void 0 : _a.forEach(({ required_providers }) => (required_providers || []).forEach((providerBlock) => Object.entries(providerBlock).forEach(([key, value]) => {
        let name, version;
        if (typeof value === "string") {
            name = key;
            version = value;
        }
        else {
            name = value.source;
            version = value.version;
        }
        if (!name) {
            return;
        }
        // implicitly only the last part of the path is used (e.g. docker for kreuzwerker/docker)
        const parts = name.split("/");
        if (parts.length > 1) {
            delete providerRequirements[parts.pop() || ""];
        }
        providerRequirements[name] = version || "*";
    })));
    return providerRequirements;
}
exports.getProviderRequirements = getProviderRequirements;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJwcm92aWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFZQSxTQUFnQixtQkFBbUIsQ0FDakMsTUFBc0IsRUFDdEIsWUFBb0I7SUFFcEIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUM5RCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUM1QixDQUFDO0FBQ0osQ0FBQztBQVBELGtEQU9DO0FBRUQsU0FBUyxpQkFBaUIsQ0FBQyxNQUFzQixFQUFFLElBQVk7O0lBQzdELE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFOUIsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUNwQiwrQkFBK0I7UUFDL0IsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELE1BQU0sWUFBWSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxNQUFNLENBQUM7SUFDekMsSUFBSSxZQUFZLEVBQUU7UUFDaEIsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ2Y7SUFFRCxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFZLENBQUM7SUFDN0MsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBWSxDQUFDO0lBRTdDLE1BQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ25FLE1BQU0sZ0JBQWdCLEdBQUcsR0FBRyxZQUFZLElBQUksWUFBWSxFQUFFLENBQUM7SUFFM0QsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1FBQ3JCLG1DQUFtQztRQUNuQyxPQUFPLElBQUksQ0FBQztLQUNiO0lBRUQsTUFBTSxRQUFRLFNBQUcsTUFBTSxDQUFDLGdC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SyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDOUIsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNwQixPQUFPLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNoRDtRQUNELG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLE9BQU8sSUFBSSxHQUFHLENBQUM7SUFDOUMsQ0FBQyxDQUFDLENBQ0gsRUFDRDtJQUVGLE9BQU8sb0JBQW9CLENBQUM7QUFDOUIsQ0FBQztBQXhDRCwwREF3Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB6IGZyb20gXCJ6b2RcIjtcbmltcG9ydCB7XG4gIFByb3ZpZGVyU2NoZW1hLFxuICBCbG9ja1R5cGUsXG4gIEF0dHJpYnV0ZSxcbiAgQXR0cmlidXRlVHlwZSxcbiAgU2NoZW1hLFxufSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5cbmV4cG9ydCB7IEJsb2NrVHlwZSwgQXR0cmlidXRlIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsUHJvdmlkZXJOYW1lKFxuICBzY2hlbWE6IFByb3ZpZGVyU2NoZW1hLFxuICBwcm92aWRlck5hbWU6IHN0cmluZ1xuKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2hlbWEucHJvdmlkZXJfc2NoZW1hcyB8fCB7fSkuZmluZCgobmFtZSkgPT5cbiAgICBuYW1lLmVuZHNXaXRoKHByb3ZpZGVyTmFtZSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VBdFBhdGgoc2NoZW1hOiBQcm92aWRlclNjaGVtYSwgcGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHBhcnRzID0gcGF0aC5zcGxpdChcIi5cIik7XG5cbiAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAvLyBUb28gc2hvcnQgdG8gYmUgYSB2YWxpZCBwYXRoXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpc0RhdGFTb3VyY2UgPSBwYXJ0c1swXSA9PT0gXCJkYXRhXCI7XG4gIGlmIChpc0RhdGFTb3VyY2UpIHtcbiAgICBwYXJ0cy5zaGlmdCgpO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXJOYW1lID0gcGFydHMuc2hpZnQoKSBhcyBzdHJpbmc7XG4gIGNvbnN0IHJlc291cmNlTmFtZSA9IHBhcnRzLnNoaWZ0KCkgYXMgc3RyaW5nO1xuXG4gIGNvbnN0IGZ1bGxQcm92aWRlck5hbWUgPSBnZXRGdWxsUHJvdmlkZXJOYW1lKHNjaGVtYSwgcHJvdmlkZXJOYW1lKTtcbiAgY29uc3QgZnVsbFJlc291cmNlTmFtZSA9IGAke3Byb3ZpZGVyTmFtZX1fJHtyZXNvdXJjZU5hbWV9YDtcblxuICBpZiAoIWZ1bGxQcm92aWRlck5hbWUpIHtcbiAgICAvLyBObyBwcm92aWRlciBmb3VuZCB3aXRoIHRoYXQgbmFtZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcHJvdmlkZXIgPSBzY2hlbWEucHJvdmlkZXJfc2NoZW1hcz8uW2Z1bGxQcm92aWRlck5hbWVdO1xuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgLy8gQ291bGQgbm90IGZpbmQgcHJvdmlkZXJcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChyZXNvdXJjZU5hbWUuZW5kc1dpdGgoXCJQcm92aWRlclwiKSkge1xuICAgIC8vIFRoaXMgaXMgYSBwcm92aWRlclxuICAgIHJldHVybiB7IHJlc291cmNlOiBwcm92aWRlci5wcm92aWRlciwgcGFydHMgfTtcbiAgfVxuXG4gIGNvbnN0IHJlc291cmNlcyA9IGlzRGF0YVNvdXJjZVxuICAgID8gcHJvdmlkZXIuZGF0YV9zb3VyY2Vfc2NoZW1hc1xuICAgIDogcHJvdmlkZXIucmVzb3VyY2Vfc2NoZW1hcztcblxuICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlc1tmdWxsUmVzb3VyY2VOYW1lXTtcbiAgaWYgKCFyZXNvdXJjZSkge1xuICAgIC8vIENvdWxkIG5vdCBmaW5kIHJlc291cmNlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gTm8gcHJvcGVydHkgc3BlY2lmaWVkXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4geyByZXNvdXJjZSwgcGFydHMgfTtcbn1cblxudHlwZSBFeHRlbmRlZEJsb2NrVHlwZSA9IEJsb2NrVHlwZSAmIHsgbWF4X2l0ZW1zPzogbnVtYmVyIH07XG5leHBvcnQgZnVuY3Rpb24gZ2V0QmxvY2tUeXBlQXRQYXRoKFxuICBzY2hlbWE6IFByb3ZpZGVyU2NoZW1hLFxuICBwYXRoOiBzdHJpbmdcbik6IEV4dGVuZGVkQmxvY2tUeXBlIHwgbnVsbCB7XG4gIGNvbnN0IHJlc291cmNlU2NoZW1hID0gZ2V0UmVzb3VyY2VBdFBhdGgoc2NoZW1hLCBwYXRoKTtcbiAgaWYgKCFyZXNvdXJjZVNjaGVtYSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgcmVzb3VyY2UsIHBhcnRzIH0gPSByZXNvdXJjZVNjaGVtYTtcblxuICBsZXQgY3VycmVudFNjaGVtYTogQmxvY2tUeXBlIHwgdHlwZW9mIHJlc291cmNlID0gcmVzb3VyY2U7XG4gIGRvIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHMuc2hpZnQoKSBhcyBzdHJpbmc7XG4gICAgaWYgKFxuICAgICAgIWN1cnJlbnRTY2hlbWEgfHxcbiAgICAgICFjdXJyZW50U2NoZW1hLmJsb2NrIHx8XG4gICAgICAhY3VycmVudFNjaGVtYS5ibG9jay5ibG9ja190eXBlcyB8fFxuICAgICAgIWN1cnJlbnRTY2hlbWEuYmxvY2suYmxvY2tfdHlwZXMuaGFzT3duUHJvcGVydHkocGFydClcbiAgICApIHtcbiAgICAgIC8vIEZvdW5kIG5vIGJsb2NrIHByb3BlcnR5IHdpdGggdGhpcyBuYW1lLCB0aGVyZSBjb3VsZCBiZSBhbiBhdHRyaWJ1dGUsIGJ1dCB3ZSBkb24ndCBjYXJlIGF0IHRoaXMgcG9pbnRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGN1cnJlbnRTY2hlbWEgPSBjdXJyZW50U2NoZW1hLmJsb2NrLmJsb2NrX3R5cGVzW3BhcnRdO1xuICB9IHdoaWxlIChwYXJ0cy5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gY3VycmVudFNjaGVtYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF0dHJpYnV0ZVR5cGVBdFBhdGgoXG4gIHNjaGVtYTogUHJvdmlkZXJTY2hlbWEsXG4gIHBhdGg6IHN0cmluZ1xuKTogQXR0cmlidXRlIHwgbnVsbCB7XG4gIGNvbnN0IHJlc291cmNlU2NoZW1hID0gZ2V0UmVzb3VyY2VBdFBhdGgoc2NoZW1hLCBwYXRoKTtcbiAgaWYgKCFyZXNvdXJjZVNjaGVtYSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgcmVzb3VyY2UsIHBhcnRzIH0gPSByZXNvdXJjZVNjaGVtYTtcblxuICBjb25zdCBhdHRyaWJ1dGVzID0gcmVzb3VyY2UuYmxvY2suYXR0cmlidXRlcztcblxuICBpZiAocGFydHMubGVuZ3RoICE9PSAxKSB7XG4gICAgLy8gTm8gcHJvcGVydHkgc3BlY2lmaWVkIG9yIHRoZSBwYXRoIGlzIHRvbyBkZWVwXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gcGFydHNbMF07XG5cbiAgcmV0dXJuIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG59XG5cbi8vIFJlc29sdmVzIHdpdGhpbiBhIGxpc3Qgb2Ygb2JqZWN0cywgZS5nLlxuLy8gXCJpbmdyZXNzXCI6IHtcbi8vICAgXCJ0eXBlXCI6IFtcbi8vICAgICBcInNldFwiLFxuLy8gICAgIFtcbi8vICAgICAgIFwib2JqZWN0XCIsXG4vLyAgICAgICB7XG4vLyAgICAgICAgIFwiY2lkcl9ibG9ja3NcIjogW1xuLy8gICAgICAgICAgIFwibGlzdFwiLFxuLy8gICAgICAgICAgIFwic3RyaW5nXCJcbi8vICAgICAgICAgXSxcbmZ1bmN0aW9uIHJlc29sdmVBdHRyaWJ1dGUoXG4gIGF0dDogQXR0cmlidXRlLFxuICBwYXJ0czogc3RyaW5nW11cbik6IEF0dHJpYnV0ZVR5cGUgfCBudWxsIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBhdHQudHlwZTtcbiAgfVxuXG4gIGxldCBjdXJyZW50QXR0OiBBdHRyaWJ1dGVUeXBlIHwgdW5kZWZpbmVkID0gYXR0LnR5cGU7XG4gIGRvIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHMuc2hpZnQoKSBhcyBzdHJpbmc7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShjdXJyZW50QXR0KSAmJlxuICAgICAgY3VycmVudEF0dC5sZW5ndGggPT09IDIgJiZcbiAgICAgIChjdXJyZW50QXR0WzBdID09PSBcInNldFwiIHx8IGN1cnJlbnRBdHRbMF0gPT09IFwibGlzdFwiKSAmJlxuICAgICAgQXJyYXkuaXNBcnJheShjdXJyZW50QXR0WzFdKSAmJlxuICAgICAgY3VycmVudEF0dFsxXVswXSA9PT0gXCJvYmplY3RcIlxuICAgICkge1xuICAgICAgLy8gV2UgY2FuIGdvIGRlZXBlciBpbnRvIHRoZSBzZXQvbGlzdFxuICAgICAgY29uc3QgeCA9IGN1cnJlbnRBdHRbMV1bMV1bcGFydF07XG4gICAgICBjdXJyZW50QXR0ID0geDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IHdoaWxlIChwYXJ0cy5sZW5ndGggPiAwKTtcblxuICBpZiAocGFydHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRBdHQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY291bGQgbm90IGdvIGRlZXBlciBidXQgdGhlIGl0ZW0gcGF0aCBleHBlY3RzIG1vcmUgcGFydHMsIHdlIGhhdmUgdG8gcmV0dXJuIG51bGxcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZUF0UGF0aChcbiAgc2NoZW1hOiBQcm92aWRlclNjaGVtYSxcbiAgcGF0aDogc3RyaW5nXG4pOiBTY2hlbWEgfCBCbG9ja1R5cGUgfCBBdHRyaWJ1dGVUeXBlIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHJlc291cmNlU2NoZW1hID0gZ2V0UmVzb3VyY2VBdFBhdGgoc2NoZW1hLCBwYXRoKTtcbiAgaWYgKCFyZXNvdXJjZVNjaGVtYSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHsgcmVzb3VyY2UsIHBhcnRzIH0gPSByZXNvdXJjZVNjaGVtYTtcblxuICBsZXQgY3VycmVudFNjaGVtYTogQmxvY2tUeXBlIHwgdHlwZW9mIHJlc291cmNlID0gcmVzb3VyY2U7XG4gIGRvIHtcbiAgICBjb25zdCBwYXJ0ID0gcGFydHMuc2hpZnQoKSBhcyBzdHJpbmc7XG5cbiAgICAvLyBHbyBpbnRvIGJsb2NrcyBpZiBwb3NzaWJsZVxuICAgIGlmIChcbiAgICAgIGN1cnJlbnRTY2hlbWEgJiZcbiAgICAgIGN1cnJlbnRTY2hlbWEuYmxvY2sgJiZcbiAgICAgIGN1cnJlbnRTY2hlbWEuYmxvY2suYmxvY2tfdHlwZXMgJiZcbiAgICAgIGN1cnJlbnRTY2hlbWEuYmxvY2suYmxvY2tfdHlwZXMuaGFzT3duUHJvcGVydHkocGFydClcbiAgICApIHtcbiAgICAgIGN1cnJlbnRTY2hlbWEgPSBjdXJyZW50U2NoZW1hLmJsb2NrLmJsb2NrX3R5cGVzW3BhcnRdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gR28gaW50byBhdHRyaWJ1dGVzIGlmIHBvc3NpYmxlXG4gICAgaWYgKFxuICAgICAgY3VycmVudFNjaGVtYSAmJlxuICAgICAgY3VycmVudFNjaGVtYS5ibG9jayAmJlxuICAgICAgY3VycmVudFNjaGVtYS5ibG9jay5hdHRyaWJ1dGVzICYmXG4gICAgICBjdXJyZW50U2NoZW1hLmJsb2NrLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocGFydClcbiAgICApIHtcbiAgICAgIHJldHVybiByZXNvbHZlQXR0cmlidXRlKGN1cnJlbnRTY2hlbWEuYmxvY2suYXR0cmlidXRlc1twYXJ0XSwgcGFydHMpO1xuICAgIH1cblxuICAgIC8vIE5vIGJsb2NrIG9yIGF0dHJpYnV0ZSBmb3VuZCBidXQgcGFydHMgbGVmdFxuICAgIHJldHVybiBudWxsO1xuICB9IHdoaWxlIChwYXJ0cy5sZW5ndGggPiAwKTtcblxuICByZXR1cm4gY3VycmVudFNjaGVtYTtcbn1cblxudHlwZSBQbGFuID0gei5pbmZlcjx0eXBlb2Ygc2NoZW1hPjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm92aWRlclJlcXVpcmVtZW50cyhwbGFuOiBQbGFuKSB7XG4gIC8vIEluIFRlcnJhZm9ybSBvbmUgY2FuIGltcGxpY2l0bHkgZGVmaW5lIHRoZSBwcm92aWRlciBieSB1c2luZyByZXNvdXJjZXMgb2YgdGhhdCB0eXBlXG4gIGNvbnN0IGV4cGxpY2l0UHJvdmlkZXJzID0gT2JqZWN0LmtleXMocGxhbi5wcm92aWRlciB8fCB7fSk7XG4gIGNvbnN0IGltcGxpY2l0UHJvdmlkZXJzID0gT2JqZWN0LmtleXMoeyAuLi5wbGFuLnJlc291cmNlLCAuLi5wbGFuLmRhdGEgfSlcbiAgICAuZmlsdGVyKCh0eXBlKSA9PiB0eXBlICE9PSBcInRlcnJhZm9ybV9yZW1vdGVfc3RhdGVcIilcbiAgICAubWFwKCh0eXBlKSA9PiB0eXBlLnNwbGl0KFwiX1wiKVswXSk7XG5cbiAgY29uc3QgcHJvdmlkZXJSZXF1aXJlbWVudHMgPSBBcnJheS5mcm9tKFxuICAgIG5ldyBTZXQoWy4uLmV4cGxpY2l0UHJvdmlkZXJzLCAuLi5pbXBsaWNpdFByb3ZpZGVyc10pXG4gICkucmVkdWNlKFxuICAgIChjYXJyeSwgcmVxKSA9PiAoeyAuLi5jYXJyeSwgW3JlcV06IFwiKlwiIH0pLFxuICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgKTtcblxuICBwbGFuLnRlcnJhZm9ybT8uZm9yRWFjaCgoeyByZXF1aXJlZF9wcm92aWRlcnMgfSkgPT5cbiAgICAocmVxdWlyZWRfcHJvdmlkZXJzIHx8IFtdKS5mb3JFYWNoKChwcm92aWRlckJsb2NrKSA9PlxuICAgICAgT2JqZWN0LmVudHJpZXMocHJvdmlkZXJCbG9jaykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGxldCBuYW1lLCB2ZXJzaW9uO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgbmFtZSA9IGtleTtcbiAgICAgICAgICB2ZXJzaW9uID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IHZhbHVlLnNvdXJjZTtcbiAgICAgICAgICB2ZXJzaW9uID0gdmFsdWUudmVyc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbXBsaWNpdGx5IG9ubHkgdGhlIGxhc3QgcGFydCBvZiB0aGUgcGF0aCBpcyB1c2VkIChlLmcuIGRvY2tlciBmb3Iga3JldXp3ZXJrZXIvZG9ja2VyKVxuICAgICAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGRlbGV0ZSBwcm92aWRlclJlcXVpcmVtZW50c1twYXJ0cy5wb3AoKSB8fCBcIlwiXTtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlclJlcXVpcmVtZW50c1tuYW1lXSA9IHZlcnNpb24gfHwgXCIqXCI7XG4gICAgICB9KVxuICAgIClcbiAgKTtcblxuICByZXR1cm4gcHJvdmlkZXJSZXF1aXJlbWVudHM7XG59XG4iXX0=