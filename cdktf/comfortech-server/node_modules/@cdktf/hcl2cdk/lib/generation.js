"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gen = exports.moduleImports = exports.providerImports = exports.cdktfImport = exports.provider = exports.modules = exports.local = exports.variable = exports.output = exports.resource = exports.backendToExpression = exports.valueToTs = void 0;
const generator_1 = __importDefault(require("@babel/generator"));
const template_1 = __importDefault(require("@babel/template"));
const t = __importStar(require("@babel/types"));
const prettier_1 = __importDefault(require("prettier"));
const utils_1 = require("./utils");
const expressions_1 = require("./expressions");
const provider_generator_1 = require("@cdktf/provider-generator");
const provider_1 = require("./provider");
function getReference(graph, id) {
    utils_1.logger.debug(`Finding reference for ${id}`);
    const neighbors = graph.outNeighbors(id);
    if (neighbors.length > 0) {
        utils_1.logger.debug(`Found neighbors ${neighbors} for ${id}`);
        const edge = graph.directedEdge(id, neighbors[0]);
        if (edge) {
            utils_1.logger.debug(`Found first edge ${edge} for ${id}`);
            utils_1.logger.debug(`Returning reference ${graph.getEdgeAttribute(edge, "ref")}`);
            return graph.getEdgeAttribute(edge, "ref");
        }
        else {
            utils_1.logger.debug(`Found no edge for ${id}`);
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
exports.valueToTs = async (scope, item, path, nodeIds, scopedIds = [], isModule = false) => {
    var _a;
    switch (typeof item) {
        case "string":
            const wrapInArray = expressions_1.isListExpression(item);
            const ast = expressions_1.referencesToAst(scope, item, await expressions_1.extractReferencesFromExpression(item, nodeIds, scopedIds), scopedIds);
            return wrapInArray ? t.arrayExpression([ast]) : ast;
        case "boolean":
            return t.booleanLiteral(item);
        case "number":
            return t.numericLiteral(item);
        case "object":
            if (item === undefined || item === null) {
                return t.nullLiteral();
            }
            const unwrappedItem = ((_a = provider_1.getBlockTypeAtPath(scope.providerSchema, path)) === null || _a === void 0 ? void 0 : _a.max_items) === 1 &&
                Array.isArray(item)
                ? item[0]
                : item;
            if (Array.isArray(unwrappedItem)) {
                return t.arrayExpression(await Promise.all(unwrappedItem.map((i) => exports.valueToTs(scope, i, path, nodeIds, scopedIds))));
            }
            return t.objectExpression((await Promise.all(Object.entries(unwrappedItem).map(async ([key, value]) => {
                var _a;
                if (key === "lifecycle" || value === undefined) {
                    return undefined;
                }
                if (key === "dynamic") {
                    const { for_each, ...others } = value;
                    const dynamicRef = Object.keys(others)[0];
                    return t.objectProperty(t.identifier(dynamicRef), t.arrayExpression());
                }
                const itemPath = `${path}.${key}`;
                const attribute = provider_1.getAttributeTypeAtPath(scope.providerSchema, itemPath);
                // Map type attributes must not be wrapped in arrays
                const isMapAttribute = Array.isArray(attribute === null || attribute === void 0 ? void 0 : attribute.type)
                    ? ((_a = attribute === null || attribute === void 0 ? void 0 : attribute.type) === null || _a === void 0 ? void 0 : _a[0]) === "map"
                    : false;
                const typeMetadata = provider_1.getTypeAtPath(scope.providerSchema, itemPath);
                const isSingleItemBlock = typeMetadata &&
                    typeof typeMetadata === "object" &&
                    typeMetadata.hasOwnProperty("max_items")
                    ? typeMetadata.max_items === 1
                    : false;
                const shouldBeArray = typeof value === "object" &&
                    !Array.isArray(value) &&
                    !isSingleItemBlock &&
                    !isMapAttribute &&
                    key !== "tags";
                const keepKeyName = !isModule && (key === "for_each" || !typeMetadata);
                return t.objectProperty(t.stringLiteral(keepKeyName ? key : provider_generator_1.escapeAttributeName(utils_1.camelCase(key))), shouldBeArray
                    ? t.arrayExpression([
                        await exports.valueToTs(scope, value, itemPath, nodeIds, scopedIds),
                    ])
                    : await exports.valueToTs(scope, value, itemPath, nodeIds, scopedIds));
            }))).filter((expr) => expr !== undefined));
    }
    throw new Error("Unsupported type " + item);
};
async function backendToExpression(scope, tf, nodeIds) {
    return (await Promise.all(Object.entries(tf || {}).map(async ([type, [config]]) => t.expressionStatement(t.newExpression(t.memberExpression(t.identifier("cdktf"), t.identifier(utils_1.pascalCase(`${type}Backend`))), [
        t.thisExpression(),
        t.objectExpression((await Promise.all(Object.entries(config).map(async ([property, value]) => t.objectProperty(t.identifier(utils_1.camelCase(property)), await exports.valueToTs(scope, value, "path-for-backends-can-be-ignored", nodeIds))))).reduce((carry, item) => [...carry, item], [])),
    ]))))).reduce((carry, item) => [...carry, item], []);
}
exports.backendToExpression = backendToExpression;
function addOverrideExpression(variable, path, value, explanatoryComment) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("addOverride")), [t.stringLiteral(path), value]));
    if (explanatoryComment) {
        t.addComment(ast, "leading", explanatoryComment);
    }
    return ast;
}
function addOverrideLogicalIdExpression(variable, logicalId) {
    const ast = t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(variable), t.identifier("overrideLogicalId")), [t.stringLiteral(logicalId)]));
    t.addComment(ast, "leading", "This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.");
    return ast;
}
function getRemoteStateType(item) {
    const backendRecord = item.find((val) => val.backend);
    if (backendRecord) {
        const backend = backendRecord.backend;
        switch (backend) {
            case "remote":
                return "";
            case "etcdv3":
                return "_etcd_v3";
            default:
                return `_${backend}`;
        }
    }
    else {
        return "";
    }
}
function resourceType(provider, name, item) {
    switch (provider) {
        case "data.terraform":
            return `cdktf.data_terraform_${name.join("_")}${getRemoteStateType(item)}`;
        case "null":
            return `NullProvider.${name.join("_")}`;
        default:
            return `${provider}.${name.join("_")}`;
    }
}
function mapConfigPerResourceType(resource, item) {
    // Backends have a slightly different API
    if (resource.startsWith("cdktf.data_terraform_")) {
        return item.config;
    }
    return item;
}
async function resource(scope, type, key, id, item, graph) {
    const [provider, ...name] = type.split("_");
    const nodeIds = graph.nodes();
    const resource = resourceType(provider, name, item);
    if (!provider) {
        throw new Error(`Could not parse resource type '${type}'`);
    }
    const { for_each, count, ...config } = item[0];
    const mappedConfig = mapConfigPerResourceType(resource, config);
    const dynBlocks = expressions_1.extractDynamicBlocks(mappedConfig);
    const overrideReference = dynBlocks.length || count || for_each
        ? {
            start: 0,
            end: 0,
            referencee: {
                id: `${type}.${key}`,
                full: `${type}.${key}`,
            },
        }
        : undefined;
    const expressions = await asExpression(scope, resource, key, mappedConfig, nodeIds, false, false, getReference(graph, id) || overrideReference);
    const varName = expressions_1.variableName(scope, resource, key);
    const loopComment = `In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.`;
    if (for_each) {
        const references = await expressions_1.extractReferencesFromExpression(for_each, nodeIds, ["each"]);
        expressions.push(addOverrideExpression(varName, "for_each", expressions_1.referencesToAst(scope, for_each, references), loopComment));
    }
    if (count) {
        if (typeof count === "number") {
            expressions.push(addOverrideExpression(varName, "count", await exports.valueToTs(scope, count, "path-for-counts-can-be-ignored", nodeIds), loopComment));
        }
        else {
            const references = await expressions_1.extractReferencesFromExpression(count, nodeIds, [
                "count",
            ]);
            expressions.push(addOverrideExpression(varName, "count", expressions_1.referencesToAst(scope, count, references), loopComment));
        }
    }
    // Check for dynamic blocks
    return [
        ...expressions,
        ...(await Promise.all(dynBlocks.map(async ({ path, for_each, content, scopedVar }) => {
            return addOverrideExpression(varName, path.substring(1), // The path starts with a dot that we don't want
            await exports.valueToTs(scope, {
                for_each,
                content,
            }, "path-for-dynamic-blocks-can-be-ignored", nodeIds, [scopedVar]), loopComment);
        }))),
    ];
}
exports.resource = resource;
async function asExpression(scope, type, name, config, nodeIds, isModuleImport, isProvider, reference) {
    const { lifecycle, providers, ...otherOptions } = config;
    const constructId = utils_1.uniqueId(scope.constructs, name);
    const overrideId = !isProvider && constructId !== name;
    const expression = t.newExpression(expressions_1.constructAst(scope, type, isModuleImport), [
        t.thisExpression(),
        t.stringLiteral(constructId),
        await exports.valueToTs(scope, {
            ...otherOptions,
            providers: providers && Object.keys(providers).length
                ? Object.entries(providers).map(([key, value]) => ({
                    moduleAlias: key,
                    provider: value,
                }))
                : undefined,
        }, `${type}`, nodeIds, [], isModuleImport),
    ]);
    const statements = [];
    const varName = reference
        ? expressions_1.referenceToVariableName(scope, reference)
        : expressions_1.variableName(scope, type, name);
    if (reference || lifecycle || overrideId) {
        statements.push(t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(varName), expression),
        ]));
    }
    else {
        statements.push(t.expressionStatement(expression));
    }
    if (lifecycle) {
        statements.push(addOverrideExpression(varName, "lifecycle", await exports.valueToTs(scope, lifecycle, "path-for-lifecycle-blocks-can-be-ignored", nodeIds)));
    }
    if (overrideId) {
        statements.push(addOverrideLogicalIdExpression(varName, name));
    }
    return statements;
}
async function output(scope, key, _id, item, graph) {
    const nodeIds = graph.nodes();
    const [{ value, description, sensitive }] = item;
    return asExpression(scope, "cdktf.TerraformOutput", key, {
        value,
        description,
        sensitive,
    }, nodeIds, false, false);
}
exports.output = output;
async function variable(scope, key, id, item, graph) {
    // We don't handle type information right now
    const [{ type, ...props }] = item;
    const nodeIds = graph.nodes();
    if (!getReference(graph, id)) {
        return [];
    }
    return asExpression(scope, "cdktf.TerraformVariable", key, props, nodeIds, false, false, getReference(graph, id));
}
exports.variable = variable;
async function local(scope, key, id, item, graph) {
    utils_1.logger.debug(`Initializing local resource ${key} with id ${id}`);
    const nodeIds = graph.nodes();
    if (!getReference(graph, id)) {
        utils_1.logger.debug(`No reference found for ${key}`);
        return [];
    }
    return [
        t.variableDeclaration("const", [
            t.variableDeclarator(t.identifier(expressions_1.variableName(scope, "local", key)), await exports.valueToTs(scope, item, "path-for-local-blocks-can-be-ignored", nodeIds)),
        ]),
    ];
}
exports.local = local;
async function modules(scope, key, id, item, graph) {
    const [{ source, version, ...props }] = item;
    const nodeIds = graph.nodes();
    const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(source);
    return asExpression(scope, moduleConstraint.className, key, props, nodeIds, true, false, getReference(graph, id));
}
exports.modules = modules;
async function provider(scope, key, id, item, graph) {
    const nodeIds = graph.nodes();
    const { version, ...props } = item;
    const importKey = key === "null" ? "NullProvider" : key;
    return asExpression(scope, `${importKey}.${utils_1.pascalCase(key)}Provider`, key, props, nodeIds, false, true, getReference(graph, id));
}
exports.provider = provider;
exports.cdktfImport = template_1.default(`import * as cdktf from "cdktf"`)();
exports.providerImports = (providers) => providers.map((providerName) => {
    const parts = providerName.split("/");
    const name = parts.length > 1 ? parts[1] : parts[0];
    const importName = name === "null" ? "NullProvider" : name;
    return template_1.default(`import * as ${importName} from "./.gen/providers/${name.replace("./", "")}"`)();
});
exports.moduleImports = (modules) => {
    const uniqueModules = new Set();
    Object.values(modules || {}).map(([module]) => uniqueModules.add(module.source));
    const imports = [];
    uniqueModules.forEach((m) => {
        const moduleConstraint = new provider_generator_1.TerraformModuleConstraint(m);
        imports.push(template_1.default.ast(`import * as ${moduleConstraint.className} from "./.gen/modules/${moduleConstraint.fileName}"`));
    });
    return imports;
};
async function gen(statements) {
    utils_1.logger.debug(`Generating code for ${JSON.stringify(statements, null, 2)}`);
    const code = prettier_1.default.format(generator_1.default(t.program(statements)).code, {
        parser: "babel",
    });
    utils_1.logger.debug(`Generated code:\n${code}`);
    return code;
}
exports.gen = gen;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdlbmVyYXRpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGlFQUF3QztBQUN4QywrREFBdUM7QUFDdkMsZ0RBQWtDO0FBRWxDLHdEQUFnQztBQUdoQyxtQ0FBa0U7QUFTbEUsK0NBU3VCO0FBQ3ZCLGtFQUdtQztBQUNuQyx5Q0FJb0I7QUFFcEIsU0FBUyxZQUFZLENBQUMsS0FBb0IsRUFBRSxFQUFVO0lBQ3BELGNBQU0sQ0FBQyxLQUFLLENBQUMseUJBQXlCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDNUMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUV6QyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1FBQ3hCLGNBQU0sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLFNBQVMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZELE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWxELElBQUksSUFBSSxFQUFFO1lBQ1IsY0FBTSxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDbkQsY0FBTSxDQUFDLEtBQUssQ0FDVix1QkFBdUIsS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxDQUM3RCxDQUFDO1lBQ0YsT0FBTyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBYyxDQUFDO1NBQ3pEO2FBQU07WUFDTCxjQUFNLENBQUMsS0FBSyxDQUFDLHFCQUFxQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO0tBQ0Y7U0FBTTtRQUNMLE9B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QyxDQUFDO0lBQzNFLE1BQU0sSUFBSSxHQUFHLGtCQUFRLENBQUMsTUFBTSxDQUFDLG1CQUFRLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQVEsQ0FBQyxDQUFDLElBQUksRUFBRTtRQUN4RSxNQUFNLEVBQUUsT0FBTztLQUNoQixDQUFDLENBQUM7SUFFSCxjQUFNLENBQUMsS0FBSyxDQUFDLG9CQUFvQixJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBRXpDLE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQVRELGtCQVNDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdlbmVyYXRlIGZyb20gXCJAYmFiZWwvZ2VuZXJhdG9yXCI7XG5pbXBvcnQgdGVtcGxhdGUgZnJvbSBcIkBiYWJlbC90ZW1wbGF0ZVwiO1xuaW1wb3J0ICogYXMgdCBmcm9tIFwiQGJhYmVsL3R5cGVzXCI7XG5pbXBvcnQgeyBEaXJlY3RlZEdyYXBoIH0gZnJvbSBcImdyYXBob2xvZ3lcIjtcbmltcG9ydCBwcmV0dGllciBmcm9tIFwicHJldHRpZXJcIjtcblxuaW1wb3J0IHsgVGVycmFmb3JtUmVzb3VyY2VCbG9jaywgU2NvcGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBsb2dnZXIsIHBhc2NhbENhc2UsIHVuaXF1ZUlkIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7XG4gIFJlc291cmNlLFxuICBUZXJyYWZvcm1Db25maWcsXG4gIE1vZHVsZSxcbiAgUHJvdmlkZXIsXG4gIFZhcmlhYmxlLFxuICBPdXRwdXQsXG59IGZyb20gXCIuL3NjaGVtYVwiO1xuaW1wb3J0IHtcbiAgcmVmZXJlbmNlc1RvQXN0LFxuICBleHRyYWN0UmVmZXJlbmNlc0Zyb21FeHByZXNzaW9uLFxuICBSZWZlcmVuY2UsXG4gIHZhcmlhYmxlTmFtZSxcbiAgcmVmZXJlbmNlVG9WYXJpYWJsZU5hbWUsXG4gIGV4dHJhY3REeW5hbWljQmxvY2tzLFxuICBjb25zdHJ1Y3RBc3QsXG4gIGlzTGlzdEV4cHJlc3Npb24sXG59IGZyb20gXCIuL2V4cHJlc3Npb25zXCI7XG5pbXBvcnQge1xuICBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50LFxuICBlc2NhcGVBdHRyaWJ1dGVOYW1lLFxufSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHtcbiAgZ2V0QmxvY2tUeXBlQXRQYXRoLFxuICBnZXRBdHRyaWJ1dGVUeXBlQXRQYXRoLFxuICBnZXRUeXBlQXRQYXRoLFxufSBmcm9tIFwiLi9wcm92aWRlclwiO1xuXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2UoZ3JhcGg6IERpcmVjdGVkR3JhcGgsIGlkOiBzdHJpbmcpIHtcbiAgbG9nZ2VyLmRlYnVnKGBGaW5kaW5nIHJlZmVyZW5jZSBmb3IgJHtpZH1gKTtcbiAgY29uc3QgbmVpZ2hib3JzID0gZ3JhcGgub3V0TmVpZ2hib3JzKGlkKTtcblxuICBpZiAobmVpZ2hib3JzLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIuZGVidWcoYEZvdW5kIG5laWdoYm9ycyAke25laWdoYm9yc30gZm9yICR7aWR9YCk7XG4gICAgY29uc3QgZWRnZSA9IGdyYXBoLmRpcmVjdGVkRWRnZShpZCwgbmVpZ2hib3JzWzBdKTtcblxuICAgIGlmIChlZGdlKSB7XG4gICAgICBsb2dnZXIuZGVidWcoYEZvdW5kIGZpcnN0IGVkZ2UgJHtlZGdlfSBmb3IgJHtpZH1gKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgYFJldHVybmluZyByZWZlcmVuY2UgJHtncmFwaC5nZXRFZGdlQXR0cmlidXRlKGVkZ2UsIFwicmVmXCIpfWBcbiAgICAgICk7XG4gICAgICByZXR1cm4gZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZShlZGdlLCBcInJlZlwiKSBhcyBSZWZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgbm8gZWRnZSBmb3IgJHtpZH1gKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHZhbHVlVG9UcyA9IGFzeW5jIChcbiAgc2NvcGU6IFNjb3BlLFxuICBpdGVtOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBwYXRoOiBzdHJpbmcsXG4gIG5vZGVJZHM6IHN0cmluZ1tdLFxuICBzY29wZWRJZHM6IHN0cmluZ1tdID0gW10sXG4gIGlzTW9kdWxlID0gZmFsc2Vcbik6IFByb21pc2U8dC5FeHByZXNzaW9uPiA9PiB7XG4gIHN3aXRjaCAodHlwZW9mIGl0ZW0pIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBjb25zdCB3cmFwSW5BcnJheSA9IGlzTGlzdEV4cHJlc3Npb24oaXRlbSk7XG4gICAgICBjb25zdCBhc3QgPSByZWZlcmVuY2VzVG9Bc3QoXG4gICAgICAgIHNjb3BlLFxuICAgICAgICBpdGVtLFxuICAgICAgICBhd2FpdCBleHRyYWN0UmVmZXJlbmNlc0Zyb21FeHByZXNzaW9uKGl0ZW0sIG5vZGVJZHMsIHNjb3BlZElkcyksXG4gICAgICAgIHNjb3BlZElkc1xuICAgICAgKTtcbiAgICAgIHJldHVybiB3cmFwSW5BcnJheSA/IHQuYXJyYXlFeHByZXNzaW9uKFthc3RdKSA6IGFzdDtcblxuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gdC5ib29sZWFuTGl0ZXJhbChpdGVtKTtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gdC5udW1lcmljTGl0ZXJhbChpdGVtKTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHQubnVsbExpdGVyYWwoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdW53cmFwcGVkSXRlbSA9XG4gICAgICAgIGdldEJsb2NrVHlwZUF0UGF0aChzY29wZS5wcm92aWRlclNjaGVtYSwgcGF0aCk/Lm1heF9pdGVtcyA9PT0gMSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGl0ZW0pXG4gICAgICAgICAgPyBpdGVtWzBdXG4gICAgICAgICAgOiBpdGVtO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1bndyYXBwZWRJdGVtKSkge1xuICAgICAgICByZXR1cm4gdC5hcnJheUV4cHJlc3Npb24oXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB1bndyYXBwZWRJdGVtLm1hcCgoaSkgPT5cbiAgICAgICAgICAgICAgdmFsdWVUb1RzKHNjb3BlLCBpLCBwYXRoLCBub2RlSWRzLCBzY29wZWRJZHMpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAoXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh1bndyYXBwZWRJdGVtKS5tYXAoYXN5bmMgKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImxpZmVjeWNsZVwiIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZvcl9lYWNoLCAuLi5vdGhlcnMgfSA9IHZhbHVlIGFzIGFueTtcbiAgICAgICAgICAgICAgICBjb25zdCBkeW5hbWljUmVmID0gT2JqZWN0LmtleXMob3RoZXJzKVswXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcihkeW5hbWljUmVmKSxcbiAgICAgICAgICAgICAgICAgIHQuYXJyYXlFeHByZXNzaW9uKClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgaXRlbVBhdGggPSBgJHtwYXRofS4ke2tleX1gO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdldEF0dHJpYnV0ZVR5cGVBdFBhdGgoXG4gICAgICAgICAgICAgICAgc2NvcGUucHJvdmlkZXJTY2hlbWEsXG4gICAgICAgICAgICAgICAgaXRlbVBhdGhcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAvLyBNYXAgdHlwZSBhdHRyaWJ1dGVzIG11c3Qgbm90IGJlIHdyYXBwZWQgaW4gYXJyYXlzXG4gICAgICAgICAgICAgIGNvbnN0IGlzTWFwQXR0cmlidXRlID0gQXJyYXkuaXNBcnJheShhdHRyaWJ1dGU/LnR5cGUpXG4gICAgICAgICAgICAgICAgPyBhdHRyaWJ1dGU/LnR5cGU/LlswXSA9PT0gXCJtYXBcIlxuICAgICAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgY29uc3QgdHlwZU1ldGFkYXRhID0gZ2V0VHlwZUF0UGF0aChcbiAgICAgICAgICAgICAgICBzY29wZS5wcm92aWRlclNjaGVtYSxcbiAgICAgICAgICAgICAgICBpdGVtUGF0aFxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGlzU2luZ2xlSXRlbUJsb2NrID1cbiAgICAgICAgICAgICAgICB0eXBlTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdHlwZU1ldGFkYXRhID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZU1ldGFkYXRhLmhhc093blByb3BlcnR5KFwibWF4X2l0ZW1zXCIpXG4gICAgICAgICAgICAgICAgICA/ICh0eXBlTWV0YWRhdGEgYXMgYW55KS5tYXhfaXRlbXMgPT09IDFcbiAgICAgICAgICAgICAgICAgIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQmVBcnJheSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmXG4gICAgICAgICAgICAgICAgIWlzU2luZ2xlSXRlbUJsb2NrICYmXG4gICAgICAgICAgICAgICAgIWlzTWFwQXR0cmlidXRlICYmXG4gICAgICAgICAgICAgICAga2V5ICE9PSBcInRhZ3NcIjtcblxuICAgICAgICAgICAgICBjb25zdCBrZWVwS2V5TmFtZTogYm9vbGVhbiA9XG4gICAgICAgICAgICAgICAgIWlzTW9kdWxlICYmIChrZXkgPT09IFwiZm9yX2VhY2hcIiB8fCAhdHlwZU1ldGFkYXRhKTtcblxuICAgICAgICAgICAgICByZXR1cm4gdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICB0LnN0cmluZ0xpdGVyYWwoXG4gICAgICAgICAgICAgICAgICBrZWVwS2V5TmFtZSA/IGtleSA6IGVzY2FwZUF0dHJpYnV0ZU5hbWUoY2FtZWxDYXNlKGtleSkpXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBzaG91bGRCZUFycmF5XG4gICAgICAgICAgICAgICAgICA/IHQuYXJyYXlFeHByZXNzaW9uKFtcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB2YWx1ZVRvVHMoXG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVkSWRzXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIDogYXdhaXQgdmFsdWVUb1RzKHNjb3BlLCB2YWx1ZSwgaXRlbVBhdGgsIG5vZGVJZHMsIHNjb3BlZElkcylcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLmZpbHRlcigoZXhwcikgPT4gZXhwciAhPT0gdW5kZWZpbmVkKSBhcyB0Lk9iamVjdFByb3BlcnR5W11cbiAgICAgICk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBcIiArIGl0ZW0pO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJhY2tlbmRUb0V4cHJlc3Npb24oXG4gIHNjb3BlOiBTY29wZSxcbiAgdGY6IFRlcnJhZm9ybUNvbmZpZ1tcImJhY2tlbmRcIl0sXG4gIG5vZGVJZHM6IHN0cmluZ1tdXG4pOiBQcm9taXNlPHQuU3RhdGVtZW50W10+IHtcbiAgcmV0dXJuIChcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRmIHx8IHt9KS5tYXAoYXN5bmMgKFt0eXBlLCBbY29uZmlnXV0pID0+XG4gICAgICAgIHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICAgICAgICB0Lm5ld0V4cHJlc3Npb24oXG4gICAgICAgICAgICB0Lm1lbWJlckV4cHJlc3Npb24oXG4gICAgICAgICAgICAgIHQuaWRlbnRpZmllcihcImNka3RmXCIpLFxuICAgICAgICAgICAgICB0LmlkZW50aWZpZXIocGFzY2FsQ2FzZShgJHt0eXBlfUJhY2tlbmRgKSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHQudGhpc0V4cHJlc3Npb24oKSxcbiAgICAgICAgICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhjb25maWcpLm1hcChhc3luYyAoW3Byb3BlcnR5LCB2YWx1ZV0pID0+XG4gICAgICAgICAgICAgICAgICAgICAgdC5vYmplY3RQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuaWRlbnRpZmllcihjYW1lbENhc2UocHJvcGVydHkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhdGgtZm9yLWJhY2tlbmRzLWNhbi1iZS1pZ25vcmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLnJlZHVjZShcbiAgICAgICAgICAgICAgICAgIChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCBpdGVtXSxcbiAgICAgICAgICAgICAgICAgIFtdIGFzIHQuT2JqZWN0UHJvcGVydHlbXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIClcbiAgICApXG4gICkucmVkdWNlKChjYXJyeSwgaXRlbSkgPT4gWy4uLmNhcnJ5LCBpdGVtXSwgW10gYXMgdC5TdGF0ZW1lbnRbXSk7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgdmFyaWFibGU6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nLFxuICB2YWx1ZTogdC5FeHByZXNzaW9uLFxuICBleHBsYW5hdG9yeUNvbW1lbnQ/OiBzdHJpbmdcbikge1xuICBjb25zdCBhc3QgPSB0LmV4cHJlc3Npb25TdGF0ZW1lbnQoXG4gICAgdC5jYWxsRXhwcmVzc2lvbihcbiAgICAgIHQubWVtYmVyRXhwcmVzc2lvbih0LmlkZW50aWZpZXIodmFyaWFibGUpLCB0LmlkZW50aWZpZXIoXCJhZGRPdmVycmlkZVwiKSksXG4gICAgICBbdC5zdHJpbmdMaXRlcmFsKHBhdGgpLCB2YWx1ZV1cbiAgICApXG4gICk7XG5cbiAgaWYgKGV4cGxhbmF0b3J5Q29tbWVudCkge1xuICAgIHQuYWRkQ29tbWVudChhc3QsIFwibGVhZGluZ1wiLCBleHBsYW5hdG9yeUNvbW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGFzdDtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcnJpZGVMb2dpY2FsSWRFeHByZXNzaW9uKHZhcmlhYmxlOiBzdHJpbmcsIGxvZ2ljYWxJZDogc3RyaW5nKSB7XG4gIGNvbnN0IGFzdCA9IHQuZXhwcmVzc2lvblN0YXRlbWVudChcbiAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgdC5tZW1iZXJFeHByZXNzaW9uKFxuICAgICAgICB0LmlkZW50aWZpZXIodmFyaWFibGUpLFxuICAgICAgICB0LmlkZW50aWZpZXIoXCJvdmVycmlkZUxvZ2ljYWxJZFwiKVxuICAgICAgKSxcbiAgICAgIFt0LnN0cmluZ0xpdGVyYWwobG9naWNhbElkKV1cbiAgICApXG4gICk7XG5cbiAgdC5hZGRDb21tZW50KFxuICAgIGFzdCxcbiAgICBcImxlYWRpbmdcIixcbiAgICBcIlRoaXMgYWxsb3dzIHRoZSBUZXJyYWZvcm0gcmVzb3VyY2UgbmFtZSB0byBtYXRjaCB0aGUgb3JpZ2luYWwgbmFtZS4gWW91IGNhbiByZW1vdmUgdGhlIGNhbGwgaWYgeW91IGRvbid0IG5lZWQgdGhlbSB0byBtYXRjaC5cIlxuICApO1xuXG4gIHJldHVybiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJlbW90ZVN0YXRlVHlwZShpdGVtOiBSZXNvdXJjZSkge1xuICBjb25zdCBiYWNrZW5kUmVjb3JkID0gaXRlbS5maW5kKCh2YWwpID0+IHZhbC5iYWNrZW5kKTtcbiAgaWYgKGJhY2tlbmRSZWNvcmQpIHtcbiAgICBjb25zdCBiYWNrZW5kID0gYmFja2VuZFJlY29yZC5iYWNrZW5kO1xuICAgIHN3aXRjaCAoYmFja2VuZCkge1xuICAgICAgY2FzZSBcInJlbW90ZVwiOlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGNhc2UgXCJldGNkdjNcIjpcbiAgICAgICAgcmV0dXJuIFwiX2V0Y2RfdjNcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgXyR7YmFja2VuZH1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvdXJjZVR5cGUocHJvdmlkZXI6IHN0cmluZywgbmFtZTogc3RyaW5nW10sIGl0ZW06IFJlc291cmNlKSB7XG4gIHN3aXRjaCAocHJvdmlkZXIpIHtcbiAgICBjYXNlIFwiZGF0YS50ZXJyYWZvcm1cIjpcbiAgICAgIHJldHVybiBgY2RrdGYuZGF0YV90ZXJyYWZvcm1fJHtuYW1lLmpvaW4oXCJfXCIpfSR7Z2V0UmVtb3RlU3RhdGVUeXBlKFxuICAgICAgICBpdGVtXG4gICAgICApfWA7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICAgIHJldHVybiBgTnVsbFByb3ZpZGVyLiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7cHJvdmlkZXJ9LiR7bmFtZS5qb2luKFwiX1wiKX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcENvbmZpZ1BlclJlc291cmNlVHlwZShyZXNvdXJjZTogc3RyaW5nLCBpdGVtOiBSZXNvdXJjZVswXSkge1xuICAvLyBCYWNrZW5kcyBoYXZlIGEgc2xpZ2h0bHkgZGlmZmVyZW50IEFQSVxuICBpZiAocmVzb3VyY2Uuc3RhcnRzV2l0aChcImNka3RmLmRhdGFfdGVycmFmb3JtX1wiKSkge1xuICAgIHJldHVybiBpdGVtLmNvbmZpZztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc291cmNlKFxuICBzY29wZTogU2NvcGUsXG4gIHR5cGU6IHN0cmluZyxcbiAga2V5OiBzdHJpbmcsXG4gIGlkOiBzdHJpbmcsXG4gIGl0ZW06IFJlc291cmNlLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKTogUHJvbWlzZTx0LlN0YXRlbWVudFtdPiB7XG4gIGNvbnN0IFtwcm92aWRlciwgLi4ubmFtZV0gPSB0eXBlLnNwbGl0KFwiX1wiKTtcbiAgY29uc3Qgbm9kZUlkcyA9IGdyYXBoLm5vZGVzKCk7XG4gIGNvbnN0IHJlc291cmNlID0gcmVzb3VyY2VUeXBlKHByb3ZpZGVyLCBuYW1lLCBpdGVtKTtcblxuICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgcmVzb3VyY2UgdHlwZSAnJHt0eXBlfSdgKTtcbiAgfVxuXG4gIGNvbnN0IHsgZm9yX2VhY2gsIGNvdW50LCAuLi5jb25maWcgfSA9IGl0ZW1bMF07XG4gIGNvbnN0IG1hcHBlZENvbmZpZyA9IG1hcENvbmZpZ1BlclJlc291cmNlVHlwZShyZXNvdXJjZSwgY29uZmlnKTtcbiAgY29uc3QgZHluQmxvY2tzID0gZXh0cmFjdER5bmFtaWNCbG9ja3MobWFwcGVkQ29uZmlnKTtcbiAgY29uc3Qgb3ZlcnJpZGVSZWZlcmVuY2UgPVxuICAgIGR5bkJsb2Nrcy5sZW5ndGggfHwgY291bnQgfHwgZm9yX2VhY2hcbiAgICAgID8ge1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogMCxcbiAgICAgICAgICByZWZlcmVuY2VlOiB7XG4gICAgICAgICAgICBpZDogYCR7dHlwZX0uJHtrZXl9YCxcbiAgICAgICAgICAgIGZ1bGw6IGAke3R5cGV9LiR7a2V5fWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3QgZXhwcmVzc2lvbnMgPSBhd2FpdCBhc0V4cHJlc3Npb24oXG4gICAgc2NvcGUsXG4gICAgcmVzb3VyY2UsXG4gICAga2V5LFxuICAgIG1hcHBlZENvbmZpZyxcbiAgICBub2RlSWRzLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIGdldFJlZmVyZW5jZShncmFwaCwgaWQpIHx8IG92ZXJyaWRlUmVmZXJlbmNlXG4gICk7XG4gIGNvbnN0IHZhck5hbWUgPSB2YXJpYWJsZU5hbWUoc2NvcGUsIHJlc291cmNlLCBrZXkpO1xuXG4gIGNvbnN0IGxvb3BDb21tZW50ID0gYEluIG1vc3QgY2FzZXMgbG9vcHMgc2hvdWxkIGJlIGhhbmRsZWQgaW4gdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlIGNvbnRleHQgYW5kIFxubm90IGluc2lkZSBvZiB0aGUgVGVycmFmb3JtIGNvbnRleHQuIElmIHlvdSBhcmUgbG9vcGluZyBvdmVyIHNvbWV0aGluZyBleHRlcm5hbCwgZS5nLiBhIHZhcmlhYmxlIG9yIGEgZmlsZSBpbnB1dFxueW91IHNob3VsZCBjb25zaWRlciB1c2luZyBhIGZvciBsb29wLiBJZiB5b3UgYXJlIGxvb3Bpbmcgb3ZlciBzb21ldGhpbmcgb25seSBrbm93biB0byBUZXJyYWZvcm0sIGUuZy4gYSByZXN1bHQgb2YgYSBkYXRhIHNvdXJjZVxueW91IG5lZWQgdG8ga2VlcCB0aGlzIGxpa2UgaXQgaXMuYDtcbiAgaWYgKGZvcl9lYWNoKSB7XG4gICAgY29uc3QgcmVmZXJlbmNlcyA9IGF3YWl0IGV4dHJhY3RSZWZlcmVuY2VzRnJvbUV4cHJlc3Npb24oXG4gICAgICBmb3JfZWFjaCxcbiAgICAgIG5vZGVJZHMsXG4gICAgICBbXCJlYWNoXCJdXG4gICAgKTtcbiAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICAgICAgICB2YXJOYW1lLFxuICAgICAgICBcImZvcl9lYWNoXCIsXG4gICAgICAgIHJlZmVyZW5jZXNUb0FzdChzY29wZSwgZm9yX2VhY2gsIHJlZmVyZW5jZXMpLFxuICAgICAgICBsb29wQ29tbWVudFxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBpZiAoY291bnQpIHtcbiAgICBpZiAodHlwZW9mIGNvdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICBleHByZXNzaW9ucy5wdXNoKFxuICAgICAgICBhZGRPdmVycmlkZUV4cHJlc3Npb24oXG4gICAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgICBcImNvdW50XCIsXG4gICAgICAgICAgYXdhaXQgdmFsdWVUb1RzKFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICBjb3VudCxcbiAgICAgICAgICAgIFwicGF0aC1mb3ItY291bnRzLWNhbi1iZS1pZ25vcmVkXCIsXG4gICAgICAgICAgICBub2RlSWRzXG4gICAgICAgICAgKSxcbiAgICAgICAgICBsb29wQ29tbWVudFxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VzID0gYXdhaXQgZXh0cmFjdFJlZmVyZW5jZXNGcm9tRXhwcmVzc2lvbihjb3VudCwgbm9kZUlkcywgW1xuICAgICAgICBcImNvdW50XCIsXG4gICAgICBdKTtcbiAgICAgIGV4cHJlc3Npb25zLnB1c2goXG4gICAgICAgIGFkZE92ZXJyaWRlRXhwcmVzc2lvbihcbiAgICAgICAgICB2YXJOYW1lLFxuICAgICAgICAgIFwiY291bnRcIixcbiAgICAgICAgICByZWZlcmVuY2VzVG9Bc3Qoc2NvcGUsIGNvdW50LCByZWZlcmVuY2VzKSxcbiAgICAgICAgICBsb29wQ29tbWVudFxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGZvciBkeW5hbWljIGJsb2Nrc1xuICByZXR1cm4gW1xuICAgIC4uLmV4cHJlc3Npb25zLFxuICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGR5bkJsb2Nrcy5tYXAoYXN5bmMgKHsgcGF0aCwgZm9yX2VhY2gsIGNvbnRlbnQsIHNjb3BlZFZhciB9KSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRPdmVycmlkZUV4cHJlc3Npb24oXG4gICAgICAgICAgdmFyTmFtZSxcbiAgICAgICAgICBwYXRoLnN1YnN0cmluZygxKSwgLy8gVGhlIHBhdGggc3RhcnRzIHdpdGggYSBkb3QgdGhhdCB3ZSBkb24ndCB3YW50XG4gICAgICAgICAgYXdhaXQgdmFsdWVUb1RzKFxuICAgICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvcl9lYWNoLFxuICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwicGF0aC1mb3ItZHluYW1pYy1ibG9ja3MtY2FuLWJlLWlnbm9yZWRcIixcbiAgICAgICAgICAgIG5vZGVJZHMsXG4gICAgICAgICAgICBbc2NvcGVkVmFyXVxuICAgICAgICAgICksXG4gICAgICAgICAgbG9vcENvbW1lbnRcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKSksXG4gIF07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFzRXhwcmVzc2lvbihcbiAgc2NvcGU6IFNjb3BlLFxuICB0eXBlOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgY29uZmlnOiBUZXJyYWZvcm1SZXNvdXJjZUJsb2NrLFxuICBub2RlSWRzOiBzdHJpbmdbXSxcbiAgaXNNb2R1bGVJbXBvcnQ6IGJvb2xlYW4sXG4gIGlzUHJvdmlkZXI6IGJvb2xlYW4sXG4gIHJlZmVyZW5jZT86IFJlZmVyZW5jZVxuKSB7XG4gIGNvbnN0IHsgbGlmZWN5Y2xlLCBwcm92aWRlcnMsIC4uLm90aGVyT3B0aW9ucyB9ID0gY29uZmlnIGFzIGFueTtcblxuICBjb25zdCBjb25zdHJ1Y3RJZCA9IHVuaXF1ZUlkKHNjb3BlLmNvbnN0cnVjdHMsIG5hbWUpO1xuICBjb25zdCBvdmVycmlkZUlkID0gIWlzUHJvdmlkZXIgJiYgY29uc3RydWN0SWQgIT09IG5hbWU7XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IHQubmV3RXhwcmVzc2lvbihcbiAgICBjb25zdHJ1Y3RBc3Qoc2NvcGUsIHR5cGUsIGlzTW9kdWxlSW1wb3J0KSxcbiAgICBbXG4gICAgICB0LnRoaXNFeHByZXNzaW9uKCksXG4gICAgICB0LnN0cmluZ0xpdGVyYWwoY29uc3RydWN0SWQpLFxuICAgICAgYXdhaXQgdmFsdWVUb1RzKFxuICAgICAgICBzY29wZSxcbiAgICAgICAge1xuICAgICAgICAgIC4uLm90aGVyT3B0aW9ucyxcbiAgICAgICAgICBwcm92aWRlcnM6XG4gICAgICAgICAgICBwcm92aWRlcnMgJiYgT2JqZWN0LmtleXMocHJvdmlkZXJzKS5sZW5ndGhcbiAgICAgICAgICAgICAgPyBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgbW9kdWxlQWxpYXM6IGtleSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH0sXG4gICAgICAgIGAke3R5cGV9YCxcbiAgICAgICAgbm9kZUlkcyxcbiAgICAgICAgW10sXG4gICAgICAgIGlzTW9kdWxlSW1wb3J0XG4gICAgICApLFxuICAgIF1cbiAgKTtcblxuICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gIGNvbnN0IHZhck5hbWUgPSByZWZlcmVuY2VcbiAgICA/IHJlZmVyZW5jZVRvVmFyaWFibGVOYW1lKHNjb3BlLCByZWZlcmVuY2UpXG4gICAgOiB2YXJpYWJsZU5hbWUoc2NvcGUsIHR5cGUsIG5hbWUpO1xuXG4gIGlmIChyZWZlcmVuY2UgfHwgbGlmZWN5Y2xlIHx8IG92ZXJyaWRlSWQpIHtcbiAgICBzdGF0ZW1lbnRzLnB1c2goXG4gICAgICB0LnZhcmlhYmxlRGVjbGFyYXRpb24oXCJjb25zdFwiLCBbXG4gICAgICAgIHQudmFyaWFibGVEZWNsYXJhdG9yKHQuaWRlbnRpZmllcih2YXJOYW1lKSwgZXhwcmVzc2lvbiksXG4gICAgICBdKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKHQuZXhwcmVzc2lvblN0YXRlbWVudChleHByZXNzaW9uKSk7XG4gIH1cblxuICBpZiAobGlmZWN5Y2xlKSB7XG4gICAgc3RhdGVtZW50cy5wdXNoKFxuICAgICAgYWRkT3ZlcnJpZGVFeHByZXNzaW9uKFxuICAgICAgICB2YXJOYW1lLFxuICAgICAgICBcImxpZmVjeWNsZVwiLFxuICAgICAgICBhd2FpdCB2YWx1ZVRvVHMoXG4gICAgICAgICAgc2NvcGUsXG4gICAgICAgICAgbGlmZWN5Y2xlLFxuICAgICAgICAgIFwicGF0aC1mb3ItbGlmZWN5Y2xlLWJsb2Nrcy1jYW4tYmUtaWdub3JlZFwiLFxuICAgICAgICAgIG5vZGVJZHNcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gIH1cblxuICBpZiAob3ZlcnJpZGVJZCkge1xuICAgIHN0YXRlbWVudHMucHVzaChhZGRPdmVycmlkZUxvZ2ljYWxJZEV4cHJlc3Npb24odmFyTmFtZSwgbmFtZSkpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudHM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvdXRwdXQoXG4gIHNjb3BlOiBTY29wZSxcbiAga2V5OiBzdHJpbmcsXG4gIF9pZDogc3RyaW5nLFxuICBpdGVtOiBPdXRwdXQsXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgY29uc3Qgbm9kZUlkcyA9IGdyYXBoLm5vZGVzKCk7XG4gIGNvbnN0IFt7IHZhbHVlLCBkZXNjcmlwdGlvbiwgc2Vuc2l0aXZlIH1dID0gaXRlbTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIFwiY2RrdGYuVGVycmFmb3JtT3V0cHV0XCIsXG4gICAga2V5LFxuICAgIHtcbiAgICAgIHZhbHVlLFxuICAgICAgZGVzY3JpcHRpb24sXG4gICAgICBzZW5zaXRpdmUsXG4gICAgfSxcbiAgICBub2RlSWRzLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YXJpYWJsZShcbiAgc2NvcGU6IFNjb3BlLFxuICBrZXk6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgaXRlbTogVmFyaWFibGUsXG4gIGdyYXBoOiBEaXJlY3RlZEdyYXBoXG4pIHtcbiAgLy8gV2UgZG9uJ3QgaGFuZGxlIHR5cGUgaW5mb3JtYXRpb24gcmlnaHQgbm93XG4gIGNvbnN0IFt7IHR5cGUsIC4uLnByb3BzIH1dID0gaXRlbTtcbiAgY29uc3Qgbm9kZUlkcyA9IGdyYXBoLm5vZGVzKCk7XG5cbiAgaWYgKCFnZXRSZWZlcmVuY2UoZ3JhcGgsIGlkKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBhc0V4cHJlc3Npb24oXG4gICAgc2NvcGUsXG4gICAgXCJjZGt0Zi5UZXJyYWZvcm1WYXJpYWJsZVwiLFxuICAgIGtleSxcbiAgICBwcm9wcyxcbiAgICBub2RlSWRzLFxuICAgIGZhbHNlLFxuICAgIGZhbHNlLFxuICAgIGdldFJlZmVyZW5jZShncmFwaCwgaWQpXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2NhbChcbiAgc2NvcGU6IFNjb3BlLFxuICBrZXk6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgaXRlbTogVGVycmFmb3JtUmVzb3VyY2VCbG9jayxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbik6IFByb21pc2U8dC5WYXJpYWJsZURlY2xhcmF0aW9uW10+IHtcbiAgbG9nZ2VyLmRlYnVnKGBJbml0aWFsaXppbmcgbG9jYWwgcmVzb3VyY2UgJHtrZXl9IHdpdGggaWQgJHtpZH1gKTtcbiAgY29uc3Qgbm9kZUlkcyA9IGdyYXBoLm5vZGVzKCk7XG4gIGlmICghZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZCkpIHtcbiAgICBsb2dnZXIuZGVidWcoYE5vIHJlZmVyZW5jZSBmb3VuZCBmb3IgJHtrZXl9YCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbXG4gICAgdC52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgdC52YXJpYWJsZURlY2xhcmF0b3IoXG4gICAgICAgIHQuaWRlbnRpZmllcih2YXJpYWJsZU5hbWUoc2NvcGUsIFwibG9jYWxcIiwga2V5KSksXG4gICAgICAgIGF3YWl0IHZhbHVlVG9UcyhcbiAgICAgICAgICBzY29wZSxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIFwicGF0aC1mb3ItbG9jYWwtYmxvY2tzLWNhbi1iZS1pZ25vcmVkXCIsXG4gICAgICAgICAgbm9kZUlkc1xuICAgICAgICApXG4gICAgICApLFxuICAgIF0pLFxuICBdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbW9kdWxlcyhcbiAgc2NvcGU6IFNjb3BlLFxuICBrZXk6IHN0cmluZyxcbiAgaWQ6IHN0cmluZyxcbiAgaXRlbTogTW9kdWxlLFxuICBncmFwaDogRGlyZWN0ZWRHcmFwaFxuKSB7XG4gIGNvbnN0IFt7IHNvdXJjZSwgdmVyc2lvbiwgLi4ucHJvcHMgfV0gPSBpdGVtO1xuICBjb25zdCBub2RlSWRzID0gZ3JhcGgubm9kZXMoKTtcblxuICBjb25zdCBtb2R1bGVDb25zdHJhaW50ID0gbmV3IFRlcnJhZm9ybU1vZHVsZUNvbnN0cmFpbnQoc291cmNlKTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIG1vZHVsZUNvbnN0cmFpbnQuY2xhc3NOYW1lLFxuICAgIGtleSxcbiAgICBwcm9wcyxcbiAgICBub2RlSWRzLFxuICAgIHRydWUsXG4gICAgZmFsc2UsXG4gICAgZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZClcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb3ZpZGVyKFxuICBzY29wZTogU2NvcGUsXG4gIGtleTogc3RyaW5nLFxuICBpZDogc3RyaW5nLFxuICBpdGVtOiBQcm92aWRlclswXSxcbiAgZ3JhcGg6IERpcmVjdGVkR3JhcGhcbikge1xuICBjb25zdCBub2RlSWRzID0gZ3JhcGgubm9kZXMoKTtcbiAgY29uc3QgeyB2ZXJzaW9uLCAuLi5wcm9wcyB9ID0gaXRlbTtcblxuICBjb25zdCBpbXBvcnRLZXkgPSBrZXkgPT09IFwibnVsbFwiID8gXCJOdWxsUHJvdmlkZXJcIiA6IGtleTtcblxuICByZXR1cm4gYXNFeHByZXNzaW9uKFxuICAgIHNjb3BlLFxuICAgIGAke2ltcG9ydEtleX0uJHtwYXNjYWxDYXNlKGtleSl9UHJvdmlkZXJgLFxuICAgIGtleSxcbiAgICBwcm9wcyxcbiAgICBub2RlSWRzLFxuICAgIGZhbHNlLFxuICAgIHRydWUsXG4gICAgZ2V0UmVmZXJlbmNlKGdyYXBoLCBpZClcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGNka3RmSW1wb3J0ID0gdGVtcGxhdGUoXG4gIGBpbXBvcnQgKiBhcyBjZGt0ZiBmcm9tIFwiY2RrdGZcImBcbikoKSBhcyB0LlN0YXRlbWVudDtcblxuZXhwb3J0IGNvbnN0IHByb3ZpZGVySW1wb3J0cyA9IChwcm92aWRlcnM6IHN0cmluZ1tdKSA9PlxuICBwcm92aWRlcnMubWFwKChwcm92aWRlck5hbWUpID0+IHtcbiAgICBjb25zdCBwYXJ0cyA9IHByb3ZpZGVyTmFtZS5zcGxpdChcIi9cIik7XG4gICAgY29uc3QgbmFtZSA9IHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6IHBhcnRzWzBdO1xuICAgIGNvbnN0IGltcG9ydE5hbWUgPSBuYW1lID09PSBcIm51bGxcIiA/IFwiTnVsbFByb3ZpZGVyXCIgOiBuYW1lO1xuICAgIHJldHVybiB0ZW1wbGF0ZShcbiAgICAgIGBpbXBvcnQgKiBhcyAke2ltcG9ydE5hbWV9IGZyb20gXCIuLy5nZW4vcHJvdmlkZXJzLyR7bmFtZS5yZXBsYWNlKFxuICAgICAgICBcIi4vXCIsXG4gICAgICAgIFwiXCJcbiAgICAgICl9XCJgXG4gICAgKSgpIGFzIHQuU3RhdGVtZW50O1xuICB9KTtcblxuZXhwb3J0IGNvbnN0IG1vZHVsZUltcG9ydHMgPSAobW9kdWxlczogUmVjb3JkPHN0cmluZywgTW9kdWxlPiB8IHVuZGVmaW5lZCkgPT4ge1xuICBjb25zdCB1bmlxdWVNb2R1bGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIE9iamVjdC52YWx1ZXMobW9kdWxlcyB8fCB7fSkubWFwKChbbW9kdWxlXSkgPT5cbiAgICB1bmlxdWVNb2R1bGVzLmFkZChtb2R1bGUuc291cmNlKVxuICApO1xuXG4gIGNvbnN0IGltcG9ydHM6IHQuU3RhdGVtZW50W10gPSBbXTtcbiAgdW5pcXVlTW9kdWxlcy5mb3JFYWNoKChtKSA9PiB7XG4gICAgY29uc3QgbW9kdWxlQ29uc3RyYWludCA9IG5ldyBUZXJyYWZvcm1Nb2R1bGVDb25zdHJhaW50KG0pO1xuICAgIGltcG9ydHMucHVzaChcbiAgICAgIHRlbXBsYXRlLmFzdChcbiAgICAgICAgYGltcG9ydCAqIGFzICR7bW9kdWxlQ29uc3RyYWludC5jbGFzc05hbWV9IGZyb20gXCIuLy5nZW4vbW9kdWxlcy8ke21vZHVsZUNvbnN0cmFpbnQuZmlsZU5hbWV9XCJgXG4gICAgICApIGFzIHQuU3RhdGVtZW50XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiBpbXBvcnRzO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbihzdGF0ZW1lbnRzOiB0LlN0YXRlbWVudFtdKSB7XG4gIGxvZ2dlci5kZWJ1ZyhgR2VuZXJhdGluZyBjb2RlIGZvciAke0pTT04uc3RyaW5naWZ5KHN0YXRlbWVudHMsIG51bGwsIDIpfWApO1xuICBjb25zdCBjb2RlID0gcHJldHRpZXIuZm9ybWF0KGdlbmVyYXRlKHQucHJvZ3JhbShzdGF0ZW1lbnRzKSBhcyBhbnkpLmNvZGUsIHtcbiAgICBwYXJzZXI6IFwiYmFiZWxcIixcbiAgfSk7XG5cbiAgbG9nZ2VyLmRlYnVnKGBHZW5lcmF0ZWQgY29kZTpcXG4ke2NvZGV9YCk7XG5cbiAgcmV0dXJuIGNvZGU7XG59XG4iXX0=