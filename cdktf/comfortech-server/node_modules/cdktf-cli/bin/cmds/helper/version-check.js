"use strict";
// This code was mostly copied from https://github.com/aws/aws-cdk/blob/0e96415ea9f365db93aa4b26e7464096b3d62af2/packages/aws-cdk/lib/version.ts
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheDir = exports.homeDir = exports.displayVersionMessage = exports.latestVersionIfHigher = exports.VersionCheckTTL = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const semver = __importStar(require("semver"));
const util_1 = require("util");
const version_1 = require("../../../lib/version");
const ONE_DAY_IN_SECONDS = 1 * 24 * 60 * 60;
const exec = util_1.promisify(child_process_1.exec);
class VersionCheckTTL {
    constructor(file, ttlSecs) {
        this.file = file || VersionCheckTTL.timestampFilePath();
        try {
            fs.mkdirsSync(path.dirname(this.file));
            fs.accessSync(path.dirname(this.file), fs.constants.W_OK);
        }
        catch (_a) {
            throw new Error(`Directory (${path.dirname(this.file)}) is not writable.`);
        }
        this.ttlSecs = ttlSecs || ONE_DAY_IN_SECONDS;
    }
    static timestampFilePath() {
        return path.join(cacheDir(), "version");
    }
    async hasExpired() {
        try {
            const lastCheckTime = (await fs.stat(this.file)).mtimeMs;
            const today = new Date().getTime();
            if ((today - lastCheckTime) / 1000 > this.ttlSecs) {
                // convert ms to sec
                return true;
            }
            return false;
        }
        catch (err) {
            if (err.code === "ENOENT") {
                return true;
            }
            else {
                throw err;
            }
        }
    }
    async update(latestVersion) {
        if (!latestVersion) {
            latestVersion = "";
        }
        await fs.writeFile(this.file, latestVersion);
    }
}
exports.VersionCheckTTL = VersionCheckTTL;
// Export for unit testing only.
// Don't use directly, use displayVersionMessage() instead.
async function latestVersionIfHigher(currentVersion, cacheFile) {
    if (!(await cacheFile.hasExpired())) {
        return null;
    }
    const { stdout, stderr } = await exec("npm view cdktf-cli version");
    if (stderr && stderr.trim().length > 0) {
        console.error(`The 'npm view' command generated an error stream with content [${stderr.trim()}]`);
    }
    const latestVersion = stdout.trim();
    if (!semver.valid(latestVersion)) {
        throw new Error(`npm returned an invalid semver ${latestVersion}`);
    }
    const isNewer = semver.gt(latestVersion, currentVersion);
    await cacheFile.update(latestVersion);
    if (isNewer) {
        return latestVersion;
    }
    else {
        return null;
    }
}
exports.latestVersionIfHigher = latestVersionIfHigher;
async function displayVersionMessage() {
    if (!process.stdout.isTTY) {
        return;
    }
    try {
        const versionCheckCache = new VersionCheckTTL();
        const laterVersion = await latestVersionIfHigher(`${version_1.DISPLAY_VERSION}`, versionCheckCache);
        if (laterVersion) {
            console.log(`Newer version of Terraform CDK is available [${laterVersion}] - Upgrade recommended`);
        }
    }
    catch (err) {
        console.error(`Could not run version check - ${err.message}`);
    }
}
exports.displayVersionMessage = displayVersionMessage;
function homeDir() {
    var _a;
    return process.env.CDKTF_HOME
        ? path.resolve(process.env.CDKTF_HOME)
        : path.join(((_a = os.userInfo().homedir) !== null && _a !== void 0 ? _a : os.homedir()).trim() || "/", ".cdktf");
}
exports.homeDir = homeDir;
function cacheDir() {
    return path.join(homeDir(), "cache");
}
exports.cacheDir = cacheDir;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi1jaGVjay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24tY2hlY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLGdKQUFnSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVoSixpREFBOEM7QUFDOUMsNkNBQStCO0FBQy9CLDJDQUE2QjtBQUM3Qix1Q0FBeUI7QUFDekIsK0NBQWlDO0FBQ2pDLCtCQUFpQztBQUNqQyxrREFBdUQ7QUFFdkQsTUFBTSxrQkFBa0IsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFFNUMsTUFBTSxJQUFJLEdBQUcsZ0JBQVMsQ0FBQyxvQkFBSyxDQUFDLENBQUM7QUFFOUIsTUFBYSxlQUFlO0lBVTFCLFlBQVksSUFBYSxFQUFFLE9BQWdCO1FBQ3pDLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxJQUFJLGVBQWUsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3hELElBQUk7WUFDRixFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDdkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzNEO1FBQUMsV0FBTTtZQUNOLE1BQU0sSUFBSSxLQUFLLENBQ2IsY0FBYyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQzFELENBQUM7U0FDSDtRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxJQUFJLGtCQUFrQixDQUFDO0lBQy9DLENBQUM7SUFwQk0sTUFBTSxDQUFDLGlCQUFpQjtRQUM3QixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDMUMs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Q3JCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVO1FBQzNCLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO1FBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNQLE9BQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksR0FBRyxFQUNyRCxRQUFRLENBQ1QsQ0FBQztBQUNSLENBQUM7QUFQRCwwQkFPQztBQUVELFNBQWdCLFFBQVE7SUFDdEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZDLENBQUM7QUFGRCw0QkFFQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgY29kZSB3YXMgbW9zdGx5IGNvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9ibG9iLzBlOTY0MTVlYTlmMzY1ZGI5M2FhNGIyNmU3NDY0MDk2YjNkNjJhZjIvcGFja2FnZXMvYXdzLWNkay9saWIvdmVyc2lvbi50c1xuXG5pbXBvcnQgeyBleGVjIGFzIF9leGVjIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSBcInV0aWxcIjtcbmltcG9ydCB7IERJU1BMQVlfVkVSU0lPTiB9IGZyb20gXCIuLi8uLi8uLi9saWIvdmVyc2lvblwiO1xuXG5jb25zdCBPTkVfREFZX0lOX1NFQ09ORFMgPSAxICogMjQgKiA2MCAqIDYwO1xuXG5jb25zdCBleGVjID0gcHJvbWlzaWZ5KF9leGVjKTtcblxuZXhwb3J0IGNsYXNzIFZlcnNpb25DaGVja1RUTCB7XG4gIHB1YmxpYyBzdGF0aWMgdGltZXN0YW1wRmlsZVBhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKGNhY2hlRGlyKCksIFwidmVyc2lvblwiKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZTogc3RyaW5nO1xuXG4gIC8vIEZpbGUgbW9kaWZ5IHRpbWVzIGFyZSBhY2N1cmF0ZSBvbmx5IHRvIHRoZSBzZWNvbmRcbiAgcHJpdmF0ZSByZWFkb25seSB0dGxTZWNzOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZmlsZT86IHN0cmluZywgdHRsU2Vjcz86IG51bWJlcikge1xuICAgIHRoaXMuZmlsZSA9IGZpbGUgfHwgVmVyc2lvbkNoZWNrVFRMLnRpbWVzdGFtcEZpbGVQYXRoKCk7XG4gICAgdHJ5IHtcbiAgICAgIGZzLm1rZGlyc1N5bmMocGF0aC5kaXJuYW1lKHRoaXMuZmlsZSkpO1xuICAgICAgZnMuYWNjZXNzU3luYyhwYXRoLmRpcm5hbWUodGhpcy5maWxlKSwgZnMuY29uc3RhbnRzLldfT0spO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRGlyZWN0b3J5ICgke3BhdGguZGlybmFtZSh0aGlzLmZpbGUpfSkgaXMgbm90IHdyaXRhYmxlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudHRsU2VjcyA9IHR0bFNlY3MgfHwgT05FX0RBWV9JTl9TRUNPTkRTO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhc0V4cGlyZWQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGxhc3RDaGVja1RpbWUgPSAoYXdhaXQgZnMuc3RhdCh0aGlzLmZpbGUpKS5tdGltZU1zO1xuICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgICAgaWYgKCh0b2RheSAtIGxhc3RDaGVja1RpbWUpIC8gMTAwMCA+IHRoaXMudHRsU2Vjcykge1xuICAgICAgICAvLyBjb252ZXJ0IG1zIHRvIHNlY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXBkYXRlKGxhdGVzdFZlcnNpb24/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIWxhdGVzdFZlcnNpb24pIHtcbiAgICAgIGxhdGVzdFZlcnNpb24gPSBcIlwiO1xuICAgIH1cbiAgICBhd2FpdCBmcy53cml0ZUZpbGUodGhpcy5maWxlLCBsYXRlc3RWZXJzaW9uKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgZm9yIHVuaXQgdGVzdGluZyBvbmx5LlxuLy8gRG9uJ3QgdXNlIGRpcmVjdGx5LCB1c2UgZGlzcGxheVZlcnNpb25NZXNzYWdlKCkgaW5zdGVhZC5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsYXRlc3RWZXJzaW9uSWZIaWdoZXIoXG4gIGN1cnJlbnRWZXJzaW9uOiBzdHJpbmcsXG4gIGNhY2hlRmlsZTogVmVyc2lvbkNoZWNrVFRMXG4pOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgaWYgKCEoYXdhaXQgY2FjaGVGaWxlLmhhc0V4cGlyZWQoKSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWMoXCJucG0gdmlldyBjZGt0Zi1jbGkgdmVyc2lvblwiKTtcbiAgaWYgKHN0ZGVyciAmJiBzdGRlcnIudHJpbSgpLmxlbmd0aCA+IDApIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgYFRoZSAnbnBtIHZpZXcnIGNvbW1hbmQgZ2VuZXJhdGVkIGFuIGVycm9yIHN0cmVhbSB3aXRoIGNvbnRlbnQgWyR7c3RkZXJyLnRyaW0oKX1dYFxuICAgICk7XG4gIH1cbiAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IHN0ZG91dC50cmltKCk7XG4gIGlmICghc2VtdmVyLnZhbGlkKGxhdGVzdFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBucG0gcmV0dXJuZWQgYW4gaW52YWxpZCBzZW12ZXIgJHtsYXRlc3RWZXJzaW9ufWApO1xuICB9XG4gIGNvbnN0IGlzTmV3ZXIgPSBzZW12ZXIuZ3QobGF0ZXN0VmVyc2lvbiwgY3VycmVudFZlcnNpb24pO1xuICBhd2FpdCBjYWNoZUZpbGUudXBkYXRlKGxhdGVzdFZlcnNpb24pO1xuXG4gIGlmIChpc05ld2VyKSB7XG4gICAgcmV0dXJuIGxhdGVzdFZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgaWYgKCFwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdmVyc2lvbkNoZWNrQ2FjaGUgPSBuZXcgVmVyc2lvbkNoZWNrVFRMKCk7XG4gICAgY29uc3QgbGF0ZXJWZXJzaW9uID0gYXdhaXQgbGF0ZXN0VmVyc2lvbklmSGlnaGVyKFxuICAgICAgYCR7RElTUExBWV9WRVJTSU9OfWAsXG4gICAgICB2ZXJzaW9uQ2hlY2tDYWNoZVxuICAgICk7XG4gICAgaWYgKGxhdGVyVmVyc2lvbikge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIGBOZXdlciB2ZXJzaW9uIG9mIFRlcnJhZm9ybSBDREsgaXMgYXZhaWxhYmxlIFske2xhdGVyVmVyc2lvbn1dIC0gVXBncmFkZSByZWNvbW1lbmRlZGBcbiAgICAgICk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcnVuIHZlcnNpb24gY2hlY2sgLSAke2Vyci5tZXNzYWdlfWApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob21lRGlyKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQ0RLVEZfSE9NRVxuICAgID8gcGF0aC5yZXNvbHZlKHByb2Nlc3MuZW52LkNES1RGX0hPTUUpXG4gICAgOiBwYXRoLmpvaW4oXG4gICAgICAgIChvcy51c2VySW5mbygpLmhvbWVkaXIgPz8gb3MuaG9tZWRpcigpKS50cmltKCkgfHwgXCIvXCIsXG4gICAgICAgIFwiLmNka3RmXCJcbiAgICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWNoZURpcigpIHtcbiAgcmV0dXJuIHBhdGguam9pbihob21lRGlyKCksIFwiY2FjaGVcIik7XG59XG4iXX0=