"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInteractiveTerminal = exports.verifySimilarLibraryVersion = exports.checkEnvironment = void 0;
const semver = __importStar(require("semver"));
const debug_1 = require("../../../lib/debug");
const errors_1 = require("../../../lib/errors");
const logging_1 = require("../../../lib/logging");
const version_1 = require("../../../lib/version");
const environment_1 = require("../../../lib/environment");
function throwIfLowerVersion(language, minVersion, stdout) {
    if (!stdout) {
        throw errors_1.Errors.Usage(`${language} version could not be determined`);
    }
    const version = semver.coerce(stdout);
    if (!version || !semver.valid(version)) {
        console.error(errors_1.Errors.Internal(`Unable to parse ${language} version "${stdout}"`));
        return;
    }
    if (semver.lt(version, minVersion)) {
        console.error(errors_1.Errors.Usage(`${language} version "${version}" is not supported. Please upgrade to at least ${minVersion}`));
    }
}
async function checkGoVersion() {
    const out = await debug_1.getGoVersion();
    throwIfLowerVersion("Go", "1.16.0", out);
}
async function checkNodeVersion() {
    const out = await debug_1.getNodeVersion();
    throwIfLowerVersion("Node.js", "14.17.0", out);
}
async function checkEnvironment() {
    await checkNodeVersion();
    switch (debug_1.getLanguage()) {
        case "go":
            await checkGoVersion();
    }
}
exports.checkEnvironment = checkEnvironment;
async function verifySimilarLibraryVersion() {
    if (environment_1.DISABLE_VERSION_CHECK) {
        logging_1.logger.debug("Version check disabled via environment variable");
        return;
    }
    const language = debug_1.getLanguage();
    if (!language) {
        logging_1.logger.debug("Unable to detect language, skipping version check");
        return;
    }
    const libVersion = await debug_1.getPackageVersion(language, "cdktf");
    if (!libVersion) {
        logging_1.logger.debug(`Unable to detect library version for ${language}`);
        return;
    }
    const cliVersion = `${version_1.DISPLAY_VERSION}`;
    if (!libVersion) {
        logging_1.logger.debug(`Unable to detect library version for ${language}`);
        return;
    }
    logging_1.logger.debug(`CLI version: ${cliVersion}`);
    logging_1.logger.debug(`${language} package version: ${libVersion}`);
    if (cliVersion === "0.0.0" || cliVersion.includes("-dev")) {
        logging_1.logger.debug(`Running a development version of cdktf, skipping version check`);
        return;
    }
    if (cliVersion.includes(".dev") || cliVersion.includes("-pre.")) {
        logging_1.logger.debug(`Running a pre-release version of cdktf-cli, skipping version compatibility check`);
        return;
    }
    if (libVersion.includes(".dev") || libVersion.includes("-pre.")) {
        logging_1.logger.debug(`Running a pre-release version of cdktf, skipping version compatibility check`);
        return;
    }
    if (!semver.valid(libVersion)) {
        logging_1.logger.info("Could not determine library version, skipping version compatibility check");
        return;
    }
    if (!semver.valid(cliVersion)) {
        logging_1.logger.info("Could not determine CLI version, skipping version compatibility check");
        return;
    }
    if (semver.major(libVersion) !== semver.major(cliVersion)) {
        throw errors_1.Errors.Usage(`The major version of the library (${libVersion}) and the CLI (${cliVersion}) are different. Please update the library to the same major version and regenerate your provider bindings with 'cdktf get' and update your prebuilt providers.`);
    }
    if (semver.minor(libVersion) !== semver.minor(cliVersion)) {
        throw errors_1.Errors.Usage(`The minor version of the library (${libVersion}) and the CLI (${cliVersion}) are different. Please update the library to the same minor version and regenerate your provider bindings with 'cdktf get' and update your prebuilt providers.`);
    }
}
exports.verifySimilarLibraryVersion = verifySimilarLibraryVersion;
function isInteractiveTerminal() {
    return process.stdout.isTTY && !process.env.CI;
}
exports.isInteractiveTerminal = isInteractiveTerminal;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2stZW52aXJvbm1lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjaGVjay1lbnZpcm9ubWVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsK0NBQWlDO0FBQ2pDLDhDQUs0QjtBQUM1QixnREFBNkM7QUFDN0Msa0RBQThDO0FBQzlDLGtEQUF1RDtBQUN2RCwwREFBaUU7QUFFakUsU0FBUyxtQkFBbUIsQ0FDMUIsUUFBZ0IsRUFDaEIsVUFBa0IsRUFDbEIsTUFBMEI7SUFFMUIsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLE1BQU0sZUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsa0NBQWtDLENBQUMsQ0FBQztLQUNuRTtJQUVELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdEMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDdEMsT0FBTyxDQUFDLEtBQUssQ0FDWCxlQUFNLENBQUMsUUFBUSxDQUFDLG1CQUFtQixRQUFRLGFBQWEsTUFBTSxHQUFHLENBQUMsQ0FDbkUsQ0FBQztRQUNGLE9BQU87S0FDUjtJQUVELElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLEVBQUU7UUFDbEMsT0FBTyxDQUFDLEtBQUssQ0FDWCxlQUFNLENBQUMsS0FBSyxDQUNWLEdBQUcsUUFBUSxhQUFhLE9BQU8sa0RBQWtELFVBQVUsRUFBRSxDQUM5RixDQUNGLENBQUM7S0FDSDtBQUNILENBQUM7QUFFRCxLQUFLLFVBQVUsY0FBYztJQUMzQixNQUFNLEdBQUcsR0FBRyxNQUFNLG9CQUFZLEVBQUUsQ0FBQztJQUNqQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFFRCxLQUFLLFVBQVUsZ0JBQWdC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QWtCLFVBQVUsaUtBQWlLLENBQzdPLENBQUM7S0FDSDtBQUNILENBQUM7QUExRUQsa0VBMEVDO0FBRUQsU0FBZ0IscUJBQXFCO0lBQ25DLE9BQU8sT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUNqRCxDQUFDO0FBRkQsc0RBRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0IHtcbiAgZ2V0R29WZXJzaW9uLFxuICBnZXRMYW5ndWFnZSxcbiAgZ2V0Tm9kZVZlcnNpb24sXG4gIGdldFBhY2thZ2VWZXJzaW9uLFxufSBmcm9tIFwiLi4vLi4vLi4vbGliL2RlYnVnXCI7XG5pbXBvcnQgeyBFcnJvcnMgfSBmcm9tIFwiLi4vLi4vLi4vbGliL2Vycm9yc1wiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9sb2dnaW5nXCI7XG5pbXBvcnQgeyBESVNQTEFZX1ZFUlNJT04gfSBmcm9tIFwiLi4vLi4vLi4vbGliL3ZlcnNpb25cIjtcbmltcG9ydCB7IERJU0FCTEVfVkVSU0lPTl9DSEVDSyB9IGZyb20gXCIuLi8uLi8uLi9saWIvZW52aXJvbm1lbnRcIjtcblxuZnVuY3Rpb24gdGhyb3dJZkxvd2VyVmVyc2lvbihcbiAgbGFuZ3VhZ2U6IHN0cmluZyxcbiAgbWluVmVyc2lvbjogc3RyaW5nLFxuICBzdGRvdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSB7XG4gIGlmICghc3Rkb3V0KSB7XG4gICAgdGhyb3cgRXJyb3JzLlVzYWdlKGAke2xhbmd1YWdlfSB2ZXJzaW9uIGNvdWxkIG5vdCBiZSBkZXRlcm1pbmVkYCk7XG4gIH1cblxuICBjb25zdCB2ZXJzaW9uID0gc2VtdmVyLmNvZXJjZShzdGRvdXQpO1xuICBpZiAoIXZlcnNpb24gfHwgIXNlbXZlci52YWxpZCh2ZXJzaW9uKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBFcnJvcnMuSW50ZXJuYWwoYFVuYWJsZSB0byBwYXJzZSAke2xhbmd1YWdlfSB2ZXJzaW9uIFwiJHtzdGRvdXR9XCJgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNlbXZlci5sdCh2ZXJzaW9uLCBtaW5WZXJzaW9uKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBFcnJvcnMuVXNhZ2UoXG4gICAgICAgIGAke2xhbmd1YWdlfSB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiIGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1cGdyYWRlIHRvIGF0IGxlYXN0ICR7bWluVmVyc2lvbn1gXG4gICAgICApXG4gICAgKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja0dvVmVyc2lvbigpIHtcbiAgY29uc3Qgb3V0ID0gYXdhaXQgZ2V0R29WZXJzaW9uKCk7XG4gIHRocm93SWZMb3dlclZlcnNpb24oXCJHb1wiLCBcIjEuMTYuMFwiLCBvdXQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjaGVja05vZGVWZXJzaW9uKCkge1xuICBjb25zdCBvdXQgPSBhd2FpdCBnZXROb2RlVmVyc2lvbigpO1xuICB0aHJvd0lmTG93ZXJWZXJzaW9uKFwiTm9kZS5qc1wiLCBcIjE0LjE3LjBcIiwgb3V0KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrRW52aXJvbm1lbnQoKSB7XG4gIGF3YWl0IGNoZWNrTm9kZVZlcnNpb24oKTtcblxuICBzd2l0Y2ggKGdldExhbmd1YWdlKCkpIHtcbiAgICBjYXNlIFwiZ29cIjpcbiAgICAgIGF3YWl0IGNoZWNrR29WZXJzaW9uKCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpbWlsYXJMaWJyYXJ5VmVyc2lvbigpIHtcbiAgaWYgKERJU0FCTEVfVkVSU0lPTl9DSEVDSykge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlZlcnNpb24gY2hlY2sgZGlzYWJsZWQgdmlhIGVudmlyb25tZW50IHZhcmlhYmxlXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2UoKTtcbiAgaWYgKCFsYW5ndWFnZSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlVuYWJsZSB0byBkZXRlY3QgbGFuZ3VhZ2UsIHNraXBwaW5nIHZlcnNpb24gY2hlY2tcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGliVmVyc2lvbiA9IGF3YWl0IGdldFBhY2thZ2VWZXJzaW9uKGxhbmd1YWdlLCBcImNka3RmXCIpO1xuICBpZiAoIWxpYlZlcnNpb24pIHtcbiAgICBsb2dnZXIuZGVidWcoYFVuYWJsZSB0byBkZXRlY3QgbGlicmFyeSB2ZXJzaW9uIGZvciAke2xhbmd1YWdlfWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNsaVZlcnNpb24gPSBgJHtESVNQTEFZX1ZFUlNJT059YDtcblxuICBpZiAoIWxpYlZlcnNpb24pIHtcbiAgICBsb2dnZXIuZGVidWcoYFVuYWJsZSB0byBkZXRlY3QgbGlicmFyeSB2ZXJzaW9uIGZvciAke2xhbmd1YWdlfWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxvZ2dlci5kZWJ1ZyhgQ0xJIHZlcnNpb246ICR7Y2xpVmVyc2lvbn1gKTtcbiAgbG9nZ2VyLmRlYnVnKGAke2xhbmd1YWdlfSBwYWNrYWdlIHZlcnNpb246ICR7bGliVmVyc2lvbn1gKTtcblxuICBpZiAoY2xpVmVyc2lvbiA9PT0gXCIwLjAuMFwiIHx8IGNsaVZlcnNpb24uaW5jbHVkZXMoXCItZGV2XCIpKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgYFJ1bm5pbmcgYSBkZXZlbG9wbWVudCB2ZXJzaW9uIG9mIGNka3RmLCBza2lwcGluZyB2ZXJzaW9uIGNoZWNrYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNsaVZlcnNpb24uaW5jbHVkZXMoXCIuZGV2XCIpIHx8IGNsaVZlcnNpb24uaW5jbHVkZXMoXCItcHJlLlwiKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgIGBSdW5uaW5nIGEgcHJlLXJlbGVhc2UgdmVyc2lvbiBvZiBjZGt0Zi1jbGksIHNraXBwaW5nIHZlcnNpb24gY29tcGF0aWJpbGl0eSBjaGVja2BcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChsaWJWZXJzaW9uLmluY2x1ZGVzKFwiLmRldlwiKSB8fCBsaWJWZXJzaW9uLmluY2x1ZGVzKFwiLXByZS5cIikpIHtcbiAgICBsb2dnZXIuZGVidWcoXG4gICAgICBgUnVubmluZyBhIHByZS1yZWxlYXNlIHZlcnNpb24gb2YgY2RrdGYsIHNraXBwaW5nIHZlcnNpb24gY29tcGF0aWJpbGl0eSBjaGVja2BcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc2VtdmVyLnZhbGlkKGxpYlZlcnNpb24pKSB7XG4gICAgbG9nZ2VyLmluZm8oXG4gICAgICBcIkNvdWxkIG5vdCBkZXRlcm1pbmUgbGlicmFyeSB2ZXJzaW9uLCBza2lwcGluZyB2ZXJzaW9uIGNvbXBhdGliaWxpdHkgY2hlY2tcIlxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFzZW12ZXIudmFsaWQoY2xpVmVyc2lvbikpIHtcbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIFwiQ291bGQgbm90IGRldGVybWluZSBDTEkgdmVyc2lvbiwgc2tpcHBpbmcgdmVyc2lvbiBjb21wYXRpYmlsaXR5IGNoZWNrXCJcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzZW12ZXIubWFqb3IobGliVmVyc2lvbikgIT09IHNlbXZlci5tYWpvcihjbGlWZXJzaW9uKSkge1xuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBUaGUgbWFqb3IgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSAoJHtsaWJWZXJzaW9ufSkgYW5kIHRoZSBDTEkgKCR7Y2xpVmVyc2lvbn0pIGFyZSBkaWZmZXJlbnQuIFBsZWFzZSB1cGRhdGUgdGhlIGxpYnJhcnkgdG8gdGhlIHNhbWUgbWFqb3IgdmVyc2lvbiBhbmQgcmVnZW5lcmF0ZSB5b3VyIHByb3ZpZGVyIGJpbmRpbmdzIHdpdGggJ2Nka3RmIGdldCcgYW5kIHVwZGF0ZSB5b3VyIHByZWJ1aWx0IHByb3ZpZGVycy5gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChzZW12ZXIubWlub3IobGliVmVyc2lvbikgIT09IHNlbXZlci5taW5vcihjbGlWZXJzaW9uKSkge1xuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBUaGUgbWlub3IgdmVyc2lvbiBvZiB0aGUgbGlicmFyeSAoJHtsaWJWZXJzaW9ufSkgYW5kIHRoZSBDTEkgKCR7Y2xpVmVyc2lvbn0pIGFyZSBkaWZmZXJlbnQuIFBsZWFzZSB1cGRhdGUgdGhlIGxpYnJhcnkgdG8gdGhlIHNhbWUgbWlub3IgdmVyc2lvbiBhbmQgcmVnZW5lcmF0ZSB5b3VyIHByb3ZpZGVyIGJpbmRpbmdzIHdpdGggJ2Nka3RmIGdldCcgYW5kIHVwZGF0ZSB5b3VyIHByZWJ1aWx0IHByb3ZpZGVycy5gXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZVRlcm1pbmFsKCkge1xuICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQuaXNUVFkgJiYgIXByb2Nlc3MuZW52LkNJO1xufVxuIl19