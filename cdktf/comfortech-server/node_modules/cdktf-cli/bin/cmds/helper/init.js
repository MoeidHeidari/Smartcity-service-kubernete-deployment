"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runInit = exports.checkForEmptyDirectory = void 0;
const fs = __importStar(require("fs-extra"));
const chalk = __importStar(require("chalk"));
const inquirer = __importStar(require("inquirer"));
const extract_zip_1 = __importDefault(require("extract-zip"));
const terraform_login_1 = require("../helper/terraform-login");
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const terraformCloudClient = __importStar(require("../helper/terraform-cloud-client"));
const util_1 = require("../../../lib/util");
const logging_1 = require("../../../lib/logging");
const errors_1 = require("../../../lib/errors");
const hcl2cdk_1 = require("@cdktf/hcl2cdk");
const provider_generator_1 = require("@cdktf/provider-generator");
const child_process_1 = require("child_process");
const checkpoint_1 = require("../../../lib/checkpoint");
const uuid_1 = require("uuid");
const provider_generator_2 = require("@cdktf/provider-generator");
const init_templates_1 = require("./init-templates");
const lib_1 = require("../../../lib");
const error_reporting_1 = require("../../../lib/error-reporting");
const ci_detect_1 = __importDefault(require("@npmcli/ci-detect"));
const check_environment_1 = require("./check-environment");
const chalkColour = new chalk.Instance();
const isReadme = (file) => file.toLowerCase() === "readme.md";
function checkForEmptyDirectory(dir) {
    if (fs
        .readdirSync(dir)
        .filter((f) => !f.startsWith(".") && f !== logging_1.logFileName && !isReadme(f))
        .length > 0) {
        console.error(chalkColour `{redBright ERROR: Cannot initialize a project in a non-empty directory}`);
        process.exit(1);
    }
}
exports.checkForEmptyDirectory = checkForEmptyDirectory;
const tfeHostname = "app.terraform.io";
async function runInit(argv) {
    var _a;
    const telemetryData = {};
    const destination = argv.destination || ".";
    let token = "";
    if (!argv.local) {
        // We ask the user to login to Terraform Cloud and set a token
        // If the user chooses not to use Terraform Cloud, we continue
        // without a token and set up the project.
        const terraformLogin = new terraform_login_1.TerraformLogin(tfeHostname);
        token = await terraformLogin.askToLogin();
    }
    else {
        console.log(chalkColour `{yellow Note: By supplying '--local' option you have chosen local storage mode for storing the state of your stack.
This means that your Terraform state file will be stored locally on disk in a file 'terraform.<STACK NAME>.tfstate' in the root of your project.}`);
    }
    // Check if template was specified by the user
    let template = "";
    if (argv.template) {
        template = argv.template;
    }
    // Gather information about the template and the project
    const templateInfo = await getTemplate(template);
    telemetryData.template = templateInfo.Name;
    const projectInfo = await gatherInfo(token, argv.projectName, argv.projectDescription);
    const projectId = uuid_1.v4();
    telemetryData.projectId = projectId;
    const fromTerraformProject = argv.fromTerraformProject ||
        (templateInfo.Name === "typescript"
            ? await getTerraformProject()
            : undefined);
    if (!argv.local) {
        if (!("OrganizationName" in projectInfo)) {
            throw new Error(`Missing organization name in project info`);
        }
        if (!("WorkspaceName" in projectInfo)) {
            throw new Error(`Missing organization name in project info`);
        }
        // Check if token is set so we can set up Terraform Cloud workspace
        // only set with the '--local' option is specified the user.
        if (token != "") {
            telemetryData.isRemote = Boolean(token);
            console.log(chalkColour `\n{whiteBright Setting up remote state backend and workspace in Terraform Cloud.}`);
            try {
                await terraformCloudClient.createWorkspace(tfeHostname, projectInfo.OrganizationName, projectInfo.WorkspaceName, token);
            }
            catch (error) {
                console.error(chalkColour `{redBright ERROR: Could not create Terraform Cloud Workspace: ${error.message}}`);
                process.exit(1);
            }
        }
    }
    const ci = ci_detect_1.default();
    const sendCrashReports = (_a = argv.enableCrashReporting) !== null && _a !== void 0 ? _a : (ci ? false : await error_reporting_1.askForCrashReportingConsent());
    let convertResult, importPath;
    if (fromTerraformProject) {
        if (templateInfo.Name !== "typescript") {
            console.error(`The --from-terraform-project flag is only supported with the typescript template. The command will continue and ignore the flag.`);
        }
        importPath = path.resolve(process.cwd(), fromTerraformProject);
        const combinedTfFile = hcl2cdk_1.getTerraformConfigFromDir(importPath);
        // Fetch all provider requirements from the project
        const providerRequirements = await hcl2cdk_1.parseProviderRequirements(combinedTfFile);
        // Get all the provider schemas
        const { providerSchema } = await provider_generator_2.readSchema(Object.entries(providerRequirements).map(([name, version]) => provider_generator_2.ConstructsMakerProviderTarget.from(new provider_generator_2.config.TerraformProviderConstraint(`${name}@ ${version}`), provider_generator_2.LANGUAGES[0])));
        try {
            convertResult = await hcl2cdk_1.convertProject(combinedTfFile, {
                language: "typescript",
                providerSchema,
            });
        }
        catch (err) {
            throw errors_1.Errors.Internal(err, { fromTerraformProject: true });
        }
    }
    await lib_1.init({
        cdktfVersion: argv.cdktfVersion,
        destination,
        dist: argv.dist,
        projectId,
        projectInfo,
        templatePath: templateInfo.Path,
        sendCrashReports: sendCrashReports,
    });
    if (convertResult && importPath) {
        const { code, cdktfJson, stats } = convertResult;
        const mainTs = fs.readFileSync(path.resolve(destination, "main.ts"), "utf8");
        fs.writeFileSync(path.resolve(destination, "main.ts"), code(mainTs), "utf8");
        const renderedCdktfJson = cdktfJson(require(path.resolve(destination, "cdktf.json")));
        fs.writeFileSync(path.resolve(destination, "cdktf.json"), JSON.stringify(renderedCdktfJson, null, 2), "utf8");
        const { terraformModules, terraformProviders } = renderedCdktfJson;
        if (terraformModules.length > 0) {
            copyLocalModules(terraformModules, importPath, destination);
        }
        if (terraformModules.length + terraformProviders.length > 0) {
            child_process_1.execSync("npm run get", { cwd: destination });
        }
        telemetryData.conversionStats = stats;
    }
    if (templateInfo.cleanupTemporaryFiles) {
        await templateInfo.cleanupTemporaryFiles();
    }
    await checkpoint_1.sendTelemetry("init", telemetryData);
}
exports.runInit = runInit;
function copyLocalModules(modules, sourcePath, destination) {
    modules
        .filter((m) => provider_generator_1.isLocalModule(m))
        .map((m) => fs.copySync(path.resolve(sourcePath, m), path.resolve(destination, m), {
        recursive: true,
    }));
}
async function gatherInfo(token, projectName, projectDescription) {
    const currentDirectory = path.basename(process.cwd());
    const projectDescriptionDefault = "A simple getting started project for cdktf.";
    const questions = [];
    if (!projectName) {
        questions.push({
            name: "projectName",
            message: "Project Name",
            default: currentDirectory,
        });
    }
    if (!projectDescription) {
        questions.push({
            name: "projectDescription",
            message: "Project Description",
            default: projectDescriptionDefault,
        });
    }
    const answers = questions.length > 0 ? await inquirer.prompt(questions) : {};
    const project = {
        Name: projectName || answers.projectName || "",
        Description: projectDescription || answers.projectDescription || "",
        OrganizationName: "",
        WorkspaceName: "",
    };
    if (token != "") {
        console.log(chalkColour `\nDetected {blueBright Terraform Cloud} token.`);
        console.log(chalkColour `\nWe will now set up {blueBright Terraform Cloud} for your project.\n`);
        const organizationNames = await terraformCloudClient.getOrganizationNames(tfeHostname, token);
        const organizationData = organizationNames.data;
        const organizationOptions = [];
        for (const organization of organizationData) {
            organizationOptions.push(organization.id);
        }
        // todo: add validation for the organization name and workspace. add error handling
        const { organization: organizationSelect } = await inquirer.prompt([
            {
                type: "list",
                name: "organization",
                message: "Terraform Cloud Organization Name",
                choices: organizationOptions,
            },
        ]);
        console.log(chalkColour `\nWe are going to create a new {blueBright Terraform Cloud Workspace} for your project.\n`);
        const { workspace: workspaceName } = await inquirer.prompt([
            {
                name: "workspace",
                message: "Terraform Cloud Workspace Name",
                default: project.Name,
            },
        ]);
        project.OrganizationName = organizationSelect;
        project.WorkspaceName = workspaceName;
    }
    return project;
}
async function getTerraformProject() {
    if (!check_environment_1.isInteractiveTerminal()) {
        return Promise.resolve(undefined);
    }
    const { shouldUseTerraformProject } = await inquirer.prompt({
        name: "shouldUseTerraformProject",
        message: "Do you want to start from a Terraform project?",
        type: "confirm",
        default: false,
    });
    if (!shouldUseTerraformProject) {
        return undefined;
    }
    let { terraformProject } = await inquirer.prompt([
        {
            name: "terraformProject",
            message: "Please enter the path to the Terraform project",
            type: "input",
            default: "",
        },
    ]);
    if (!terraformProject || terraformProject === "") {
        return undefined;
    }
    if (!path.isAbsolute(terraformProject)) {
        terraformProject = path.resolve(process.cwd(), terraformProject);
    }
    if (!fs.existsSync(terraformProject)) {
        throw errors_1.Errors.Usage(`Could not find folder '${terraformProject}' to initialize from.`);
    }
    return terraformProject;
}
/**
 *
 * @param templateName either the name of built-in templates or an url pointing to a zip archive
 */
async function getTemplate(templateName) {
    if (templateName == "") {
        const templateOptionRemote = "<remote zip file>";
        const options = [...init_templates_1.templates, templateOptionRemote];
        // Prompt for template
        const { template: selection } = await inquirer.prompt([
            {
                type: "list",
                name: "template",
                message: "What template do you want to use?",
                choices: options,
            },
        ]);
        if (selection === templateOptionRemote) {
            const { templateName: remoteTemplateName } = await inquirer.prompt([
                {
                    name: "templateName",
                    message: "Please enter an URL pointing to the template zip file you want to use:",
                    validate: (value) => {
                        if (value === "") {
                            return "Url can not be empty";
                        }
                        else {
                            return true;
                        }
                    },
                },
            ]);
            templateName = remoteTemplateName;
        }
        else {
            templateName = selection;
            console.log(chalkColour `\n{whiteBright Initializing a project using the {greenBright ${templateName}} template.}`);
        }
    }
    // treat as remote url
    if (!init_templates_1.templates.includes(templateName)) {
        return fetchRemoteTemplate(templateName);
    }
    else {
        return {
            Name: templateName,
            Path: path.join(init_templates_1.templatesDir, templateName),
        };
    }
}
async function fetchRemoteTemplate(templateUrl) {
    console.log(chalkColour `Fetching remote template from: {whiteBright ${templateUrl}}`);
    try {
        const url = new URL(templateUrl);
        const remoteFileName = path.basename(url.pathname) || "template.zip";
        logging_1.logger.trace(`Detected remote file name to be "${remoteFileName}" out of template URL "${templateUrl}"`);
        const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
        const tmpZipFile = path.join(tmpDir, remoteFileName);
        const zipExtractDir = path.join(tmpDir, "extracted");
        logging_1.logger.trace(`Downloading "${remoteFileName}" to temporary directory "${tmpDir}"`);
        console.log(chalkColour `Downloading "{whiteBright ${remoteFileName}}" to temporary directory`);
        await util_1.downloadFile(url.href, tmpZipFile);
        console.log("Extracting zip file");
        await extract_zip_1.default(tmpZipFile, { dir: zipExtractDir });
        // walk directory to find cdktf.json as the extracted directory contains a root directory with unknown name
        // this also allows nesting the template itself into a sub directory and having a root directory with an unrelated README
        console.log(chalkColour `Looking for directory containing {whiteBright cdktf.json}`);
        const templatePath = await findCdkTfJsonDirectory(zipExtractDir);
        if (!templatePath) {
            throw errors_1.Errors.Usage(chalkColour `Could not find a {whiteBright cdktf.json} in the extracted directory`, {});
        }
        return {
            Name: path.parse(remoteFileName).name,
            Path: templatePath,
            cleanupTemporaryFiles: async () => {
                console.log("Clearing up temporary directory of remote template");
                await fs.remove(tmpDir);
            },
        };
    }
    catch (e) {
        if (e.code === "ERR_INVALID_URL") {
            console.error(chalkColour `Could not download template: {redBright the supplied url is invalid}`);
            console.error(chalkColour `Please supply a valid url (including the protocol) or use one of the built-in templates.`);
            process.exit(1);
        }
        if (e instanceof util_1.HttpError) {
            console.error(chalkColour `Could not download template: {redBright ${e.message}}`);
            process.exit(1);
        }
        console.error(e);
        process.exit(1);
    }
}
async function findCdkTfJsonDirectory(rootDir) {
    const files = await fs.readdir(rootDir);
    if (files.includes("cdktf.json")) {
        return rootDir;
    }
    for (const file of files) {
        const fullPath = path.join(rootDir, file);
        if ((await fs.stat(fullPath)).isDirectory()) {
            const dir = findCdkTfJsonDirectory(fullPath);
            if (dir)
                return dir;
            // else continue with next sub directory
        }
    }
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZDQUErQjtBQUMvQiw2Q0FBK0I7QUFDL0IsbURBQXFDO0FBQ3JDLDhEQUFrQztBQUNsQywrREFBMkQ7QUFFM0QsdUNBQXlCO0FBQ3pCLDJDQUE2QjtBQUU3Qix1RkFBeUU7QUFFekUsNENBQTREO0FBQzVELGtEQUEyRDtBQUMzRCxnREFBNkM7QUFDN0MsNENBSXdCO0FBQ3hCLGtFQUEwRDtBQUMxRCxpREFBeUM7QUFDekMsd0RBQXdEO0FBQ3hELCtCQUFrQztBQUNsQyxrRUFLbUM7QUFDbkMscURBQTJEO0FBQzNELHNDQUE2QztBQUM3QyxrRUFBMkU7QUFDM0Usa0VBQXlDO0FBQ3pDLDJEQUE0RDtBQUU1RCxNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUV6QyxNQUFNLFFBQVEsR0FBRyxDQUFDLElBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxLQUFLLFdBQVcsQ0FBQztBQUV0RSxTQUFnQixzQkFBc0IsQ0FBQyxHQUFXO0lBQ2hELElBQ0UsRUFBRTtTQUNDLFdBQVcsQ0FBQyxHQUFHLENBQUM7U0FDaEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLHFCQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEUsTUFBTSxHQUFHLENBQUMsRUFDYjtRQUNBLE9BQU8sQ0FBQyxLQUFLLENBQ1gsV0FBVyxDQUFBLHlFQUF5RSxDQUNyRixDQUFDO1FBQ0YsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNqQjtBQUNILENBQUM7QUFaRCx3REFZQztBQUNELE1BQU0sV0FBVyxHQUFH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QUFHLENBQUM7WUFDcEIsd0NBQXdDO1NBQ3pDO0tBQ0Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0ICogYXMgaW5xdWlyZXIgZnJvbSBcImlucXVpcmVyXCI7XG5pbXBvcnQgZXh0cmFjdCBmcm9tIFwiZXh0cmFjdC16aXBcIjtcbmltcG9ydCB7IFRlcnJhZm9ybUxvZ2luIH0gZnJvbSBcIi4uL2hlbHBlci90ZXJyYWZvcm0tbG9naW5cIjtcblxuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5cbmltcG9ydCAqIGFzIHRlcnJhZm9ybUNsb3VkQ2xpZW50IGZyb20gXCIuLi9oZWxwZXIvdGVycmFmb3JtLWNsb3VkLWNsaWVudFwiO1xuXG5pbXBvcnQgeyBkb3dubG9hZEZpbGUsIEh0dHBFcnJvciB9IGZyb20gXCIuLi8uLi8uLi9saWIvdXRpbFwiO1xuaW1wb3J0IHsgbG9nRmlsZU5hbWUsIGxvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi9saWIvbG9nZ2luZ1wiO1xuaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9lcnJvcnNcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRQcm9qZWN0LFxuICBnZXRUZXJyYWZvcm1Db25maWdGcm9tRGlyLFxuICBwYXJzZVByb3ZpZGVyUmVxdWlyZW1lbnRzLFxufSBmcm9tIFwiQGNka3RmL2hjbDJjZGtcIjtcbmltcG9ydCB7IGlzTG9jYWxNb2R1bGUgfSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgc2VuZFRlbGVtZXRyeSB9IGZyb20gXCIuLi8uLi8uLi9saWIvY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQge1xuICByZWFkU2NoZW1hLFxuICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldCxcbiAgTEFOR1VBR0VTLFxuICBjb25maWcsXG59IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyB0ZW1wbGF0ZXMsIHRlbXBsYXRlc0RpciB9IGZyb20gXCIuL2luaXQtdGVtcGxhdGVzXCI7XG5pbXBvcnQgeyBpbml0LCBQcm9qZWN0IH0gZnJvbSBcIi4uLy4uLy4uL2xpYlwiO1xuaW1wb3J0IHsgYXNrRm9yQ3Jhc2hSZXBvcnRpbmdDb25zZW50IH0gZnJvbSBcIi4uLy4uLy4uL2xpYi9lcnJvci1yZXBvcnRpbmdcIjtcbmltcG9ydCBjaURldGVjdCBmcm9tIFwiQG5wbWNsaS9jaS1kZXRlY3RcIjtcbmltcG9ydCB7IGlzSW50ZXJhY3RpdmVUZXJtaW5hbCB9IGZyb20gXCIuL2NoZWNrLWVudmlyb25tZW50XCI7XG5cbmNvbnN0IGNoYWxrQ29sb3VyID0gbmV3IGNoYWxrLkluc3RhbmNlKCk7XG5cbmNvbnN0IGlzUmVhZG1lID0gKGZpbGU6IHN0cmluZykgPT4gZmlsZS50b0xvd2VyQ2FzZSgpID09PSBcInJlYWRtZS5tZFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tGb3JFbXB0eURpcmVjdG9yeShkaXI6IHN0cmluZykge1xuICBpZiAoXG4gICAgZnNcbiAgICAgIC5yZWFkZGlyU3luYyhkaXIpXG4gICAgICAuZmlsdGVyKChmKSA9PiAhZi5zdGFydHNXaXRoKFwiLlwiKSAmJiBmICE9PSBsb2dGaWxlTmFtZSAmJiAhaXNSZWFkbWUoZikpXG4gICAgICAubGVuZ3RoID4gMFxuICApIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY2hhbGtDb2xvdXJge3JlZEJyaWdodCBFUlJPUjogQ2Fubm90IGluaXRpYWxpemUgYSBwcm9qZWN0IGluIGEgbm9uLWVtcHR5IGRpcmVjdG9yeX1gXG4gICAgKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cbn1cbmNvbnN0IHRmZUhvc3RuYW1lID0gXCJhcHAudGVycmFmb3JtLmlvXCI7XG50eXBlIE9wdGlvbnMgPSB7XG4gIGxvY2FsPzogYm9vbGVhbjtcbiAgdGVtcGxhdGU/OiBzdHJpbmc7XG4gIHByb2plY3ROYW1lPzogc3RyaW5nO1xuICBwcm9qZWN0RGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGNka3RmVmVyc2lvbj86IHN0cmluZztcbiAgZGlzdD86IHN0cmluZztcbiAgZGVzdGluYXRpb246IHN0cmluZztcbiAgZnJvbVRlcnJhZm9ybVByb2plY3Q/OiBzdHJpbmc7XG4gIGVuYWJsZUNyYXNoUmVwb3J0aW5nPzogYm9vbGVhbjtcbn07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuSW5pdChhcmd2OiBPcHRpb25zKSB7XG4gIGNvbnN0IHRlbGVtZXRyeURhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gIGNvbnN0IGRlc3RpbmF0aW9uID0gYXJndi5kZXN0aW5hdGlvbiB8fCBcIi5cIjtcbiAgbGV0IHRva2VuID0gXCJcIjtcbiAgaWYgKCFhcmd2LmxvY2FsKSB7XG4gICAgLy8gV2UgYXNrIHRoZSB1c2VyIHRvIGxvZ2luIHRvIFRlcnJhZm9ybSBDbG91ZCBhbmQgc2V0IGEgdG9rZW5cbiAgICAvLyBJZiB0aGUgdXNlciBjaG9vc2VzIG5vdCB0byB1c2UgVGVycmFmb3JtIENsb3VkLCB3ZSBjb250aW51ZVxuICAgIC8vIHdpdGhvdXQgYSB0b2tlbiBhbmQgc2V0IHVwIHRoZSBwcm9qZWN0LlxuXG4gICAgY29uc3QgdGVycmFmb3JtTG9naW4gPSBuZXcgVGVycmFmb3JtTG9naW4odGZlSG9zdG5hbWUpO1xuICAgIHRva2VuID0gYXdhaXQgdGVycmFmb3JtTG9naW4uYXNrVG9Mb2dpbigpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGNoYWxrQ29sb3VyYHt5ZWxsb3cgTm90ZTogQnkgc3VwcGx5aW5nICctLWxvY2FsJyBvcHRpb24geW91IGhhdmUgY2hvc2VuIGxvY2FsIHN0b3JhZ2UgbW9kZSBmb3Igc3RvcmluZyB0aGUgc3RhdGUgb2YgeW91ciBzdGFjay5cblRoaXMgbWVhbnMgdGhhdCB5b3VyIFRlcnJhZm9ybSBzdGF0ZSBmaWxlIHdpbGwgYmUgc3RvcmVkIGxvY2FsbHkgb24gZGlzayBpbiBhIGZpbGUgJ3RlcnJhZm9ybS48U1RBQ0sgTkFNRT4udGZzdGF0ZScgaW4gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0Ln1gKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRlbXBsYXRlIHdhcyBzcGVjaWZpZWQgYnkgdGhlIHVzZXJcbiAgbGV0IHRlbXBsYXRlID0gXCJcIjtcbiAgaWYgKGFyZ3YudGVtcGxhdGUpIHtcbiAgICB0ZW1wbGF0ZSA9IGFyZ3YudGVtcGxhdGU7XG4gIH1cblxuICAvLyBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRlbXBsYXRlIGFuZCB0aGUgcHJvamVjdFxuICBjb25zdCB0ZW1wbGF0ZUluZm8gPSBhd2FpdCBnZXRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIHRlbGVtZXRyeURhdGEudGVtcGxhdGUgPSB0ZW1wbGF0ZUluZm8uTmFtZTtcblxuICBjb25zdCBwcm9qZWN0SW5mbzogUHJvamVjdCA9IGF3YWl0IGdhdGhlckluZm8oXG4gICAgdG9rZW4sXG4gICAgYXJndi5wcm9qZWN0TmFtZSxcbiAgICBhcmd2LnByb2plY3REZXNjcmlwdGlvblxuICApO1xuICBjb25zdCBwcm9qZWN0SWQgPSB1dWlkKCk7XG4gIHRlbGVtZXRyeURhdGEucHJvamVjdElkID0gcHJvamVjdElkO1xuXG4gIGNvbnN0IGZyb21UZXJyYWZvcm1Qcm9qZWN0ID1cbiAgICBhcmd2LmZyb21UZXJyYWZvcm1Qcm9qZWN0IHx8XG4gICAgKHRlbXBsYXRlSW5mby5OYW1lID09PSBcInR5cGVzY3JpcHRcIlxuICAgICAgPyBhd2FpdCBnZXRUZXJyYWZvcm1Qcm9qZWN0KClcbiAgICAgIDogdW5kZWZpbmVkKTtcblxuICBpZiAoIWFyZ3YubG9jYWwpIHtcbiAgICBpZiAoIShcIk9yZ2FuaXphdGlvbk5hbWVcIiBpbiBwcm9qZWN0SW5mbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBvcmdhbml6YXRpb24gbmFtZSBpbiBwcm9qZWN0IGluZm9gKTtcbiAgICB9XG5cbiAgICBpZiAoIShcIldvcmtzcGFjZU5hbWVcIiBpbiBwcm9qZWN0SW5mbykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBvcmdhbml6YXRpb24gbmFtZSBpbiBwcm9qZWN0IGluZm9gKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0b2tlbiBpcyBzZXQgc28gd2UgY2FuIHNldCB1cCBUZXJyYWZvcm0gQ2xvdWQgd29ya3NwYWNlXG4gICAgLy8gb25seSBzZXQgd2l0aCB0aGUgJy0tbG9jYWwnIG9wdGlvbiBpcyBzcGVjaWZpZWQgdGhlIHVzZXIuXG4gICAgaWYgKHRva2VuICE9IFwiXCIpIHtcbiAgICAgIHRlbGVtZXRyeURhdGEuaXNSZW1vdGUgPSBCb29sZWFuKHRva2VuKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBjaGFsa0NvbG91cmBcXG57d2hpdGVCcmlnaHQgU2V0dGluZyB1cCByZW1vdGUgc3RhdGUgYmFja2VuZCBhbmQgd29ya3NwYWNlIGluIFRlcnJhZm9ybSBDbG91ZC59YFxuICAgICAgKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRlcnJhZm9ybUNsb3VkQ2xpZW50LmNyZWF0ZVdvcmtzcGFjZShcbiAgICAgICAgICB0ZmVIb3N0bmFtZSxcbiAgICAgICAgICBwcm9qZWN0SW5mby5Pcmdhbml6YXRpb25OYW1lLFxuICAgICAgICAgIHByb2plY3RJbmZvLldvcmtzcGFjZU5hbWUsXG4gICAgICAgICAgdG9rZW5cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgY2hhbGtDb2xvdXJge3JlZEJyaWdodCBFUlJPUjogQ291bGQgbm90IGNyZWF0ZSBUZXJyYWZvcm0gQ2xvdWQgV29ya3NwYWNlOiAke2Vycm9yLm1lc3NhZ2V9fWBcbiAgICAgICAgKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNpOiBzdHJpbmcgfCBmYWxzZSA9IGNpRGV0ZWN0KCk7XG4gIGNvbnN0IHNlbmRDcmFzaFJlcG9ydHMgPVxuICAgIGFyZ3YuZW5hYmxlQ3Jhc2hSZXBvcnRpbmcgPz9cbiAgICAoY2kgPyBmYWxzZSA6IGF3YWl0IGFza0ZvckNyYXNoUmVwb3J0aW5nQ29uc2VudCgpKTtcblxuICBsZXQgY29udmVydFJlc3VsdCwgaW1wb3J0UGF0aDtcbiAgaWYgKGZyb21UZXJyYWZvcm1Qcm9qZWN0KSB7XG4gICAgaWYgKHRlbXBsYXRlSW5mby5OYW1lICE9PSBcInR5cGVzY3JpcHRcIikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRoZSAtLWZyb20tdGVycmFmb3JtLXByb2plY3QgZmxhZyBpcyBvbmx5IHN1cHBvcnRlZCB3aXRoIHRoZSB0eXBlc2NyaXB0IHRlbXBsYXRlLiBUaGUgY29tbWFuZCB3aWxsIGNvbnRpbnVlIGFuZCBpZ25vcmUgdGhlIGZsYWcuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpbXBvcnRQYXRoID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIGZyb21UZXJyYWZvcm1Qcm9qZWN0KTtcblxuICAgIGNvbnN0IGNvbWJpbmVkVGZGaWxlID0gZ2V0VGVycmFmb3JtQ29uZmlnRnJvbURpcihpbXBvcnRQYXRoKTtcblxuICAgIC8vIEZldGNoIGFsbCBwcm92aWRlciByZXF1aXJlbWVudHMgZnJvbSB0aGUgcHJvamVjdFxuICAgIGNvbnN0IHByb3ZpZGVyUmVxdWlyZW1lbnRzID0gYXdhaXQgcGFyc2VQcm92aWRlclJlcXVpcmVtZW50cyhcbiAgICAgIGNvbWJpbmVkVGZGaWxlXG4gICAgKTtcblxuICAgIC8vIEdldCBhbGwgdGhlIHByb3ZpZGVyIHNjaGVtYXNcbiAgICBjb25zdCB7IHByb3ZpZGVyU2NoZW1hIH0gPSBhd2FpdCByZWFkU2NoZW1hKFxuICAgICAgT2JqZWN0LmVudHJpZXMocHJvdmlkZXJSZXF1aXJlbWVudHMpLm1hcCgoW25hbWUsIHZlcnNpb25dKSA9PlxuICAgICAgICBDb25zdHJ1Y3RzTWFrZXJQcm92aWRlclRhcmdldC5mcm9tKFxuICAgICAgICAgIG5ldyBjb25maWcuVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50KGAke25hbWV9QCAke3ZlcnNpb259YCksXG4gICAgICAgICAgTEFOR1VBR0VTWzBdXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnZlcnRSZXN1bHQgPSBhd2FpdCBjb252ZXJ0UHJvamVjdChjb21iaW5lZFRmRmlsZSwge1xuICAgICAgICBsYW5ndWFnZTogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgIHByb3ZpZGVyU2NoZW1hLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoZXJyLCB7IGZyb21UZXJyYWZvcm1Qcm9qZWN0OiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGF3YWl0IGluaXQoe1xuICAgIGNka3RmVmVyc2lvbjogYXJndi5jZGt0ZlZlcnNpb24sXG4gICAgZGVzdGluYXRpb24sXG4gICAgZGlzdDogYXJndi5kaXN0LFxuICAgIHByb2plY3RJZCxcbiAgICBwcm9qZWN0SW5mbyxcbiAgICB0ZW1wbGF0ZVBhdGg6IHRlbXBsYXRlSW5mby5QYXRoLFxuICAgIHNlbmRDcmFzaFJlcG9ydHM6IHNlbmRDcmFzaFJlcG9ydHMsXG4gIH0pO1xuXG4gIGlmIChjb252ZXJ0UmVzdWx0ICYmIGltcG9ydFBhdGgpIHtcbiAgICBjb25zdCB7IGNvZGUsIGNka3RmSnNvbiwgc3RhdHMgfSA9IGNvbnZlcnRSZXN1bHQ7XG5cbiAgICBjb25zdCBtYWluVHMgPSBmcy5yZWFkRmlsZVN5bmMoXG4gICAgICBwYXRoLnJlc29sdmUoZGVzdGluYXRpb24sIFwibWFpbi50c1wiKSxcbiAgICAgIFwidXRmOFwiXG4gICAgKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKFxuICAgICAgcGF0aC5yZXNvbHZlKGRlc3RpbmF0aW9uLCBcIm1haW4udHNcIiksXG4gICAgICBjb2RlKG1haW5UcyksXG4gICAgICBcInV0ZjhcIlxuICAgICk7XG5cbiAgICBjb25zdCByZW5kZXJlZENka3RmSnNvbiA9IGNka3RmSnNvbihcbiAgICAgIHJlcXVpcmUocGF0aC5yZXNvbHZlKGRlc3RpbmF0aW9uLCBcImNka3RmLmpzb25cIikpXG4gICAgKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKFxuICAgICAgcGF0aC5yZXNvbHZlKGRlc3RpbmF0aW9uLCBcImNka3RmLmpzb25cIiksXG4gICAgICBKU09OLnN0cmluZ2lmeShyZW5kZXJlZENka3RmSnNvbiwgbnVsbCwgMiksXG4gICAgICBcInV0ZjhcIlxuICAgICk7XG5cbiAgICBjb25zdCB7IHRlcnJhZm9ybU1vZHVsZXMsIHRlcnJhZm9ybVByb3ZpZGVycyB9ID0gcmVuZGVyZWRDZGt0Zkpzb247XG5cbiAgICBpZiAodGVycmFmb3JtTW9kdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb3B5TG9jYWxNb2R1bGVzKHRlcnJhZm9ybU1vZHVsZXMsIGltcG9ydFBhdGgsIGRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAodGVycmFmb3JtTW9kdWxlcy5sZW5ndGggKyB0ZXJyYWZvcm1Qcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgZXhlY1N5bmMoXCJucG0gcnVuIGdldFwiLCB7IGN3ZDogZGVzdGluYXRpb24gfSk7XG4gICAgfVxuXG4gICAgdGVsZW1ldHJ5RGF0YS5jb252ZXJzaW9uU3RhdHMgPSBzdGF0cztcbiAgfVxuXG4gIGlmICh0ZW1wbGF0ZUluZm8uY2xlYW51cFRlbXBvcmFyeUZpbGVzKSB7XG4gICAgYXdhaXQgdGVtcGxhdGVJbmZvLmNsZWFudXBUZW1wb3JhcnlGaWxlcygpO1xuICB9XG5cbiAgYXdhaXQgc2VuZFRlbGVtZXRyeShcImluaXRcIiwgdGVsZW1ldHJ5RGF0YSk7XG59XG5cbmZ1bmN0aW9uIGNvcHlMb2NhbE1vZHVsZXMoXG4gIG1vZHVsZXM6IGFueVtdLFxuICBzb3VyY2VQYXRoOiBzdHJpbmcsXG4gIGRlc3RpbmF0aW9uOiBzdHJpbmdcbikge1xuICBtb2R1bGVzXG4gICAgLmZpbHRlcigobSkgPT4gaXNMb2NhbE1vZHVsZShtKSlcbiAgICAubWFwKChtKSA9PlxuICAgICAgZnMuY29weVN5bmMocGF0aC5yZXNvbHZlKHNvdXJjZVBhdGgsIG0pLCBwYXRoLnJlc29sdmUoZGVzdGluYXRpb24sIG0pLCB7XG4gICAgICAgIHJlY3Vyc2l2ZTogdHJ1ZSxcbiAgICAgIH0pXG4gICAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2F0aGVySW5mbyhcbiAgdG9rZW46IHN0cmluZyxcbiAgcHJvamVjdE5hbWU/OiBzdHJpbmcsXG4gIHByb2plY3REZXNjcmlwdGlvbj86IHN0cmluZ1xuKTogUHJvbWlzZTxQcm9qZWN0PiB7XG4gIGNvbnN0IGN1cnJlbnREaXJlY3RvcnkgPSBwYXRoLmJhc2VuYW1lKHByb2Nlc3MuY3dkKCkpO1xuICBjb25zdCBwcm9qZWN0RGVzY3JpcHRpb25EZWZhdWx0ID1cbiAgICBcIkEgc2ltcGxlIGdldHRpbmcgc3RhcnRlZCBwcm9qZWN0IGZvciBjZGt0Zi5cIjtcbiAgY29uc3QgcXVlc3Rpb25zID0gW107XG4gIGlmICghcHJvamVjdE5hbWUpIHtcbiAgICBxdWVzdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiBcInByb2plY3ROYW1lXCIsXG4gICAgICBtZXNzYWdlOiBcIlByb2plY3QgTmFtZVwiLFxuICAgICAgZGVmYXVsdDogY3VycmVudERpcmVjdG9yeSxcbiAgICB9KTtcbiAgfVxuICBpZiAoIXByb2plY3REZXNjcmlwdGlvbikge1xuICAgIHF1ZXN0aW9ucy5wdXNoKHtcbiAgICAgIG5hbWU6IFwicHJvamVjdERlc2NyaXB0aW9uXCIsXG4gICAgICBtZXNzYWdlOiBcIlByb2plY3QgRGVzY3JpcHRpb25cIixcbiAgICAgIGRlZmF1bHQ6IHByb2plY3REZXNjcmlwdGlvbkRlZmF1bHQsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBhbnN3ZXJzOiB7XG4gICAgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG4gICAgcHJvamVjdERlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB9ID0gcXVlc3Rpb25zLmxlbmd0aCA+IDAgPyBhd2FpdCBpbnF1aXJlci5wcm9tcHQocXVlc3Rpb25zKSA6IHt9O1xuXG4gIGNvbnN0IHByb2plY3Q6IFByb2plY3QgPSB7XG4gICAgTmFtZTogcHJvamVjdE5hbWUgfHwgYW5zd2Vycy5wcm9qZWN0TmFtZSB8fCBcIlwiLFxuICAgIERlc2NyaXB0aW9uOiBwcm9qZWN0RGVzY3JpcHRpb24gfHwgYW5zd2Vycy5wcm9qZWN0RGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICBPcmdhbml6YXRpb25OYW1lOiBcIlwiLFxuICAgIFdvcmtzcGFjZU5hbWU6IFwiXCIsXG4gIH07XG5cbiAgaWYgKHRva2VuICE9IFwiXCIpIHtcbiAgICBjb25zb2xlLmxvZyhjaGFsa0NvbG91cmBcXG5EZXRlY3RlZCB7Ymx1ZUJyaWdodCBUZXJyYWZvcm0gQ2xvdWR9IHRva2VuLmApO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgY2hhbGtDb2xvdXJgXFxuV2Ugd2lsbCBub3cgc2V0IHVwIHtibHVlQnJpZ2h0IFRlcnJhZm9ybSBDbG91ZH0gZm9yIHlvdXIgcHJvamVjdC5cXG5gXG4gICAgKTtcbiAgICBjb25zdCBvcmdhbml6YXRpb25OYW1lcyA9IGF3YWl0IHRlcnJhZm9ybUNsb3VkQ2xpZW50LmdldE9yZ2FuaXphdGlvbk5hbWVzKFxuICAgICAgdGZlSG9zdG5hbWUsXG4gICAgICB0b2tlblxuICAgICk7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uRGF0YSA9IG9yZ2FuaXphdGlvbk5hbWVzLmRhdGE7XG4gICAgY29uc3Qgb3JnYW5pemF0aW9uT3B0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3JnYW5pemF0aW9uIG9mIG9yZ2FuaXphdGlvbkRhdGEpIHtcbiAgICAgIG9yZ2FuaXphdGlvbk9wdGlvbnMucHVzaChvcmdhbml6YXRpb24uaWQpO1xuICAgIH1cblxuICAgIC8vIHRvZG86IGFkZCB2YWxpZGF0aW9uIGZvciB0aGUgb3JnYW5pemF0aW9uIG5hbWUgYW5kIHdvcmtzcGFjZS4gYWRkIGVycm9yIGhhbmRsaW5nXG4gICAgY29uc3QgeyBvcmdhbml6YXRpb246IG9yZ2FuaXphdGlvblNlbGVjdCB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICAgIG5hbWU6IFwib3JnYW5pemF0aW9uXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiVGVycmFmb3JtIENsb3VkIE9yZ2FuaXphdGlvbiBOYW1lXCIsXG4gICAgICAgIGNob2ljZXM6IG9yZ2FuaXphdGlvbk9wdGlvbnMsXG4gICAgICB9LFxuICAgIF0pO1xuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBjaGFsa0NvbG91cmBcXG5XZSBhcmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IHtibHVlQnJpZ2h0IFRlcnJhZm9ybSBDbG91ZCBXb3Jrc3BhY2V9IGZvciB5b3VyIHByb2plY3QuXFxuYFxuICAgICk7XG5cbiAgICBjb25zdCB7IHdvcmtzcGFjZTogd29ya3NwYWNlTmFtZSB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJ3b3Jrc3BhY2VcIixcbiAgICAgICAgbWVzc2FnZTogXCJUZXJyYWZvcm0gQ2xvdWQgV29ya3NwYWNlIE5hbWVcIixcbiAgICAgICAgZGVmYXVsdDogcHJvamVjdC5OYW1lLFxuICAgICAgfSxcbiAgICBdKTtcbiAgICBwcm9qZWN0Lk9yZ2FuaXphdGlvbk5hbWUgPSBvcmdhbml6YXRpb25TZWxlY3Q7XG4gICAgcHJvamVjdC5Xb3Jrc3BhY2VOYW1lID0gd29ya3NwYWNlTmFtZTtcbiAgfVxuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRUZXJyYWZvcm1Qcm9qZWN0KCk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGlmICghaXNJbnRlcmFjdGl2ZVRlcm1pbmFsKCkpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIH1cbiAgY29uc3QgeyBzaG91bGRVc2VUZXJyYWZvcm1Qcm9qZWN0IH0gPSBhd2FpdCBpbnF1aXJlci5wcm9tcHQoe1xuICAgIG5hbWU6IFwic2hvdWxkVXNlVGVycmFmb3JtUHJvamVjdFwiLFxuICAgIG1lc3NhZ2U6IFwiRG8geW91IHdhbnQgdG8gc3RhcnQgZnJvbSBhIFRlcnJhZm9ybSBwcm9qZWN0P1wiLFxuICAgIHR5cGU6IFwiY29uZmlybVwiLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICB9KTtcblxuICBpZiAoIXNob3VsZFVzZVRlcnJhZm9ybVByb2plY3QpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGV0IHsgdGVycmFmb3JtUHJvamVjdCB9ID0gYXdhaXQgaW5xdWlyZXIucHJvbXB0KFtcbiAgICB7XG4gICAgICBuYW1lOiBcInRlcnJhZm9ybVByb2plY3RcIixcbiAgICAgIG1lc3NhZ2U6IFwiUGxlYXNlIGVudGVyIHRoZSBwYXRoIHRvIHRoZSBUZXJyYWZvcm0gcHJvamVjdFwiLFxuICAgICAgdHlwZTogXCJpbnB1dFwiLFxuICAgICAgZGVmYXVsdDogXCJcIixcbiAgICB9LFxuICBdKTtcblxuICBpZiAoIXRlcnJhZm9ybVByb2plY3QgfHwgdGVycmFmb3JtUHJvamVjdCA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIXBhdGguaXNBYnNvbHV0ZSh0ZXJyYWZvcm1Qcm9qZWN0KSkge1xuICAgIHRlcnJhZm9ybVByb2plY3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgdGVycmFmb3JtUHJvamVjdCk7XG4gIH1cblxuICBpZiAoIWZzLmV4aXN0c1N5bmModGVycmFmb3JtUHJvamVjdCkpIHtcbiAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICBgQ291bGQgbm90IGZpbmQgZm9sZGVyICcke3RlcnJhZm9ybVByb2plY3R9JyB0byBpbml0aWFsaXplIGZyb20uYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdGVycmFmb3JtUHJvamVjdDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHRlbXBsYXRlTmFtZSBlaXRoZXIgdGhlIG5hbWUgb2YgYnVpbHQtaW4gdGVtcGxhdGVzIG9yIGFuIHVybCBwb2ludGluZyB0byBhIHppcCBhcmNoaXZlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldFRlbXBsYXRlKHRlbXBsYXRlTmFtZTogc3RyaW5nKTogUHJvbWlzZTxUZW1wbGF0ZT4ge1xuICBpZiAodGVtcGxhdGVOYW1lID09IFwiXCIpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZU9wdGlvblJlbW90ZSA9IFwiPHJlbW90ZSB6aXAgZmlsZT5cIjtcbiAgICBjb25zdCBvcHRpb25zID0gWy4uLnRlbXBsYXRlcywgdGVtcGxhdGVPcHRpb25SZW1vdGVdO1xuICAgIC8vIFByb21wdCBmb3IgdGVtcGxhdGVcbiAgICBjb25zdCB7IHRlbXBsYXRlOiBzZWxlY3Rpb24gfSA9IGF3YWl0IGlucXVpcmVyLnByb21wdChbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICBuYW1lOiBcInRlbXBsYXRlXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiV2hhdCB0ZW1wbGF0ZSBkbyB5b3Ugd2FudCB0byB1c2U/XCIsXG4gICAgICAgIGNob2ljZXM6IG9wdGlvbnMsXG4gICAgICB9LFxuICAgIF0pO1xuXG4gICAgaWYgKHNlbGVjdGlvbiA9PT0gdGVtcGxhdGVPcHRpb25SZW1vdGUpIHtcbiAgICAgIGNvbnN0IHsgdGVtcGxhdGVOYW1lOiByZW1vdGVUZW1wbGF0ZU5hbWUgfSA9IGF3YWl0IGlucXVpcmVyLnByb21wdChbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInRlbXBsYXRlTmFtZVwiLFxuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICBcIlBsZWFzZSBlbnRlciBhbiBVUkwgcG9pbnRpbmcgdG8gdGhlIHRlbXBsYXRlIHppcCBmaWxlIHlvdSB3YW50IHRvIHVzZTpcIixcbiAgICAgICAgICB2YWxpZGF0ZTogKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgICByZXR1cm4gXCJVcmwgY2FuIG5vdCBiZSBlbXB0eVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIF0pO1xuXG4gICAgICB0ZW1wbGF0ZU5hbWUgPSByZW1vdGVUZW1wbGF0ZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXBsYXRlTmFtZSA9IHNlbGVjdGlvbjtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBjaGFsa0NvbG91cmBcXG57d2hpdGVCcmlnaHQgSW5pdGlhbGl6aW5nIGEgcHJvamVjdCB1c2luZyB0aGUge2dyZWVuQnJpZ2h0ICR7dGVtcGxhdGVOYW1lfX0gdGVtcGxhdGUufWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJlYXQgYXMgcmVtb3RlIHVybFxuICBpZiAoIXRlbXBsYXRlcy5pbmNsdWRlcyh0ZW1wbGF0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZldGNoUmVtb3RlVGVtcGxhdGUodGVtcGxhdGVOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgTmFtZTogdGVtcGxhdGVOYW1lLFxuICAgICAgUGF0aDogcGF0aC5qb2luKHRlbXBsYXRlc0RpciwgdGVtcGxhdGVOYW1lKSxcbiAgICB9O1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVtb3RlVGVtcGxhdGUodGVtcGxhdGVVcmw6IHN0cmluZyk6IFByb21pc2U8VGVtcGxhdGU+IHtcbiAgY29uc29sZS5sb2coXG4gICAgY2hhbGtDb2xvdXJgRmV0Y2hpbmcgcmVtb3RlIHRlbXBsYXRlIGZyb206IHt3aGl0ZUJyaWdodCAke3RlbXBsYXRlVXJsfX1gXG4gICk7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh0ZW1wbGF0ZVVybCk7XG4gICAgY29uc3QgcmVtb3RlRmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKHVybC5wYXRobmFtZSkgfHwgXCJ0ZW1wbGF0ZS56aXBcIjtcbiAgICBsb2dnZXIudHJhY2UoXG4gICAgICBgRGV0ZWN0ZWQgcmVtb3RlIGZpbGUgbmFtZSB0byBiZSBcIiR7cmVtb3RlRmlsZU5hbWV9XCIgb3V0IG9mIHRlbXBsYXRlIFVSTCBcIiR7dGVtcGxhdGVVcmx9XCJgXG4gICAgKTtcblxuICAgIGNvbnN0IHRtcERpciA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNka3RmLlwiKSk7XG4gICAgY29uc3QgdG1wWmlwRmlsZSA9IHBhdGguam9pbih0bXBEaXIsIHJlbW90ZUZpbGVOYW1lKTtcbiAgICBjb25zdCB6aXBFeHRyYWN0RGlyID0gcGF0aC5qb2luKHRtcERpciwgXCJleHRyYWN0ZWRcIik7XG5cbiAgICBsb2dnZXIudHJhY2UoXG4gICAgICBgRG93bmxvYWRpbmcgXCIke3JlbW90ZUZpbGVOYW1lfVwiIHRvIHRlbXBvcmFyeSBkaXJlY3RvcnkgXCIke3RtcERpcn1cImBcbiAgICApO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgY2hhbGtDb2xvdXJgRG93bmxvYWRpbmcgXCJ7d2hpdGVCcmlnaHQgJHtyZW1vdGVGaWxlTmFtZX19XCIgdG8gdGVtcG9yYXJ5IGRpcmVjdG9yeWBcbiAgICApO1xuICAgIGF3YWl0IGRvd25sb2FkRmlsZSh1cmwuaHJlZiwgdG1wWmlwRmlsZSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIkV4dHJhY3RpbmcgemlwIGZpbGVcIik7XG4gICAgYXdhaXQgZXh0cmFjdCh0bXBaaXBGaWxlLCB7IGRpcjogemlwRXh0cmFjdERpciB9KTtcblxuICAgIC8vIHdhbGsgZGlyZWN0b3J5IHRvIGZpbmQgY2RrdGYuanNvbiBhcyB0aGUgZXh0cmFjdGVkIGRpcmVjdG9yeSBjb250YWlucyBhIHJvb3QgZGlyZWN0b3J5IHdpdGggdW5rbm93biBuYW1lXG4gICAgLy8gdGhpcyBhbHNvIGFsbG93cyBuZXN0aW5nIHRoZSB0ZW1wbGF0ZSBpdHNlbGYgaW50byBhIHN1YiBkaXJlY3RvcnkgYW5kIGhhdmluZyBhIHJvb3QgZGlyZWN0b3J5IHdpdGggYW4gdW5yZWxhdGVkIFJFQURNRVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgY2hhbGtDb2xvdXJgTG9va2luZyBmb3IgZGlyZWN0b3J5IGNvbnRhaW5pbmcge3doaXRlQnJpZ2h0IGNka3RmLmpzb259YFxuICAgICk7XG4gICAgY29uc3QgdGVtcGxhdGVQYXRoID0gYXdhaXQgZmluZENka1RmSnNvbkRpcmVjdG9yeSh6aXBFeHRyYWN0RGlyKTtcblxuICAgIGlmICghdGVtcGxhdGVQYXRoKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgIGNoYWxrQ29sb3VyYENvdWxkIG5vdCBmaW5kIGEge3doaXRlQnJpZ2h0IGNka3RmLmpzb259IGluIHRoZSBleHRyYWN0ZWQgZGlyZWN0b3J5YCxcbiAgICAgICAge31cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIE5hbWU6IHBhdGgucGFyc2UocmVtb3RlRmlsZU5hbWUpLm5hbWUsIC8vIHN0cmlwcyAuemlwIGZyb20gZmlsZW5hbWVcbiAgICAgIFBhdGg6IHRlbXBsYXRlUGF0aCxcbiAgICAgIGNsZWFudXBUZW1wb3JhcnlGaWxlczogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNsZWFyaW5nIHVwIHRlbXBvcmFyeSBkaXJlY3Rvcnkgb2YgcmVtb3RlIHRlbXBsYXRlXCIpO1xuICAgICAgICBhd2FpdCBmcy5yZW1vdmUodG1wRGlyKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09IFwiRVJSX0lOVkFMSURfVVJMXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGNoYWxrQ29sb3VyYENvdWxkIG5vdCBkb3dubG9hZCB0ZW1wbGF0ZToge3JlZEJyaWdodCB0aGUgc3VwcGxpZWQgdXJsIGlzIGludmFsaWR9YFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIGNoYWxrQ29sb3VyYFBsZWFzZSBzdXBwbHkgYSB2YWxpZCB1cmwgKGluY2x1ZGluZyB0aGUgcHJvdG9jb2wpIG9yIHVzZSBvbmUgb2YgdGhlIGJ1aWx0LWluIHRlbXBsYXRlcy5gXG4gICAgICApO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cbiAgICBpZiAoZSBpbnN0YW5jZW9mIEh0dHBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgY2hhbGtDb2xvdXJgQ291bGQgbm90IGRvd25sb2FkIHRlbXBsYXRlOiB7cmVkQnJpZ2h0ICR7ZS5tZXNzYWdlfX1gXG4gICAgICApO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbmRDZGtUZkpzb25EaXJlY3Rvcnkocm9vdERpcjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnN0IGZpbGVzID0gYXdhaXQgZnMucmVhZGRpcihyb290RGlyKTtcblxuICBpZiAoZmlsZXMuaW5jbHVkZXMoXCJjZGt0Zi5qc29uXCIpKSB7XG4gICAgcmV0dXJuIHJvb3REaXI7XG4gIH1cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4ocm9vdERpciwgZmlsZSk7XG4gICAgaWYgKChhd2FpdCBmcy5zdGF0KGZ1bGxQYXRoKSkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZGlyID0gZmluZENka1RmSnNvbkRpcmVjdG9yeShmdWxsUGF0aCk7XG4gICAgICBpZiAoZGlyKSByZXR1cm4gZGlyO1xuICAgICAgLy8gZWxzZSBjb250aW51ZSB3aXRoIG5leHQgc3ViIGRpcmVjdG9yeVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuaW50ZXJmYWNlIFRlbXBsYXRlIHtcbiAgTmFtZTogc3RyaW5nO1xuICBQYXRoOiBzdHJpbmc7XG4gIGNsZWFudXBUZW1wb3JhcnlGaWxlcz86ICgpID0+IFByb21pc2U8dm9pZD47XG59XG4iXX0=