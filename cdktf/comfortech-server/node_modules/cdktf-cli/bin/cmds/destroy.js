"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const provider_generator_1 = require("@cdktf/provider-generator");
const utilities_1 = require("./helper/utilities");
const errors_1 = require("../../lib/errors");
const base_command_1 = require("./helper/base-command");
const config = provider_generator_1.config.readConfigSync();
class Command extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.command = "destroy [stacks..]";
        this.describe = "Destroy the given stacks";
        this.builder = (args) => args
            .positional("stacks", {
            desc: "Destroy stacks matching the given ids. Required when more than one stack is present in the app",
            type: "string",
        })
            .option("app", {
            default: config.app,
            required: true,
            desc: "Command to use in order to execute cdktf app",
            alias: "a",
        })
            .option("output", {
            default: config.output,
            required: true,
            desc: "Output directory for the synthesized Terraform config",
            alias: "o",
        })
            .option("auto-approve", {
            type: "boolean",
            default: false,
            required: false,
            desc: "Auto approve",
        })
            .option("ignore-missing-stack-dependencies", {
            type: "boolean",
            required: false,
            desc: "Don't check if all stacks specified in the command have their dependencies included as well",
            default: false,
        })
            .option("parallelism", {
            type: "number",
            required: false,
            desc: "Number of concurrent CDKTF stacks to run. Defaults to infinity, denoted by -1",
            default: -1,
        })
            .showHelpOnFail(true);
    }
    async handleCommand(argv) {
        errors_1.Errors.setScope("destroy");
        // deferred require to keep cdktf-cli main entrypoint small (e.g. for fast shell completions)
        const api = utilities_1.requireHandlers();
        await api.destroy(argv);
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVzdHJveS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlc3Ryb3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFDQSxrRUFBMEQ7QUFDMUQsa0RBQXFEO0FBQ3JELDZDQUEwQztBQUMxQyx3REFBb0Q7QUFFcEQsTUFBTSxNQUFNLEdBQUcsMkJBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUVwQyxNQUFNLE9BQVEsU0FBUSwwQkFBVztJQUFqQzs7UUFDa0IsWUFBTyxHQUFHLG9CQUFvQixDQUFDO1FBQy9CLGFBQVEsR0FBRywwQkFBMEIsQ0FBQztRQUV0QyxZQUFPLEdBQUcsQ0FBQyxJQUFnQixFQUFFLEVBQUUsQ0FDN0MsSUFBSTthQUNELFVBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDcEIsSUFBSSxFQUFFLGdHQUFnRztZQUN0RyxJQUFJLEVBQUUsUUFBUTtTQUNmLENBQUM7YUFDRCxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxHQUFHO1lBQ25CLFFBQVEsRUFBRSxJQUFJO1lBQ2QsSUFBSSxFQUFFLDhDQUE4QztZQUNwRCxLQUFLLEVBQUUsR0FBRztTQUNYLENBQUM7YUFDRCxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ2hCLE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTTtZQUN0QixRQUFRLEVBQUUsSUFBSTtZQUNkLElBQUksRUFBRSx1REFBdUQ7WUFDN0QsS0FBSyxFQUFFLEdBQUc7U0FDWCxDQUFDO2FBQ0QsTUFBTSxDQUFDLGNBQWMsRUFBRTtZQUN0QixJQUFJLEVBQUUsU0FBUztZQUNmLE9BQU8sRUFBRSxLQUFLO1lBQ2QsUUFBUSxFQUFFLEtBQUs7WUFDZixJQUFJLEVBQUUsY0FBYztTQUNyQixDQUFDO2FBQ0QsTUFBTSxDQUFDLG1DQUFtQyxFQUFFO1lBQzNDLElBQUksRUFBRSxTQUFTO1lBQ2YsUUFBUSxFQUFFLEtBQUs7WUFDZixJQUFJLEVBQUUsNkZBQTZGO1lBQ25HLE9BQU8sRUFBRSxLQUFLO1NBQ2YsQ0FBQzthQUNELE1BQU0sQ0FBQyxhQUFhLEVBQUU7WUFDckIsSUFBSSxFQUFFLFFBQVE7WUFDZCxRQUFRLEVBQUUsS0FBSztZQUNmLElBQUksRUFBRSwrRUFBK0U7WUFDckYsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUNaLENBQUM7YUFDRCxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7SUFRNUIsQ0FBQztJQU5RLEtBQUssQ0FBQyxhQUFhLENBQUMsSUFBUztRQUNsQyxlQUFNLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzNCLDZGQUE2RjtRQUM3RixNQUFNLEdBQUcsR0FBRywyQkFBZSxFQUFFLENBQUM7UUFDOUIsTUFBTSxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUM7Q0FDRjtBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHlhcmdzIGZyb20gXCJ5YXJnc1wiO1xuaW1wb3J0IHsgY29uZmlnIGFzIGNmZyB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyByZXF1aXJlSGFuZGxlcnMgfSBmcm9tIFwiLi9oZWxwZXIvdXRpbGl0aWVzXCI7XG5pbXBvcnQgeyBFcnJvcnMgfSBmcm9tIFwiLi4vLi4vbGliL2Vycm9yc1wiO1xuaW1wb3J0IHsgQmFzZUNvbW1hbmQgfSBmcm9tIFwiLi9oZWxwZXIvYmFzZS1jb21tYW5kXCI7XG5cbmNvbnN0IGNvbmZpZyA9IGNmZy5yZWFkQ29uZmlnU3luYygpO1xuXG5jbGFzcyBDb21tYW5kIGV4dGVuZHMgQmFzZUNvbW1hbmQge1xuICBwdWJsaWMgcmVhZG9ubHkgY29tbWFuZCA9IFwiZGVzdHJveSBbc3RhY2tzLi5dXCI7XG4gIHB1YmxpYyByZWFkb25seSBkZXNjcmliZSA9IFwiRGVzdHJveSB0aGUgZ2l2ZW4gc3RhY2tzXCI7XG5cbiAgcHVibGljIHJlYWRvbmx5IGJ1aWxkZXIgPSAoYXJnczogeWFyZ3MuQXJndikgPT5cbiAgICBhcmdzXG4gICAgICAucG9zaXRpb25hbChcInN0YWNrc1wiLCB7XG4gICAgICAgIGRlc2M6IFwiRGVzdHJveSBzdGFja3MgbWF0Y2hpbmcgdGhlIGdpdmVuIGlkcy4gUmVxdWlyZWQgd2hlbiBtb3JlIHRoYW4gb25lIHN0YWNrIGlzIHByZXNlbnQgaW4gdGhlIGFwcFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJhcHBcIiwge1xuICAgICAgICBkZWZhdWx0OiBjb25maWcuYXBwLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgZGVzYzogXCJDb21tYW5kIHRvIHVzZSBpbiBvcmRlciB0byBleGVjdXRlIGNka3RmIGFwcFwiLFxuICAgICAgICBhbGlhczogXCJhXCIsXG4gICAgICB9KVxuICAgICAgLm9wdGlvbihcIm91dHB1dFwiLCB7XG4gICAgICAgIGRlZmF1bHQ6IGNvbmZpZy5vdXRwdXQsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgICBkZXNjOiBcIk91dHB1dCBkaXJlY3RvcnkgZm9yIHRoZSBzeW50aGVzaXplZCBUZXJyYWZvcm0gY29uZmlnXCIsXG4gICAgICAgIGFsaWFzOiBcIm9cIixcbiAgICAgIH0pXG4gICAgICAub3B0aW9uKFwiYXV0by1hcHByb3ZlXCIsIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlc2M6IFwiQXV0byBhcHByb3ZlXCIsXG4gICAgICB9KVxuICAgICAgLm9wdGlvbihcImlnbm9yZS1taXNzaW5nLXN0YWNrLWRlcGVuZGVuY2llc1wiLCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlc2M6IFwiRG9uJ3QgY2hlY2sgaWYgYWxsIHN0YWNrcyBzcGVjaWZpZWQgaW4gdGhlIGNvbW1hbmQgaGF2ZSB0aGVpciBkZXBlbmRlbmNpZXMgaW5jbHVkZWQgYXMgd2VsbFwiLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIH0pXG4gICAgICAub3B0aW9uKFwicGFyYWxsZWxpc21cIiwge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIGRlc2M6IFwiTnVtYmVyIG9mIGNvbmN1cnJlbnQgQ0RLVEYgc3RhY2tzIHRvIHJ1bi4gRGVmYXVsdHMgdG8gaW5maW5pdHksIGRlbm90ZWQgYnkgLTFcIixcbiAgICAgICAgZGVmYXVsdDogLTEsXG4gICAgICB9KVxuICAgICAgLnNob3dIZWxwT25GYWlsKHRydWUpO1xuXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVDb21tYW5kKGFyZ3Y6IGFueSkge1xuICAgIEVycm9ycy5zZXRTY29wZShcImRlc3Ryb3lcIik7XG4gICAgLy8gZGVmZXJyZWQgcmVxdWlyZSB0byBrZWVwIGNka3RmLWNsaSBtYWluIGVudHJ5cG9pbnQgc21hbGwgKGUuZy4gZm9yIGZhc3Qgc2hlbGwgY29tcGxldGlvbnMpXG4gICAgY29uc3QgYXBpID0gcmVxdWlyZUhhbmRsZXJzKCk7XG4gICAgYXdhaXQgYXBpLmRlc3Ryb3koYXJndik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29tbWFuZCgpO1xuIl19