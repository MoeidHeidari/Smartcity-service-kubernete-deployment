"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerAdd = exports.debug = exports.output = exports.watch = exports.synth = exports.login = exports.list = exports.init = exports.get = exports.diff = exports.destroy = exports.deploy = exports.convert = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs = __importStar(require("fs-extra"));
const react_1 = __importDefault(require("react"));
const hcl2cdk_1 = require("@cdktf/hcl2cdk");
const provider_generator_1 = require("@cdktf/provider-generator");
const init_1 = require("./helper/init");
const render_ink_1 = require("./helper/render-ink");
const terraform_check_1 = require("./helper/terraform-check");
const terraformCloudClient = __importStar(require("./helper/terraform-cloud-client"));
const terraform_login_1 = require("./helper/terraform-login");
const utilities_1 = require("./helper/utilities");
const version_check_1 = require("./helper/version-check");
const diff_1 = require("./ui/diff");
const deploy_1 = require("./ui/deploy");
const destroy_1 = require("./ui/destroy");
const get_1 = require("./ui/get");
const list_1 = require("./ui/list");
const synth_1 = require("./ui/synth");
const watch_1 = require("./ui/watch");
const checkpoint_1 = require("../../lib/checkpoint");
const errors_1 = require("../../lib/errors");
const output_1 = require("./ui/output");
const output_2 = require("../../lib/output");
const check_directory_1 = require("./helper/check-directory");
const check_environment_1 = require("./helper/check-environment");
const debug_1 = require("../../lib/debug");
const error_reporting_1 = require("../../lib/error-reporting");
const dependency_manager_1 = require("../../lib/dependencies/dependency-manager");
const cdktf_config_1 = require("../../lib/cdktf-config");
const logging_1 = require("../../lib/logging");
const chalkColour = new chalk_1.default.Instance();
const config = provider_generator_1.config.readConfigSync();
async function getProviderRequirements(provider) {
    let providersFromConfig = [];
    try {
        const config = cdktf_config_1.CdktfConfig.read();
        providersFromConfig = config.terraformProviders;
    }
    catch (e) {
        if (errors_1.IsErrorType(e, "External")) {
            // do nothing, expected if run in a different directory
        }
        else {
            throw e;
        }
    }
    return [...provider, ...providersFromConfig];
}
async function convert({ language, provider }) {
    await error_reporting_1.initializErrorReporting();
    await version_check_1.displayVersionMessage();
    const providerRequirements = await getProviderRequirements(provider);
    // Get all the provider schemas
    const { providerSchema } = await provider_generator_1.readSchema(providerRequirements.map((spec) => provider_generator_1.ConstructsMakerProviderTarget.from(new provider_generator_1.config.TerraformProviderConstraint(spec), provider_generator_1.LANGUAGES[0])));
    const input = await utilities_1.readStreamAsString(process.stdin, "No stdin was passed, please use it like this: cat main.tf | cdktf convert > imported.ts");
    let output;
    try {
        const { all, stats } = await hcl2cdk_1.convert(input, {
            language,
            providerSchema,
        });
        output = all;
        await checkpoint_1.sendTelemetry("convert", { ...stats, error: false });
    }
    catch (err) {
        throw errors_1.Errors.Internal(err.message, { language });
    }
    console.log(output);
}
exports.convert = convert;
async function deploy(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const command = argv.app;
    const outDir = argv.output;
    const autoApprove = argv.autoApprove;
    const stacks = argv.stacks;
    const includeSensitiveOutputs = argv.outputsFileIncludeSensitiveOutputs;
    const refreshOnly = argv.refreshOnly;
    let outputsPath = undefined;
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    let onOutputsRetrieved = () => { };
    if (argv.outputsFile) {
        outputsPath = output_2.normalizeOutputPath(argv.outputsFile);
        onOutputsRetrieved = (outputs) => output_2.saveOutputs(outputsPath, outputs, includeSensitiveOutputs);
    }
    await render_ink_1.renderInk(react_1.default.createElement(deploy_1.Deploy, {
        outDir,
        targetStacks: stacks,
        synthCommand: command,
        autoApprove,
        onOutputsRetrieved,
        outputsPath,
        ignoreMissingStackDependencies: argv.ignoreMissingStackDependencies || false,
        parallelism: argv.parallelism,
        refreshOnly,
    }));
}
exports.deploy = deploy;
async function destroy(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const command = argv.app;
    const outDir = argv.output;
    const autoApprove = argv.autoApprove;
    const stacks = argv.stacks;
    await render_ink_1.renderInk(react_1.default.createElement(destroy_1.Destroy, {
        outDir,
        targetStacks: stacks,
        synthCommand: command,
        autoApprove,
        ignoreMissingStackDependencies: argv.ignoreMissingStackDependencies || false,
        parallelism: argv.parallelism,
    }));
}
exports.destroy = destroy;
async function diff(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const command = argv.app;
    const outDir = argv.output;
    const stack = argv.stack;
    const refreshOnly = argv.refreshOnly;
    await render_ink_1.renderInk(react_1.default.createElement(diff_1.Diff, {
        outDir,
        refreshOnly,
        targetStack: stack,
        synthCommand: command,
    }));
}
exports.diff = diff;
async function get(argv) {
    var _a, _b;
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await error_reporting_1.initializErrorReporting(true);
    await check_environment_1.checkEnvironment();
    await check_environment_1.verifySimilarLibraryVersion();
    const config = provider_generator_1.config.readConfigSync(); // read config again to be up-to-date (if called via 'add' command)
    const providers = (_a = config.terraformProviders) !== null && _a !== void 0 ? _a : [];
    const modules = (_b = config.terraformModules) !== null && _b !== void 0 ? _b : [];
    const { output, language } = argv;
    const constraints = [
        ...providers,
        ...modules,
    ];
    if (constraints.length === 0) {
        logging_1.logger.warn(`WARNING: No providers or modules found in "cdktf.json" config file, therefore cdktf get does nothing.`);
        return;
    }
    await render_ink_1.renderInk(react_1.default.createElement(get_1.Get, {
        codeMakerOutput: output,
        language: language,
        constraints,
    }));
}
exports.get = get;
async function init(argv) {
    await terraform_check_1.terraformCheck();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    if (["", ".", process.cwd()].includes(argv.fromTerraformProject)) {
        throw errors_1.Errors.Usage("--from-terraform-project requires a path to an existing Terraform project to be set, e.g. --from-terraform-project=../my-tf-codebase This folder can not be the same as the current working directory since cdktf init will initialize the new project in that folder.");
    }
    init_1.checkForEmptyDirectory(".");
    await init_1.runInit(argv);
}
exports.init = init;
async function list(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const command = argv.app;
    const outDir = argv.output;
    await render_ink_1.renderInk(react_1.default.createElement(list_1.List, { outDir, synthCommand: command }));
}
exports.list = list;
async function login(argv) {
    await terraform_check_1.terraformCheck();
    await version_check_1.displayVersionMessage();
    async function showUserDetails(authToken) {
        // Get user details if token is set
        const userAccount = await terraformCloudClient.getAccountDetails(argv.tfeHostname, authToken);
        if (userAccount) {
            const username = userAccount.data.attributes.username;
            console.log(chalkColour `\n{greenBright cdktf has successfully configured Terraform Cloud credentials!}`);
            console.log(chalkColour `\nWelcome {bold ${username}}!`);
        }
        else {
            throw errors_1.Errors.Usage(`Configured Terraform Cloud token is invalid.`);
        }
    }
    const terraformLogin = new terraform_login_1.TerraformLogin(argv.tfeHostname);
    let token = "";
    try {
        token = await utilities_1.readStreamAsString(process.stdin, "No stdin was passed");
    }
    catch (e) {
        logging_1.logger.debug(`No TTY stream passed to login`);
    }
    // If we get a token through stdin, we don't need to ask for credentials, we just validate and set it
    // This is useful for programmatically authenticating, e.g. a CI server
    if (token) {
        await terraformLogin.saveTerraformCredentials(token.replace(/\n/g, ""));
    }
    else {
        token = await terraformLogin.askToLogin();
        if (token === "") {
            throw errors_1.Errors.Usage(`No Terraform Cloud token was provided.`);
        }
    }
    await showUserDetails(token);
}
exports.login = login;
async function synth(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const checkCodeMakerOutput = argv.checkCodeMakerOutput;
    const command = argv.app;
    const outDir = argv.output;
    if (checkCodeMakerOutput && !(await fs.pathExists(config.codeMakerOutput))) {
        console.error(`ERROR: synthesis failed, run "cdktf get" to generate providers in ${config.codeMakerOutput}`);
        process.exit(1);
    }
    await render_ink_1.renderInk(react_1.default.createElement(synth_1.Synth, {
        outDir,
        synthCommand: command,
    }));
}
exports.synth = synth;
async function watch(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    const command = argv.app;
    const outDir = argv.output;
    const autoApprove = argv.autoApprove;
    const stacks = argv.stacks;
    if (!autoApprove) {
        console.error(chalkColour `{redBright ERROR: The watch command always automatically deploys and approves changes. To make this behaviour explicit the --auto-approve flag must be set}`);
        process.exit(1);
    }
    await render_ink_1.renderInk(react_1.default.createElement(watch_1.Watch, {
        targetDir: outDir,
        targetStacks: stacks,
        synthCommand: command,
        autoApprove,
    }));
}
exports.watch = watch;
async function output(argv) {
    await error_reporting_1.initializErrorReporting(true);
    check_directory_1.throwIfNotProjectDirectory();
    await version_check_1.displayVersionMessage();
    await check_environment_1.checkEnvironment();
    const command = argv.app;
    const outDir = argv.output;
    const stacks = argv.stacks;
    const includeSensitiveOutputs = argv.outputsFileIncludeSensitiveOutputs;
    let outputsPath = undefined;
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    let onOutputsRetrieved = () => { };
    if (argv.outputsFile) {
        outputsPath = output_2.normalizeOutputPath(argv.outputsFile);
        onOutputsRetrieved = (outputs) => output_2.saveOutputs(outputsPath, outputs, includeSensitiveOutputs);
    }
    await render_ink_1.renderInk(react_1.default.createElement(output_1.Output, {
        outDir,
        targetStacks: stacks,
        synthCommand: command,
        onOutputsRetrieved,
        outputsPath,
    }));
}
exports.output = output;
async function debug(argv) {
    const jsonOutput = argv.json;
    const debugOutput = await debug_1.collectDebugInformation();
    if (jsonOutput) {
        console.log(JSON.stringify(debugOutput, null, 2));
    }
    else {
        console.log(chalkColour `{bold {greenBright cdktf debug}}`);
        Object.entries(debugOutput).forEach(([key, value]) => {
            console.log(`${key}: ${value === null ? "null" : value}`);
        });
    }
}
exports.debug = debug;
async function providerAdd(argv) {
    const config = cdktf_config_1.CdktfConfig.read();
    const language = config.language;
    const cdktfVersion = await debug_1.getPackageVersion(language, "cdktf");
    if (!cdktfVersion)
        throw errors_1.Errors.External("Could not determine cdktf version. Please make sure you are in a directory containing a cdktf project and have all dependencies installed.");
    const manager = new dependency_manager_1.DependencyManager(language, cdktfVersion, config.projectDirectory);
    let needsGet = false;
    for (const provider of argv.provider) {
        const constraint = dependency_manager_1.ProviderConstraint.fromConfigEntry(provider);
        if (argv.forceLocal) {
            needsGet = true;
            await manager.addLocalProvider(constraint);
        }
        else {
            const { addedLocalProvider } = await manager.addProvider(constraint);
            if (addedLocalProvider) {
                needsGet = true;
            }
        }
    }
    if (needsGet) {
        console.log("Local providers have been updated. Running cdktf get to update...");
        await get({ language: language, output: config.codeMakerOutput });
    }
}
exports.providerAdd = providerAdd;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFuZGxlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJoYW5kbGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsa0RBQTBCO0FBQzFCLDZDQUErQjtBQUMvQixrREFBMEI7QUFDMUIsNENBQTJEO0FBQzNELGtFQU1tQztBQUVuQyx3Q0FBZ0U7QUFDaEUsb0RBQWdEO0FBQ2hELDhEQUEwRDtBQUMxRCxzRkFBd0U7QUFDeEUsOERBQTBEO0FBQzFELGtEQUF3RDtBQUN4RCwwREFBK0Q7QUFFL0Qsb0NBQWlDO0FBQ2pDLHdDQUFxQztBQUNyQywwQ0FBdUM7QUFDdkMsa0NBQStCO0FBQy9CLG9DQUFpQztBQUNqQyxzQ0FBbUM7QUFDbkMsc0NBQW1DO0FBRW5DLHFEQUFxRDtBQUNyRCw2Q0FBdUQ7QUFDdkQsd0NBQXFDO0FBQ3JDLDZDQUkwQjtBQUMxQiw4REFBc0U7QUFDdEUsa0VBR29DO0FBQ3BDLDJDQUE2RTtBQUM3RSwrREFBb0U7QUFDcEUsa0ZBR21EO0FBQ25ELHlEQUE2RTtBQUM3RSwrQ0FBMkM7QUFFM0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxlQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDekMsTUFBTSxNQUFNLEdBQUcsMkJBQUcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUVwQyxLQUFLLFVBQVUsdUJBQXVCLENBQUMsUUFBa0I7SUFDdkQsSUFBSSxtQkFBbUIsR0FBd0MsRUFBRSxDQUFDO0lBRWxFLElBQUk7UUFDRixNQUFNLE1BQU0sR0FBRywwQkFBVyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2xDLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQztLQUNqRDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxvQkFBVyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsRUFBRTtZQUM5Qix1REFBdUQ7U0FDeEQ7YUFBTTtZQUNMLE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7S0FD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LE9BQU8sR0FBRyxJQUFJLHNDQUFpQixDQUNuQyxRQUFRLEVBQ1IsWUFBWSxFQUNaLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FDeEIsQ0FBQztJQUVGLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztJQUVyQixLQUFLLE1BQU0sUUFBUSxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDcEMsTUFBTSxVQUFVLEdBQUcsdUNBQWtCLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRWhFLElBQUksSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNuQixRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ2hCLE1BQU0sT0FBTyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQzVDO2FBQU07WUFDTCxNQUFNLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxNQUFNLE9BQU8sQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDckUsSUFBSSxrQkFBa0IsRUFBRTtnQkFDdEIsUUFBUSxHQUFHLElBQUksQ0FBQzthQUNqQjtTQUNGO0tBQ0Y7SUFFRCxJQUFJLFFBQVEsRUFBRTtRQUNaLE9BQU8sQ0FBQyxHQUFHLENBQ1QsbUVBQW1FLENBQ3BFLENBQUM7UUFDRixNQUFNLEdBQUcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDO0tBQ25FO0FBQ0gsQ0FBQztBQXZDRCxrQ0F1Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGNvbnZlcnQgYXMgaGNsMmNka0NvbnZlcnQgfSBmcm9tIFwiQGNka3RmL2hjbDJjZGtcIjtcbmltcG9ydCB7XG4gIHJlYWRTY2hlbWEsXG4gIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0LFxuICBMQU5HVUFHRVMsXG4gIGNvbmZpZyBhcyBjZmcsXG4gIExhbmd1YWdlLFxufSBmcm9tIFwiQGNka3RmL3Byb3ZpZGVyLWdlbmVyYXRvclwiO1xuXG5pbXBvcnQgeyBjaGVja0ZvckVtcHR5RGlyZWN0b3J5LCBydW5Jbml0IH0gZnJvbSBcIi4vaGVscGVyL2luaXRcIjtcbmltcG9ydCB7IHJlbmRlckluayB9IGZyb20gXCIuL2hlbHBlci9yZW5kZXItaW5rXCI7XG5pbXBvcnQgeyB0ZXJyYWZvcm1DaGVjayB9IGZyb20gXCIuL2hlbHBlci90ZXJyYWZvcm0tY2hlY2tcIjtcbmltcG9ydCAqIGFzIHRlcnJhZm9ybUNsb3VkQ2xpZW50IGZyb20gXCIuL2hlbHBlci90ZXJyYWZvcm0tY2xvdWQtY2xpZW50XCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1Mb2dpbiB9IGZyb20gXCIuL2hlbHBlci90ZXJyYWZvcm0tbG9naW5cIjtcbmltcG9ydCB7IHJlYWRTdHJlYW1Bc1N0cmluZyB9IGZyb20gXCIuL2hlbHBlci91dGlsaXRpZXNcIjtcbmltcG9ydCB7IGRpc3BsYXlWZXJzaW9uTWVzc2FnZSB9IGZyb20gXCIuL2hlbHBlci92ZXJzaW9uLWNoZWNrXCI7XG5cbmltcG9ydCB7IERpZmYgfSBmcm9tIFwiLi91aS9kaWZmXCI7XG5pbXBvcnQgeyBEZXBsb3kgfSBmcm9tIFwiLi91aS9kZXBsb3lcIjtcbmltcG9ydCB7IERlc3Ryb3kgfSBmcm9tIFwiLi91aS9kZXN0cm95XCI7XG5pbXBvcnQgeyBHZXQgfSBmcm9tIFwiLi91aS9nZXRcIjtcbmltcG9ydCB7IExpc3QgfSBmcm9tIFwiLi91aS9saXN0XCI7XG5pbXBvcnQgeyBTeW50aCB9IGZyb20gXCIuL3VpL3N5bnRoXCI7XG5pbXBvcnQgeyBXYXRjaCB9IGZyb20gXCIuL3VpL3dhdGNoXCI7XG5cbmltcG9ydCB7IHNlbmRUZWxlbWV0cnkgfSBmcm9tIFwiLi4vLi4vbGliL2NoZWNrcG9pbnRcIjtcbmltcG9ydCB7IEVycm9ycywgSXNFcnJvclR5cGUgfSBmcm9tIFwiLi4vLi4vbGliL2Vycm9yc1wiO1xuaW1wb3J0IHsgT3V0cHV0IH0gZnJvbSBcIi4vdWkvb3V0cHV0XCI7XG5pbXBvcnQge1xuICBOZXN0ZWRUZXJyYWZvcm1PdXRwdXRzLFxuICBzYXZlT3V0cHV0cyxcbiAgbm9ybWFsaXplT3V0cHV0UGF0aCxcbn0gZnJvbSBcIi4uLy4uL2xpYi9vdXRwdXRcIjtcbmltcG9ydCB7IHRocm93SWZOb3RQcm9qZWN0RGlyZWN0b3J5IH0gZnJvbSBcIi4vaGVscGVyL2NoZWNrLWRpcmVjdG9yeVwiO1xuaW1wb3J0IHtcbiAgY2hlY2tFbnZpcm9ubWVudCxcbiAgdmVyaWZ5U2ltaWxhckxpYnJhcnlWZXJzaW9uLFxufSBmcm9tIFwiLi9oZWxwZXIvY2hlY2stZW52aXJvbm1lbnRcIjtcbmltcG9ydCB7IGNvbGxlY3REZWJ1Z0luZm9ybWF0aW9uLCBnZXRQYWNrYWdlVmVyc2lvbiB9IGZyb20gXCIuLi8uLi9saWIvZGVidWdcIjtcbmltcG9ydCB7IGluaXRpYWxpekVycm9yUmVwb3J0aW5nIH0gZnJvbSBcIi4uLy4uL2xpYi9lcnJvci1yZXBvcnRpbmdcIjtcbmltcG9ydCB7XG4gIERlcGVuZGVuY3lNYW5hZ2VyLFxuICBQcm92aWRlckNvbnN0cmFpbnQsXG59IGZyb20gXCIuLi8uLi9saWIvZGVwZW5kZW5jaWVzL2RlcGVuZGVuY3ktbWFuYWdlclwiO1xuaW1wb3J0IHsgQ2RrdGZDb25maWcsIFByb3ZpZGVyRGVwZW5kZW5jeVNwZWMgfSBmcm9tIFwiLi4vLi4vbGliL2Nka3RmLWNvbmZpZ1wiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2xpYi9sb2dnaW5nXCI7XG5cbmNvbnN0IGNoYWxrQ29sb3VyID0gbmV3IGNoYWxrLkluc3RhbmNlKCk7XG5jb25zdCBjb25maWcgPSBjZmcucmVhZENvbmZpZ1N5bmMoKTtcblxuYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXJSZXF1aXJlbWVudHMocHJvdmlkZXI6IHN0cmluZ1tdKSB7XG4gIGxldCBwcm92aWRlcnNGcm9tQ29uZmlnOiAoc3RyaW5nIHwgUHJvdmlkZXJEZXBlbmRlbmN5U3BlYylbXSA9IFtdO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgY29uZmlnID0gQ2RrdGZDb25maWcucmVhZCgpO1xuICAgIHByb3ZpZGVyc0Zyb21Db25maWcgPSBjb25maWcudGVycmFmb3JtUHJvdmlkZXJzO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKElzRXJyb3JUeXBlKGUsIFwiRXh0ZXJuYWxcIikpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcsIGV4cGVjdGVkIGlmIHJ1biBpbiBhIGRpZmZlcmVudCBkaXJlY3RvcnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5wcm92aWRlciwgLi4ucHJvdmlkZXJzRnJvbUNvbmZpZ107XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb252ZXJ0KHsgbGFuZ3VhZ2UsIHByb3ZpZGVyIH06IGFueSkge1xuICBhd2FpdCBpbml0aWFsaXpFcnJvclJlcG9ydGluZygpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcblxuICBjb25zdCBwcm92aWRlclJlcXVpcmVtZW50cyA9IGF3YWl0IGdldFByb3ZpZGVyUmVxdWlyZW1lbnRzKHByb3ZpZGVyKTtcbiAgLy8gR2V0IGFsbCB0aGUgcHJvdmlkZXIgc2NoZW1hc1xuICBjb25zdCB7IHByb3ZpZGVyU2NoZW1hIH0gPSBhd2FpdCByZWFkU2NoZW1hKFxuICAgIHByb3ZpZGVyUmVxdWlyZW1lbnRzLm1hcCgoc3BlYykgPT5cbiAgICAgIENvbnN0cnVjdHNNYWtlclByb3ZpZGVyVGFyZ2V0LmZyb20oXG4gICAgICAgIG5ldyBjZmcuVGVycmFmb3JtUHJvdmlkZXJDb25zdHJhaW50KHNwZWMpLFxuICAgICAgICBMQU5HVUFHRVNbMF1cbiAgICAgIClcbiAgICApXG4gICk7XG5cbiAgY29uc3QgaW5wdXQgPSBhd2FpdCByZWFkU3RyZWFtQXNTdHJpbmcoXG4gICAgcHJvY2Vzcy5zdGRpbixcbiAgICBcIk5vIHN0ZGluIHdhcyBwYXNzZWQsIHBsZWFzZSB1c2UgaXQgbGlrZSB0aGlzOiBjYXQgbWFpbi50ZiB8IGNka3RmIGNvbnZlcnQgPiBpbXBvcnRlZC50c1wiXG4gICk7XG4gIGxldCBvdXRwdXQ7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBhbGwsIHN0YXRzIH0gPSBhd2FpdCBoY2wyY2RrQ29udmVydChpbnB1dCwge1xuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBwcm92aWRlclNjaGVtYSxcbiAgICB9KTtcbiAgICBvdXRwdXQgPSBhbGw7XG4gICAgYXdhaXQgc2VuZFRlbGVtZXRyeShcImNvbnZlcnRcIiwgeyAuLi5zdGF0cywgZXJyb3I6IGZhbHNlIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoKGVyciBhcyBFcnJvcikubWVzc2FnZSwgeyBsYW5ndWFnZSB9KTtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKG91dHB1dCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXBsb3koYXJndjogYW55KSB7XG4gIGF3YWl0IGluaXRpYWxpekVycm9yUmVwb3J0aW5nKHRydWUpO1xuICB0aHJvd0lmTm90UHJvamVjdERpcmVjdG9yeSgpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuICBjb25zdCBhdXRvQXBwcm92ZSA9IGFyZ3YuYXV0b0FwcHJvdmU7XG4gIGNvbnN0IHN0YWNrcyA9IGFyZ3Yuc3RhY2tzO1xuICBjb25zdCBpbmNsdWRlU2Vuc2l0aXZlT3V0cHV0cyA9IGFyZ3Yub3V0cHV0c0ZpbGVJbmNsdWRlU2Vuc2l0aXZlT3V0cHV0cztcbiAgY29uc3QgcmVmcmVzaE9ubHkgPSBhcmd2LnJlZnJlc2hPbmx5O1xuXG4gIGxldCBvdXRwdXRzUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGxldCBvbk91dHB1dHNSZXRyaWV2ZWQ6IChvdXRwdXRzOiBOZXN0ZWRUZXJyYWZvcm1PdXRwdXRzKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgaWYgKGFyZ3Yub3V0cHV0c0ZpbGUpIHtcbiAgICBvdXRwdXRzUGF0aCA9IG5vcm1hbGl6ZU91dHB1dFBhdGgoYXJndi5vdXRwdXRzRmlsZSk7XG4gICAgb25PdXRwdXRzUmV0cmlldmVkID0gKG91dHB1dHM6IE5lc3RlZFRlcnJhZm9ybU91dHB1dHMpID0+XG4gICAgICBzYXZlT3V0cHV0cyhvdXRwdXRzUGF0aCEsIG91dHB1dHMsIGluY2x1ZGVTZW5zaXRpdmVPdXRwdXRzKTtcbiAgfVxuXG4gIGF3YWl0IHJlbmRlckluayhcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERlcGxveSwge1xuICAgICAgb3V0RGlyLFxuICAgICAgdGFyZ2V0U3RhY2tzOiBzdGFja3MsXG4gICAgICBzeW50aENvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICBhdXRvQXBwcm92ZSxcbiAgICAgIG9uT3V0cHV0c1JldHJpZXZlZCxcbiAgICAgIG91dHB1dHNQYXRoLFxuICAgICAgaWdub3JlTWlzc2luZ1N0YWNrRGVwZW5kZW5jaWVzOlxuICAgICAgICBhcmd2Lmlnbm9yZU1pc3NpbmdTdGFja0RlcGVuZGVuY2llcyB8fCBmYWxzZSxcbiAgICAgIHBhcmFsbGVsaXNtOiBhcmd2LnBhcmFsbGVsaXNtLFxuICAgICAgcmVmcmVzaE9ubHksXG4gICAgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlc3Ryb3koYXJndjogYW55KSB7XG4gIGF3YWl0IGluaXRpYWxpekVycm9yUmVwb3J0aW5nKHRydWUpO1xuICB0aHJvd0lmTm90UHJvamVjdERpcmVjdG9yeSgpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuICBjb25zdCBhdXRvQXBwcm92ZSA9IGFyZ3YuYXV0b0FwcHJvdmU7XG4gIGNvbnN0IHN0YWNrcyA9IGFyZ3Yuc3RhY2tzO1xuXG4gIGF3YWl0IHJlbmRlckluayhcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERlc3Ryb3ksIHtcbiAgICAgIG91dERpcixcbiAgICAgIHRhcmdldFN0YWNrczogc3RhY2tzLFxuICAgICAgc3ludGhDb21tYW5kOiBjb21tYW5kLFxuICAgICAgYXV0b0FwcHJvdmUsXG4gICAgICBpZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXM6XG4gICAgICAgIGFyZ3YuaWdub3JlTWlzc2luZ1N0YWNrRGVwZW5kZW5jaWVzIHx8IGZhbHNlLFxuICAgICAgcGFyYWxsZWxpc206IGFyZ3YucGFyYWxsZWxpc20sXG4gICAgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRpZmYoYXJndjogYW55KSB7XG4gIGF3YWl0IGluaXRpYWxpekVycm9yUmVwb3J0aW5nKHRydWUpO1xuICB0aHJvd0lmTm90UHJvamVjdERpcmVjdG9yeSgpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuICBjb25zdCBzdGFjayA9IGFyZ3Yuc3RhY2s7XG4gIGNvbnN0IHJlZnJlc2hPbmx5ID0gYXJndi5yZWZyZXNoT25seTtcblxuICBhd2FpdCByZW5kZXJJbmsoXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWZmLCB7XG4gICAgICBvdXREaXIsXG4gICAgICByZWZyZXNoT25seSxcbiAgICAgIHRhcmdldFN0YWNrOiBzdGFjayxcbiAgICAgIHN5bnRoQ29tbWFuZDogY29tbWFuZCxcbiAgICB9KVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0KGFyZ3Y6IHsgb3V0cHV0OiBzdHJpbmc7IGxhbmd1YWdlOiBMYW5ndWFnZSB9KSB7XG4gIHRocm93SWZOb3RQcm9qZWN0RGlyZWN0b3J5KCk7XG4gIGF3YWl0IGRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpO1xuICBhd2FpdCBpbml0aWFsaXpFcnJvclJlcG9ydGluZyh0cnVlKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBhd2FpdCB2ZXJpZnlTaW1pbGFyTGlicmFyeVZlcnNpb24oKTtcbiAgY29uc3QgY29uZmlnID0gY2ZnLnJlYWRDb25maWdTeW5jKCk7IC8vIHJlYWQgY29uZmlnIGFnYWluIHRvIGJlIHVwLXRvLWRhdGUgKGlmIGNhbGxlZCB2aWEgJ2FkZCcgY29tbWFuZClcbiAgY29uc3QgcHJvdmlkZXJzID0gY29uZmlnLnRlcnJhZm9ybVByb3ZpZGVycyA/PyBbXTtcbiAgY29uc3QgbW9kdWxlcyA9IGNvbmZpZy50ZXJyYWZvcm1Nb2R1bGVzID8/IFtdO1xuICBjb25zdCB7IG91dHB1dCwgbGFuZ3VhZ2UgfSA9IGFyZ3Y7XG5cbiAgY29uc3QgY29uc3RyYWludHM6IGNmZy5UZXJyYWZvcm1EZXBlbmRlbmN5Q29uc3RyYWludFtdID0gW1xuICAgIC4uLnByb3ZpZGVycyxcbiAgICAuLi5tb2R1bGVzLFxuICBdO1xuXG4gIGlmIChjb25zdHJhaW50cy5sZW5ndGggPT09IDApIHtcbiAgICBsb2dnZXIud2FybihcbiAgICAgIGBXQVJOSU5HOiBObyBwcm92aWRlcnMgb3IgbW9kdWxlcyBmb3VuZCBpbiBcImNka3RmLmpzb25cIiBjb25maWcgZmlsZSwgdGhlcmVmb3JlIGNka3RmIGdldCBkb2VzIG5vdGhpbmcuYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXdhaXQgcmVuZGVySW5rKFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoR2V0LCB7XG4gICAgICBjb2RlTWFrZXJPdXRwdXQ6IG91dHB1dCxcbiAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0KGFyZ3Y6IGFueSkge1xuICBhd2FpdCB0ZXJyYWZvcm1DaGVjaygpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuXG4gIGlmIChbXCJcIiwgXCIuXCIsIHByb2Nlc3MuY3dkKCldLmluY2x1ZGVzKGFyZ3YuZnJvbVRlcnJhZm9ybVByb2plY3QpKSB7XG4gICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgXCItLWZyb20tdGVycmFmb3JtLXByb2plY3QgcmVxdWlyZXMgYSBwYXRoIHRvIGFuIGV4aXN0aW5nIFRlcnJhZm9ybSBwcm9qZWN0IHRvIGJlIHNldCwgZS5nLiAtLWZyb20tdGVycmFmb3JtLXByb2plY3Q9Li4vbXktdGYtY29kZWJhc2UgVGhpcyBmb2xkZXIgY2FuIG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSBzaW5jZSBjZGt0ZiBpbml0IHdpbGwgaW5pdGlhbGl6ZSB0aGUgbmV3IHByb2plY3QgaW4gdGhhdCBmb2xkZXIuXCJcbiAgICApO1xuICB9XG5cbiAgY2hlY2tGb3JFbXB0eURpcmVjdG9yeShcIi5cIik7XG5cbiAgYXdhaXQgcnVuSW5pdChhcmd2KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxpc3QoYXJndjogYW55KSB7XG4gIGF3YWl0IGluaXRpYWxpekVycm9yUmVwb3J0aW5nKHRydWUpO1xuICB0aHJvd0lmTm90UHJvamVjdERpcmVjdG9yeSgpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuXG4gIGF3YWl0IHJlbmRlckluayhSZWFjdC5jcmVhdGVFbGVtZW50KExpc3QsIHsgb3V0RGlyLCBzeW50aENvbW1hbmQ6IGNvbW1hbmQgfSkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9naW4oYXJndjogeyB0ZmVIb3N0bmFtZTogc3RyaW5nIH0pIHtcbiAgYXdhaXQgdGVycmFmb3JtQ2hlY2soKTtcbiAgYXdhaXQgZGlzcGxheVZlcnNpb25NZXNzYWdlKCk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2hvd1VzZXJEZXRhaWxzKGF1dGhUb2tlbjogc3RyaW5nKSB7XG4gICAgLy8gR2V0IHVzZXIgZGV0YWlscyBpZiB0b2tlbiBpcyBzZXRcbiAgICBjb25zdCB1c2VyQWNjb3VudCA9IGF3YWl0IHRlcnJhZm9ybUNsb3VkQ2xpZW50LmdldEFjY291bnREZXRhaWxzKFxuICAgICAgYXJndi50ZmVIb3N0bmFtZSxcbiAgICAgIGF1dGhUb2tlblxuICAgICk7XG4gICAgaWYgKHVzZXJBY2NvdW50KSB7XG4gICAgICBjb25zdCB1c2VybmFtZSA9IHVzZXJBY2NvdW50LmRhdGEuYXR0cmlidXRlcy51c2VybmFtZTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBjaGFsa0NvbG91cmBcXG57Z3JlZW5CcmlnaHQgY2RrdGYgaGFzIHN1Y2Nlc3NmdWxseSBjb25maWd1cmVkIFRlcnJhZm9ybSBDbG91ZCBjcmVkZW50aWFscyF9YFxuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKGNoYWxrQ29sb3VyYFxcbldlbGNvbWUge2JvbGQgJHt1c2VybmFtZX19IWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoYENvbmZpZ3VyZWQgVGVycmFmb3JtIENsb3VkIHRva2VuIGlzIGludmFsaWQuYCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGVycmFmb3JtTG9naW4gPSBuZXcgVGVycmFmb3JtTG9naW4oYXJndi50ZmVIb3N0bmFtZSk7XG4gIGxldCB0b2tlbiA9IFwiXCI7XG4gIHRyeSB7XG4gICAgdG9rZW4gPSBhd2FpdCByZWFkU3RyZWFtQXNTdHJpbmcocHJvY2Vzcy5zdGRpbiwgXCJObyBzdGRpbiB3YXMgcGFzc2VkXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBObyBUVFkgc3RyZWFtIHBhc3NlZCB0byBsb2dpbmApO1xuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGEgdG9rZW4gdGhyb3VnaCBzdGRpbiwgd2UgZG9uJ3QgbmVlZCB0byBhc2sgZm9yIGNyZWRlbnRpYWxzLCB3ZSBqdXN0IHZhbGlkYXRlIGFuZCBzZXQgaXRcbiAgLy8gVGhpcyBpcyB1c2VmdWwgZm9yIHByb2dyYW1tYXRpY2FsbHkgYXV0aGVudGljYXRpbmcsIGUuZy4gYSBDSSBzZXJ2ZXJcbiAgaWYgKHRva2VuKSB7XG4gICAgYXdhaXQgdGVycmFmb3JtTG9naW4uc2F2ZVRlcnJhZm9ybUNyZWRlbnRpYWxzKHRva2VuLnJlcGxhY2UoL1xcbi9nLCBcIlwiKSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBhd2FpdCB0ZXJyYWZvcm1Mb2dpbi5hc2tUb0xvZ2luKCk7XG4gICAgaWYgKHRva2VuID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoYE5vIFRlcnJhZm9ybSBDbG91ZCB0b2tlbiB3YXMgcHJvdmlkZWQuYCk7XG4gICAgfVxuICB9XG5cbiAgYXdhaXQgc2hvd1VzZXJEZXRhaWxzKHRva2VuKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN5bnRoKGFyZ3Y6IGFueSkge1xuICBhd2FpdCBpbml0aWFsaXpFcnJvclJlcG9ydGluZyh0cnVlKTtcbiAgdGhyb3dJZk5vdFByb2plY3REaXJlY3RvcnkoKTtcbiAgYXdhaXQgZGlzcGxheVZlcnNpb25NZXNzYWdlKCk7XG4gIGF3YWl0IGNoZWNrRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgY2hlY2tDb2RlTWFrZXJPdXRwdXQgPSBhcmd2LmNoZWNrQ29kZU1ha2VyT3V0cHV0O1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuXG4gIGlmIChjaGVja0NvZGVNYWtlck91dHB1dCAmJiAhKGF3YWl0IGZzLnBhdGhFeGlzdHMoY29uZmlnLmNvZGVNYWtlck91dHB1dCkpKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIGBFUlJPUjogc3ludGhlc2lzIGZhaWxlZCwgcnVuIFwiY2RrdGYgZ2V0XCIgdG8gZ2VuZXJhdGUgcHJvdmlkZXJzIGluICR7Y29uZmlnLmNvZGVNYWtlck91dHB1dH1gXG4gICAgKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBhd2FpdCByZW5kZXJJbmsoXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChTeW50aCwge1xuICAgICAgb3V0RGlyLFxuICAgICAgc3ludGhDb21tYW5kOiBjb21tYW5kLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YXRjaChhcmd2OiBhbnkpIHtcbiAgYXdhaXQgaW5pdGlhbGl6RXJyb3JSZXBvcnRpbmcodHJ1ZSk7XG4gIHRocm93SWZOb3RQcm9qZWN0RGlyZWN0b3J5KCk7XG4gIGF3YWl0IGRpc3BsYXlWZXJzaW9uTWVzc2FnZSgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuICBjb25zdCBhdXRvQXBwcm92ZSA9IGFyZ3YuYXV0b0FwcHJvdmU7XG4gIGNvbnN0IHN0YWNrcyA9IGFyZ3Yuc3RhY2tzO1xuXG4gIGlmICghYXV0b0FwcHJvdmUpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY2hhbGtDb2xvdXJge3JlZEJyaWdodCBFUlJPUjogVGhlIHdhdGNoIGNvbW1hbmQgYWx3YXlzIGF1dG9tYXRpY2FsbHkgZGVwbG95cyBhbmQgYXBwcm92ZXMgY2hhbmdlcy4gVG8gbWFrZSB0aGlzIGJlaGF2aW91ciBleHBsaWNpdCB0aGUgLS1hdXRvLWFwcHJvdmUgZmxhZyBtdXN0IGJlIHNldH1gXG4gICAgKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBhd2FpdCByZW5kZXJJbmsoXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChXYXRjaCwge1xuICAgICAgdGFyZ2V0RGlyOiBvdXREaXIsXG4gICAgICB0YXJnZXRTdGFja3M6IHN0YWNrcyxcbiAgICAgIHN5bnRoQ29tbWFuZDogY29tbWFuZCxcbiAgICAgIGF1dG9BcHByb3ZlLFxuICAgIH0pXG4gICk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBvdXRwdXQoYXJndjogYW55KSB7XG4gIGF3YWl0IGluaXRpYWxpekVycm9yUmVwb3J0aW5nKHRydWUpO1xuICB0aHJvd0lmTm90UHJvamVjdERpcmVjdG9yeSgpO1xuICBhd2FpdCBkaXNwbGF5VmVyc2lvbk1lc3NhZ2UoKTtcbiAgYXdhaXQgY2hlY2tFbnZpcm9ubWVudCgpO1xuICBjb25zdCBjb21tYW5kID0gYXJndi5hcHA7XG4gIGNvbnN0IG91dERpciA9IGFyZ3Yub3V0cHV0O1xuICBjb25zdCBzdGFja3MgPSBhcmd2LnN0YWNrcztcbiAgY29uc3QgaW5jbHVkZVNlbnNpdGl2ZU91dHB1dHMgPSBhcmd2Lm91dHB1dHNGaWxlSW5jbHVkZVNlbnNpdGl2ZU91dHB1dHM7XG4gIGxldCBvdXRwdXRzUGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG4gIGxldCBvbk91dHB1dHNSZXRyaWV2ZWQ6IChvdXRwdXRzOiBOZXN0ZWRUZXJyYWZvcm1PdXRwdXRzKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgaWYgKGFyZ3Yub3V0cHV0c0ZpbGUpIHtcbiAgICBvdXRwdXRzUGF0aCA9IG5vcm1hbGl6ZU91dHB1dFBhdGgoYXJndi5vdXRwdXRzRmlsZSk7XG4gICAgb25PdXRwdXRzUmV0cmlldmVkID0gKG91dHB1dHM6IE5lc3RlZFRlcnJhZm9ybU91dHB1dHMpID0+XG4gICAgICBzYXZlT3V0cHV0cyhvdXRwdXRzUGF0aCEsIG91dHB1dHMsIGluY2x1ZGVTZW5zaXRpdmVPdXRwdXRzKTtcbiAgfVxuXG4gIGF3YWl0IHJlbmRlckluayhcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE91dHB1dCwge1xuICAgICAgb3V0RGlyLFxuICAgICAgdGFyZ2V0U3RhY2tzOiBzdGFja3MsXG4gICAgICBzeW50aENvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICBvbk91dHB1dHNSZXRyaWV2ZWQsXG4gICAgICBvdXRwdXRzUGF0aCxcbiAgICB9KVxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVidWcoYXJndjogYW55KSB7XG4gIGNvbnN0IGpzb25PdXRwdXQgPSBhcmd2Lmpzb247XG4gIGNvbnN0IGRlYnVnT3V0cHV0ID0gYXdhaXQgY29sbGVjdERlYnVnSW5mb3JtYXRpb24oKTtcblxuICBpZiAoanNvbk91dHB1dCkge1xuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGRlYnVnT3V0cHV0LCBudWxsLCAyKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coY2hhbGtDb2xvdXJge2JvbGQge2dyZWVuQnJpZ2h0IGNka3RmIGRlYnVnfX1gKTtcblxuICAgIE9iamVjdC5lbnRyaWVzKGRlYnVnT3V0cHV0KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGAke2tleX06ICR7dmFsdWUgPT09IG51bGwgPyBcIm51bGxcIiA6IHZhbHVlfWApO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm92aWRlckFkZChhcmd2OiBhbnkpIHtcbiAgY29uc3QgY29uZmlnID0gQ2RrdGZDb25maWcucmVhZCgpO1xuXG4gIGNvbnN0IGxhbmd1YWdlID0gY29uZmlnLmxhbmd1YWdlO1xuICBjb25zdCBjZGt0ZlZlcnNpb24gPSBhd2FpdCBnZXRQYWNrYWdlVmVyc2lvbihsYW5ndWFnZSwgXCJjZGt0ZlwiKTtcblxuICBpZiAoIWNka3RmVmVyc2lvbilcbiAgICB0aHJvdyBFcnJvcnMuRXh0ZXJuYWwoXG4gICAgICBcIkNvdWxkIG5vdCBkZXRlcm1pbmUgY2RrdGYgdmVyc2lvbi4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UgYXJlIGluIGEgZGlyZWN0b3J5IGNvbnRhaW5pbmcgYSBjZGt0ZiBwcm9qZWN0IGFuZCBoYXZlIGFsbCBkZXBlbmRlbmNpZXMgaW5zdGFsbGVkLlwiXG4gICAgKTtcblxuICBjb25zdCBtYW5hZ2VyID0gbmV3IERlcGVuZGVuY3lNYW5hZ2VyKFxuICAgIGxhbmd1YWdlLFxuICAgIGNka3RmVmVyc2lvbixcbiAgICBjb25maWcucHJvamVjdERpcmVjdG9yeVxuICApO1xuXG4gIGxldCBuZWVkc0dldCA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgcHJvdmlkZXIgb2YgYXJndi5wcm92aWRlcikge1xuICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBQcm92aWRlckNvbnN0cmFpbnQuZnJvbUNvbmZpZ0VudHJ5KHByb3ZpZGVyKTtcblxuICAgIGlmIChhcmd2LmZvcmNlTG9jYWwpIHtcbiAgICAgIG5lZWRzR2V0ID0gdHJ1ZTtcbiAgICAgIGF3YWl0IG1hbmFnZXIuYWRkTG9jYWxQcm92aWRlcihjb25zdHJhaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBhZGRlZExvY2FsUHJvdmlkZXIgfSA9IGF3YWl0IG1hbmFnZXIuYWRkUHJvdmlkZXIoY29uc3RyYWludCk7XG4gICAgICBpZiAoYWRkZWRMb2NhbFByb3ZpZGVyKSB7XG4gICAgICAgIG5lZWRzR2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmVlZHNHZXQpIHtcbiAgICBjb25zb2xlLmxvZyhcbiAgICAgIFwiTG9jYWwgcHJvdmlkZXJzIGhhdmUgYmVlbiB1cGRhdGVkLiBSdW5uaW5nIGNka3RmIGdldCB0byB1cGRhdGUuLi5cIlxuICAgICk7XG4gICAgYXdhaXQgZ2V0KHsgbGFuZ3VhZ2U6IGxhbmd1YWdlLCBvdXRwdXQ6IGNvbmZpZy5jb2RlTWFrZXJPdXRwdXQgfSk7XG4gIH1cbn1cbiJdfQ==