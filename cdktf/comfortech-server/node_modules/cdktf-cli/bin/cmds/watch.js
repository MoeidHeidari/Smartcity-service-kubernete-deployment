"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const provider_generator_1 = require("@cdktf/provider-generator");
const utilities_1 = require("./helper/utilities");
const errors_1 = require("../../lib/errors");
const base_command_1 = require("./helper/base-command");
const config = provider_generator_1.config.readConfigSync();
class Command extends base_command_1.BaseCommand {
    constructor() {
        super(...arguments);
        this.command = "watch [stacks..]";
        this.describe = "[experimental] Watch for file changes and automatically trigger a deploy";
        this.builder = (args) => args
            .positional("stacks", {
            desc: "Deploy stacks matching the given ids. Required when more than one stack is present in the app",
            type: "string",
        })
            .option("app", {
            default: config.app,
            required: true,
            desc: "Command to use in order to execute cdktf app",
            alias: "a",
        })
            .option("output", {
            default: config.output,
            required: true,
            desc: "Output directory for the synthesized Terraform config",
            alias: "o",
        })
            .option("auto-approve", {
            type: "boolean",
            default: false,
            required: false,
            desc: "Auto approve",
        })
            .option("parallelism", {
            type: "number",
            required: false,
            desc: "Number of concurrent CDKTF stacks to run. Defaults to infinity, denoted by -1",
            default: -1,
        })
            .showHelpOnFail(true);
    }
    async handleCommand(argv) {
        errors_1.Errors.setScope("watch");
        // deferred require to keep cdktf-cli main entrypoint small (e.g. for fast shell completions)
        const api = utilities_1.requireHandlers();
        await api.watch(argv);
    }
}
module.exports = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2F0Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3YXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLGtFQUEwRDtBQUMxRCxrREFBcUQ7QUFDckQsNkNBQTBDO0FBQzFDLHdEQUFvRDtBQUVwRCxNQUFNLE1BQU0sR0FBRywyQkFBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBRXBDLE1BQU0sT0FBUSxTQUFRLDBCQUFXO0lBQWpDOztRQUNrQixZQUFPLEdBQUcsa0JBQWtCLENBQUM7UUFDN0IsYUFBUSxHQUN0QiwwRUFBMEUsQ0FBQztRQUU3RCxZQUFPLEdBQUcsQ0FBQyxJQUFnQixFQUFFLEVBQUUsQ0FDN0MsSUFBSTthQUNELFVBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDcEIsSUFBSSxFQUFFLCtGQUErRjtZQUNyRyxJQUFJLEVBQUUsUUFBUTtTQUNmLENBQUM7YUFDRCxNQUFNLENBQUMsS0FBSyxFQUFFO1lBQ2IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxHQUFHO1lBQ25CLFFBQVEsRUFBRSxJQUFJO1lBQ2QsSUFBSSxFQUFFLDhDQUE4QztZQUNwRCxLQUFLLEVBQUUsR0FBRztTQUNYLENBQUM7YUFDRCxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ2hCLE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTTtZQUN0QixRQUFRLEVBQUUsSUFBSTtZQUNkLElBQUksRUFBRSx1REFBdUQ7WUFDN0QsS0FBSyxFQUFFLEdBQUc7U0FDWCxDQUFDO2FBQ0QsTUFBTSxDQUFDLGNBQWMsRUFBRTtZQUN0QixJQUFJLEVBQUUsU0FBUztZQUNmLE9BQU8sRUFBRSxLQUFLO1lBQ2QsUUFBUSxFQUFFLEtBQUs7WUFDZixJQUFJLEVBQUUsY0FBYztTQUNyQixDQUFDO2FBQ0QsTUFBTSxDQUFDLGFBQWEsRUFBRTtZQUNyQixJQUFJLEVBQUUsUUFBUTtZQUNkLFFBQVEsRUFBRSxLQUFLO1lBQ2YsSUFBSSxFQUFFLCtFQUErRTtZQUNyRixPQUFPLEVBQUUsQ0FBQyxDQUFDO1NBQ1osQ0FBQzthQUNELGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQVE1QixDQUFDO0lBTlEsS0FBSyxDQUFDLGFBQWEsQ0FBQyxJQUFTO1FBQ2xDLGVBQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekIsNkZBQTZGO1FBQzdGLE1BQU0sR0FBRyxHQUFHLDJCQUFlLEVBQUUsQ0FBQztRQUM5QixNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsQ0FBQztDQUNGO0FBRUQsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgeWFyZ3MgZnJvbSBcInlhcmdzXCI7XG5pbXBvcnQgeyBjb25maWcgYXMgY2ZnIH0gZnJvbSBcIkBjZGt0Zi9wcm92aWRlci1nZW5lcmF0b3JcIjtcbmltcG9ydCB7IHJlcXVpcmVIYW5kbGVycyB9IGZyb20gXCIuL2hlbHBlci91dGlsaXRpZXNcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCIuLi8uLi9saWIvZXJyb3JzXCI7XG5pbXBvcnQgeyBCYXNlQ29tbWFuZCB9IGZyb20gXCIuL2hlbHBlci9iYXNlLWNvbW1hbmRcIjtcblxuY29uc3QgY29uZmlnID0gY2ZnLnJlYWRDb25maWdTeW5jKCk7XG5cbmNsYXNzIENvbW1hbmQgZXh0ZW5kcyBCYXNlQ29tbWFuZCB7XG4gIHB1YmxpYyByZWFkb25seSBjb21tYW5kID0gXCJ3YXRjaCBbc3RhY2tzLi5dXCI7XG4gIHB1YmxpYyByZWFkb25seSBkZXNjcmliZSA9XG4gICAgXCJbZXhwZXJpbWVudGFsXSBXYXRjaCBmb3IgZmlsZSBjaGFuZ2VzIGFuZCBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgYSBkZXBsb3lcIjtcblxuICBwdWJsaWMgcmVhZG9ubHkgYnVpbGRlciA9IChhcmdzOiB5YXJncy5Bcmd2KSA9PlxuICAgIGFyZ3NcbiAgICAgIC5wb3NpdGlvbmFsKFwic3RhY2tzXCIsIHtcbiAgICAgICAgZGVzYzogXCJEZXBsb3kgc3RhY2tzIG1hdGNoaW5nIHRoZSBnaXZlbiBpZHMuIFJlcXVpcmVkIHdoZW4gbW9yZSB0aGFuIG9uZSBzdGFjayBpcyBwcmVzZW50IGluIHRoZSBhcHBcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIH0pXG4gICAgICAub3B0aW9uKFwiYXBwXCIsIHtcbiAgICAgICAgZGVmYXVsdDogY29uZmlnLmFwcCxcbiAgICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgICAgIGRlc2M6IFwiQ29tbWFuZCB0byB1c2UgaW4gb3JkZXIgdG8gZXhlY3V0ZSBjZGt0ZiBhcHBcIixcbiAgICAgICAgYWxpYXM6IFwiYVwiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJvdXRwdXRcIiwge1xuICAgICAgICBkZWZhdWx0OiBjb25maWcub3V0cHV0LFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgICAgZGVzYzogXCJPdXRwdXQgZGlyZWN0b3J5IGZvciB0aGUgc3ludGhlc2l6ZWQgVGVycmFmb3JtIGNvbmZpZ1wiLFxuICAgICAgICBhbGlhczogXCJvXCIsXG4gICAgICB9KVxuICAgICAgLm9wdGlvbihcImF1dG8tYXBwcm92ZVwiLCB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICBkZXNjOiBcIkF1dG8gYXBwcm92ZVwiLFxuICAgICAgfSlcbiAgICAgIC5vcHRpb24oXCJwYXJhbGxlbGlzbVwiLCB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgZGVzYzogXCJOdW1iZXIgb2YgY29uY3VycmVudCBDREtURiBzdGFja3MgdG8gcnVuLiBEZWZhdWx0cyB0byBpbmZpbml0eSwgZGVub3RlZCBieSAtMVwiLFxuICAgICAgICBkZWZhdWx0OiAtMSxcbiAgICAgIH0pXG4gICAgICAuc2hvd0hlbHBPbkZhaWwodHJ1ZSk7XG5cbiAgcHVibGljIGFzeW5jIGhhbmRsZUNvbW1hbmQoYXJndjogYW55KSB7XG4gICAgRXJyb3JzLnNldFNjb3BlKFwid2F0Y2hcIik7XG4gICAgLy8gZGVmZXJyZWQgcmVxdWlyZSB0byBrZWVwIGNka3RmLWNsaSBtYWluIGVudHJ5cG9pbnQgc21hbGwgKGUuZy4gZm9yIGZhc3Qgc2hlbGwgY29tcGxldGlvbnMpXG4gICAgY29uc3QgYXBpID0gcmVxdWlyZUhhbmRsZXJzKCk7XG4gICAgYXdhaXQgYXBpLndhdGNoKGFyZ3YpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENvbW1hbmQoKTtcbiJdfQ==