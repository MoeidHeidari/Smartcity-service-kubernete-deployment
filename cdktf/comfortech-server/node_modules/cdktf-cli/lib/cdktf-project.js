"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdktfProject = exports.getStackWithNoUnmetDependencies = exports.getMultipleStacks = void 0;
const node_abort_controller_1 = require("node-abort-controller"); // polyfill until we update to node 16
const synth_stack_1 = require("./synth-stack");
const synth_1 = require("./synth");
const cdktf_stack_1 = require("./cdktf-stack");
const errors_1 = require("./errors");
const logging_1 = require("./logging");
const minimatch_1 = __importDefault(require("minimatch"));
const execution_logs_1 = require("./execution-logs");
function getSingleStack(stacks, stackName, targetAction) {
    if (!stacks) {
        throw errors_1.Errors.Internal("Trying to access a stack before it has been synthesized");
    }
    if (stackName) {
        const stack = stacks.find((s) => s.name === stackName);
        if (!stack) {
            throw errors_1.Errors.Usage("Could not find stack: " + stackName);
        }
        return stack;
    }
    if (stacks.length === 1) {
        return stacks[0];
    }
    throw errors_1.Errors.Usage(`Found more than one stack, please specify a target stack. Run cdktf ${targetAction || "<verb>"} <stack> with one of these stacks: ${stacks
        .map((s) => s.name)
        .join(", ")} `);
}
function getMultipleStacks(stacks, patterns, targetAction) {
    if (!patterns || !patterns.length) {
        if (stacks.length === 1) {
            return [stacks[0]];
        }
        throw errors_1.Errors.Usage(`Found more than one stack, please specify a target stack. Run cdktf ${targetAction || "<verb>"} <stack> with one of these stacks: ${stacks
            .map((s) => s.name)
            .join(", ")} `);
    }
    return patterns.flatMap((pattern) => {
        const matchingStacks = stacks.filter((stack) => minimatch_1.default(stack.name, pattern));
        if (matchingStacks.length === 0) {
            throw errors_1.Errors.Usage(`Could not find stack for pattern '${pattern}'`);
        }
        return matchingStacks;
    });
}
exports.getMultipleStacks = getMultipleStacks;
// Returns the first stack that has no unmet dependencies
// An unmet dependency is a dependency that has not been deployed yet
// If there is no unfinished stack, returns undefined
// If there is no stack ready to be worked on, it returns a promise that will resolve as soon as there is a follow-up stack available
async function getStackWithNoUnmetDependencies(stackExecutors) {
    logging_1.logger.debug("Checking for stacks with unmet dependencies");
    logging_1.logger.debug("stack executors:", stackExecutors);
    const pendingStacks = stackExecutors.filter((executor) => executor.isPending);
    logging_1.logger.debug("pending stacks:", stackExecutors);
    if (pendingStacks.length === 0) {
        return undefined;
    }
    const currentlyReadyStack = pendingStacks.find((executor) => executor.stack.dependencies.every((dependency) => {
        var _a;
        return ((_a = stackExecutors.find((executor) => executor.stack.name === dependency)) === null || _a === void 0 ? void 0 : _a.currentState) === "done";
    }));
    if (currentlyReadyStack) {
        logging_1.logger.debug("Found a stack with no unmet dependencies");
        return currentlyReadyStack;
    }
    const stackExecutionPromises = stackExecutors
        .filter((ex) => ex.currentWorkPromise)
        .map((ex) => ex.currentWorkPromise);
    logging_1.logger.debug(`${stackExecutionPromises.length} stacks are currently busy, waiting for one to finish`);
    if (!stackExecutionPromises.length) {
        return undefined;
    }
    await Promise.race(stackExecutionPromises);
    return await getStackWithNoUnmetDependencies(stackExecutors);
}
exports.getStackWithNoUnmetDependencies = getStackWithNoUnmetDependencies;
function findAllDependantStacks(stackExecutors, stackName) {
    return stackExecutors.filter((innerExecutor) => innerExecutor.stack.dependencies.includes(stackName));
}
function findAllNestedDependantStacks(stackExecutors, stackName, knownDependantStackNames = new Set()) {
    const dependantStacks = findAllDependantStacks(stackExecutors, stackName);
    dependantStacks.forEach((stack) => {
        if (knownDependantStackNames.has(stack.stack.name)) {
            return;
        }
        knownDependantStackNames.add(stack.stack.name);
        findAllNestedDependantStacks(stackExecutors, stack.stack.name, knownDependantStackNames);
    });
    return stackExecutors.filter((executor) => knownDependantStackNames.has(executor.stack.name));
}
// Returns the first stack that has no dependents that need to be destroyed first
async function getStackWithNoUnmetDependants(stackExecutors) {
    logging_1.logger.debug("Checking for stacks with unmet dependants");
    logging_1.logger.debug("stack executors:", stackExecutors);
    const pendingStacks = stackExecutors.filter((executor) => executor.isPending);
    logging_1.logger.debug("pending stacks:", stackExecutors);
    if (pendingStacks.length === 0) {
        return undefined;
    }
    const currentlyReadyStack = pendingStacks.find((executor) => {
        const dependantStacks = findAllDependantStacks(stackExecutors, executor.stack.name);
        return dependantStacks.every((stack) => stack.currentState === "done");
    });
    if (currentlyReadyStack) {
        logging_1.logger.debug("Found a stack with no unmet dependants");
        return currentlyReadyStack;
    }
    const stackExecutionPromises = stackExecutors
        .filter((ex) => ex.currentWorkPromise)
        .map((ex) => ex.currentWorkPromise);
    logging_1.logger.debug(`${stackExecutionPromises.length} stacks are currently busy, waiting for one to finish`);
    if (!stackExecutionPromises.length) {
        return undefined;
    }
    await Promise.race(stackExecutionPromises);
    return await getStackWithNoUnmetDependants(stackExecutors);
}
// Throws an error if there is a dependant stack that is not included
function checkIfAllDependantsAreIncluded(stacksToRun, allStacks) {
    const allDependants = new Set();
    stacksToRun
        .map((stack) => allStacks.filter((s) => s.dependencies.includes(stack.name)))
        .flat()
        .forEach((dependant) => allDependants.add(dependant.name));
    const stackNames = stacksToRun.map((stack) => stack.name);
    const missingDependants = [...allDependants].filter((dependant) => !stackNames.includes(dependant));
    if (missingDependants.length > 0) {
        throw errors_1.Errors.Usage(`The following dependant stacks are not included in the stacks to run: ${missingDependants.join(", ")}. Either add them or add the --ignore-missing-stack-dependencies flag.`);
    }
}
// Throws an error if there is a dependency that is not included
// Cycles are detected on dependency creation at synthesis time
// Running this prevents us from being in a situation where we have to wait for a stack to be deployed
// that is not included to be run
function checkIfAllDependenciesAreIncluded(stacksToRun) {
    const allDependencies = new Set();
    stacksToRun
        .map((stack) => stack.dependencies)
        .flat()
        .forEach((dependency) => allDependencies.add(dependency));
    const stackNames = stacksToRun.map((stack) => stack.name);
    const missingDependencies = [...allDependencies].filter((dependency) => !stackNames.includes(dependency));
    if (missingDependencies.length > 0) {
        throw errors_1.Errors.Usage(`The following dependencies are not included in the stacks to run: ${missingDependencies.join(", ")}. Either add them or add the --ignore-missing-stack-dependencies flag.`);
    }
}
class CdktfProject {
    constructor({ synthCommand, outDir, onUpdate, onLog, workingDirectory = process.cwd(), }) {
        // Set during deploy / destroy
        this.stacksToRun = [];
        // This means sth different in deploy / destroy
        this.stopAllStacksThatCanNotRunWithout = () => { }; // eslint-disable-line @typescript-eslint/no-empty-function
        // Pauses all progress / status events from being forwarded to the user
        // If set from true to false, the events will be sent through the channels they came in
        // (until a waiting for approval event is sent)
        this.waitingForApproval = false;
        this.eventBuffer = [];
        this.synthCommand = synthCommand;
        this.outDir = outDir;
        this.workingDirectory = workingDirectory;
        this.onUpdate = onUpdate;
        this.onLog = onLog;
        const ac = new node_abort_controller_1.AbortController();
        this.abortSignal = ac.signal;
        this.hardAbort = ac.abort.bind(ac);
    }
    stopAllStacks() {
        this.stacksToRun.forEach((stack) => stack.stop());
        this.eventBuffer = this.eventBuffer.filter((event) => event.type === "projectUpdate"
            ? event.value.type !== "waiting for approval" // we want to filter out the waiting for approval events
            : true // we want all other types
        );
    }
    waitForApproval() {
        this.waitingForApproval = true;
    }
    resumeAfterApproval() {
        // We first need to flush all events, we can not resume if there is a new waiting for approval update
        let event = this.eventBuffer.shift();
        while (event) {
            if (event.type === "projectUpdate") {
                event.cb(event.value);
                if (event.value.type === "waiting for approval") {
                    // We have to wait for approval again, therefore we can not resume
                    return;
                }
            }
            if (event.type === "logMessage") {
                event.cb(event.value);
            }
            event = this.eventBuffer.shift();
        }
        // If we reach this point there was no waiting for approval event, so we can safely resume
        this.waitingForApproval = false;
    }
    handleApprovalProcess(cb) {
        return (update) => {
            const bufferCb = (bufferedUpdate) => {
                this.eventBuffer.push({
                    cb,
                    value: bufferedUpdate,
                    type: "projectUpdate",
                });
            };
            const bufferableCb = this.waitingForApproval ? bufferCb : cb;
            if (update.type === "waiting for stack approval") {
                const callbacks = (update) => ({
                    approve: () => {
                        update.approve();
                        this.resumeAfterApproval();
                    },
                    dismiss: () => {
                        update.reject();
                        this.stopAllStacksThatCanNotRunWithout(update.stackName);
                        this.resumeAfterApproval();
                    },
                    stop: () => {
                        update.reject();
                        this.stopAllStacks();
                        this.resumeAfterApproval();
                    },
                });
                this.waitForApproval();
                bufferableCb({
                    type: "waiting for approval",
                    stackName: update.stackName,
                    plan: update.plan,
                    ...callbacks(update),
                });
            }
            else {
                bufferableCb(update);
            }
        };
    }
    bufferWhileWaitingForApproval(cb) {
        if (!cb) {
            return undefined;
        }
        return (msg) => {
            if (this.waitingForApproval) {
                this.eventBuffer.push({
                    cb,
                    value: msg,
                    type: "logMessage",
                });
            }
            else {
                cb(msg);
            }
        };
    }
    getStackExecutor(stack, opts = {}) {
        const enhanceLogMessage = execution_logs_1.createEnhanceLogMessage(stack);
        const onLog = this.bufferWhileWaitingForApproval(this.onLog);
        return new cdktf_stack_1.CdktfStack({
            ...opts,
            stack,
            onUpdate: this.handleApprovalProcess(this.onUpdate),
            onLog: onLog
                ? ({ message }) => onLog({
                    stackName: stack.name,
                    message,
                    messageWithConstructPath: enhanceLogMessage(message),
                })
                : undefined,
            abortSignal: this.abortSignal,
        });
    }
    get outputsByConstructId() {
        return this.stacksToRun.reduce((acc, stack) => ({
            ...acc,
            ...stack.outputsByConstructId,
        }), {});
    }
    async synth() {
        this.onUpdate({
            type: "synthesizing",
        });
        const stacks = await synth_stack_1.SynthStack.synth(this.abortSignal, this.synthCommand, this.outDir, this.workingDirectory);
        synth_1.printAnnotations(stacks);
        this.onUpdate({
            type: "synthesized",
            stacks,
        });
        return stacks;
    }
    async diff(opts) {
        const stacks = await this.synth();
        const stack = this.getStackExecutor(getSingleStack(stacks, opts === null || opts === void 0 ? void 0 : opts.stackName, "diff"));
        await stack.diff({ refreshOnly: opts === null || opts === void 0 ? void 0 : opts.refreshOnly });
        if (!stack.currentPlan)
            throw errors_1.Errors.External(`Stack failed to plan: ${stack.stack.name}. Please check the logs for more information.`);
        return stack.currentPlan;
    }
    async execute(method, next, parallelism, refreshOnly) {
        // We only support refresh only on deploy, a bit of a leaky abstraction here
        if (refreshOnly && method !== "deploy") {
            throw errors_1.Errors.Internal(`Refresh only is only supported on deploy`);
        }
        const maxParallelRuns = parallelism === -1 ? Infinity : parallelism;
        while (this.stacksToRun.filter((stack) => stack.isPending).length > 0) {
            const runningStacks = this.stacksToRun.filter((stack) => stack.isRunning);
            if (runningStacks.length >= maxParallelRuns) {
                await Promise.race(runningStacks.map((s) => s.currentWorkPromise));
            }
            else {
                const nextRunningExecutor = await next();
                if (!nextRunningExecutor) {
                    // In this case we have no pending stacks, but we also can not find a new executor
                    break;
                }
                method === "deploy"
                    ? nextRunningExecutor.deploy(refreshOnly)
                    : nextRunningExecutor.destroy();
            }
        }
        // We end the loop when all stacks are started, now we need to wait for them to be done
        await Promise.all(this.stacksToRun
            .filter((ex) => ex.currentWorkPromise)
            .map((ex) => ex.currentWorkPromise));
    }
    async deploy(opts = {}) {
        const parallelism = opts.parallelism || -1;
        const stacks = await this.synth();
        const stacksToRun = getMultipleStacks(stacks, opts.stackNames, "deploy");
        if (!opts.ignoreMissingStackDependencies) {
            checkIfAllDependenciesAreIncluded(stacksToRun);
        }
        this.stopAllStacksThatCanNotRunWithout = (stackName) => {
            findAllNestedDependantStacks(this.stacksToRun, stackName).forEach((stack) => stack.stop());
        };
        this.stacksToRun = stacksToRun.map((stack) => this.getStackExecutor(stack, opts));
        const next = opts.ignoreMissingStackDependencies
            ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.isPending)[0])
            : () => getStackWithNoUnmetDependencies(this.stacksToRun);
        await this.execute("deploy", next, parallelism, opts.refreshOnly);
        const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);
        if (unprocessedStacks.length > 0) {
            throw errors_1.Errors.External(`Some stacks failed to deploy: ${unprocessedStacks
                .map((s) => s.stack.name)
                .join(", ")}. Please check the logs for more information.`);
        }
    }
    async destroy(opts = {}) {
        const parallelism = opts.parallelism || -1;
        const stacks = await this.synth();
        const stacksToRun = getMultipleStacks(stacks, opts.stackNames, "destroy");
        if (!opts.ignoreMissingStackDependencies) {
            checkIfAllDependantsAreIncluded(stacksToRun, stacks);
        }
        this.stopAllStacksThatCanNotRunWithout = (stackName) => {
            const stackExecutor = this.stacksToRun.find((s) => s.stack.name === stackName);
            if (!stackExecutor) {
                throw errors_1.Errors.Internal(`Could not find stack "${stackName}" that was stopped`);
            }
            stackExecutor.stack.dependencies.forEach((dependant) => {
                this.stopAllStacksThatCanNotRunWithout(dependant);
                const dependantStack = this.stacksToRun.find((s) => s.stack.name === dependant);
                if (!dependantStack) {
                    throw errors_1.Errors.Internal(`Could not find stack "${dependant}" that was stopped`);
                }
                dependantStack.stop();
            });
        };
        this.stacksToRun = stacksToRun.map((stack) => this.getStackExecutor(stack, opts));
        const next = opts.ignoreMissingStackDependencies
            ? () => Promise.resolve(this.stacksToRun.filter((stack) => stack.currentState !== "done")[0])
            : () => getStackWithNoUnmetDependants(this.stacksToRun);
        await this.execute("destroy", next, parallelism);
        const unprocessedStacks = this.stacksToRun.filter((executor) => executor.isPending);
        if (unprocessedStacks.length > 0) {
            throw errors_1.Errors.External(`Some stacks failed to destroy: ${unprocessedStacks
                .map((s) => s.stack.name)
                .join(", ")}. Please check the logs for more information.`);
        }
    }
    async fetchOutputs(opts) {
        const stacks = await this.synth();
        const stacksToRun = getMultipleStacks(stacks, opts.stackNames || [], "deploy");
        if (stacksToRun.length === 0) {
            throw new Error("No stacks to fetch outputs for specified");
        }
        this.stacksToRun = stacksToRun.map((stack) => this.getStackExecutor(stack, opts));
        const outputs = await Promise.all(this.stacksToRun.map(async (s) => {
            const output = await s.fetchOutputs();
            return {
                [s.stack.name]: output,
            };
        }));
        return outputs.reduce((acc, curr) => ({ ...acc, ...curr }), {});
    }
}
exports.CdktfProject = CdktfProject;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrdGYtcHJvamVjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNka3RmLXByb2plY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUVBQXdELENBQUMsc0NBQXNDO0FBQy9GLCtDQUE2RDtBQUM3RCxtQ0FBMkM7QUFDM0MsK0NBQTZFO0FBQzdFLHFDQUFrQztBQUdsQyx1Q0FBbUM7QUFDbkMsMERBQWtDO0FBQ2xDLHFEQUEyRDtBQXVCM0QsU0FBUyxjQUFjLENBQ3JCLE1BQTBCLEVBQzFCLFNBQWtCLEVBQ2xCLFlBQXFCO0lBRXJCLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDWCxNQUFNLGVBQU0sQ0FBQyxRQUFRLENBQ25CLHlEQUF5RCxDQUMxRCxDQUFDO0tBQ0g7SUFFRCxJQUFJLFNBQVMsRUFBRTtRQUNiLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNWLE1BQU0sZUFBTSxDQUFDLEtBQUssQ0FBQyx3QkFBd0IsR0FBRyxTQUFTLENBQUMsQ0FBQztTQUMxRDtRQUVELE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xCO0lBRUQsTUFBTSxlQUFNLENBQUMsS0FBSyxDQUNoQix1RUFDRSxZQUFZLElBQUksUUFDbEIsc0NBQXNDLE1BQU07U0FDekMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1NBQ2xCLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUNqQixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQWdCLGlCQUFpQixDQUMvQixNQUEwQixFQUMxQixRQUFtQixF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bnRyb2xsZXIgfSBmcm9tIFwibm9kZS1hYm9ydC1jb250cm9sbGVyXCI7IC8vIHBvbHlmaWxsIHVudGlsIHdlIHVwZGF0ZSB0byBub2RlIDE2XG5pbXBvcnQgeyBTeW50aGVzaXplZFN0YWNrLCBTeW50aFN0YWNrIH0gZnJvbSBcIi4vc3ludGgtc3RhY2tcIjtcbmltcG9ydCB7IHByaW50QW5ub3RhdGlvbnMgfSBmcm9tIFwiLi9zeW50aFwiO1xuaW1wb3J0IHsgQ2RrdGZTdGFjaywgU3RhY2tBcHByb3ZhbFVwZGF0ZSwgU3RhY2tVcGRhdGUgfSBmcm9tIFwiLi9jZGt0Zi1zdGFja1wiO1xuaW1wb3J0IHsgRXJyb3JzIH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBUZXJyYWZvcm1QbGFuIH0gZnJvbSBcIi4vbW9kZWxzL3RlcnJhZm9ybVwiO1xuaW1wb3J0IHsgTmVzdGVkVGVycmFmb3JtT3V0cHV0cyB9IGZyb20gXCIuL291dHB1dFwiO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vbG9nZ2luZ1wiO1xuaW1wb3J0IG1pbmltYXRjaCBmcm9tIFwibWluaW1hdGNoXCI7XG5pbXBvcnQgeyBjcmVhdGVFbmhhbmNlTG9nTWVzc2FnZSB9IGZyb20gXCIuL2V4ZWN1dGlvbi1sb2dzXCI7XG5cbnR5cGUgTXVsdGlTdGFja0FwcHJvdmFsVXBkYXRlID0ge1xuICB0eXBlOiBcIndhaXRpbmcgZm9yIGFwcHJvdmFsXCI7XG4gIHN0YWNrTmFtZTogc3RyaW5nO1xuICBwbGFuOiBUZXJyYWZvcm1QbGFuO1xuICBhcHByb3ZlOiAoKSA9PiB2b2lkO1xuICBkaXNtaXNzOiAoKSA9PiB2b2lkO1xuICBzdG9wOiAoKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IHR5cGUgUHJvamVjdFVwZGF0ZSA9XG4gIHwge1xuICAgICAgdHlwZTogXCJzeW50aGVzaXppbmdcIjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJzeW50aGVzaXplZFwiO1xuICAgICAgc3RhY2tzOiBTeW50aGVzaXplZFN0YWNrW107XG4gICAgICBlcnJvck1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgfVxuICB8IFN0YWNrVXBkYXRlXG4gIHwgTXVsdGlTdGFja0FwcHJvdmFsVXBkYXRlO1xuXG5mdW5jdGlvbiBnZXRTaW5nbGVTdGFjayhcbiAgc3RhY2tzOiBTeW50aGVzaXplZFN0YWNrW10sXG4gIHN0YWNrTmFtZT86IHN0cmluZyxcbiAgdGFyZ2V0QWN0aW9uPzogc3RyaW5nXG4pIHtcbiAgaWYgKCFzdGFja3MpIHtcbiAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICBcIlRyeWluZyB0byBhY2Nlc3MgYSBzdGFjayBiZWZvcmUgaXQgaGFzIGJlZW4gc3ludGhlc2l6ZWRcIlxuICAgICk7XG4gIH1cblxuICBpZiAoc3RhY2tOYW1lKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3MuZmluZCgocykgPT4gcy5uYW1lID09PSBzdGFja05hbWUpO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIHRocm93IEVycm9ycy5Vc2FnZShcIkNvdWxkIG5vdCBmaW5kIHN0YWNrOiBcIiArIHN0YWNrTmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgaWYgKHN0YWNrcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gc3RhY2tzWzBdO1xuICB9XG5cbiAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgIGBGb3VuZCBtb3JlIHRoYW4gb25lIHN0YWNrLCBwbGVhc2Ugc3BlY2lmeSBhIHRhcmdldCBzdGFjay4gUnVuIGNka3RmICR7XG4gICAgICB0YXJnZXRBY3Rpb24gfHwgXCI8dmVyYj5cIlxuICAgIH0gPHN0YWNrPiB3aXRoIG9uZSBvZiB0aGVzZSBzdGFja3M6ICR7c3RhY2tzXG4gICAgICAubWFwKChzKSA9PiBzLm5hbWUpXG4gICAgICAuam9pbihcIiwgXCIpfSBgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNdWx0aXBsZVN0YWNrcyhcbiAgc3RhY2tzOiBTeW50aGVzaXplZFN0YWNrW10sXG4gIHBhdHRlcm5zPzogc3RyaW5nW10sXG4gIHRhcmdldEFjdGlvbj86IHN0cmluZ1xuKSB7XG4gIGlmICghcGF0dGVybnMgfHwgIXBhdHRlcm5zLmxlbmd0aCkge1xuICAgIGlmIChzdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gW3N0YWNrc1swXV07XG4gICAgfVxuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBGb3VuZCBtb3JlIHRoYW4gb25lIHN0YWNrLCBwbGVhc2Ugc3BlY2lmeSBhIHRhcmdldCBzdGFjay4gUnVuIGNka3RmICR7XG4gICAgICAgIHRhcmdldEFjdGlvbiB8fCBcIjx2ZXJiPlwiXG4gICAgICB9IDxzdGFjaz4gd2l0aCBvbmUgb2YgdGhlc2Ugc3RhY2tzOiAke3N0YWNrc1xuICAgICAgICAubWFwKChzKSA9PiBzLm5hbWUpXG4gICAgICAgIC5qb2luKFwiLCBcIil9IGBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBhdHRlcm5zLmZsYXRNYXAoKHBhdHRlcm4pID0+IHtcbiAgICBjb25zdCBtYXRjaGluZ1N0YWNrcyA9IHN0YWNrcy5maWx0ZXIoKHN0YWNrKSA9PlxuICAgICAgbWluaW1hdGNoKHN0YWNrLm5hbWUsIHBhdHRlcm4pXG4gICAgKTtcblxuICAgIGlmIChtYXRjaGluZ1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9ycy5Vc2FnZShgQ291bGQgbm90IGZpbmQgc3RhY2sgZm9yIHBhdHRlcm4gJyR7cGF0dGVybn0nYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoaW5nU3RhY2tzO1xuICB9KTtcbn1cblxuLy8gUmV0dXJucyB0aGUgZmlyc3Qgc3RhY2sgdGhhdCBoYXMgbm8gdW5tZXQgZGVwZW5kZW5jaWVzXG4vLyBBbiB1bm1ldCBkZXBlbmRlbmN5IGlzIGEgZGVwZW5kZW5jeSB0aGF0IGhhcyBub3QgYmVlbiBkZXBsb3llZCB5ZXRcbi8vIElmIHRoZXJlIGlzIG5vIHVuZmluaXNoZWQgc3RhY2ssIHJldHVybnMgdW5kZWZpbmVkXG4vLyBJZiB0aGVyZSBpcyBubyBzdGFjayByZWFkeSB0byBiZSB3b3JrZWQgb24sIGl0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIGFzIHNvb24gYXMgdGhlcmUgaXMgYSBmb2xsb3ctdXAgc3RhY2sgYXZhaWxhYmxlXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGVuY2llcyhcbiAgc3RhY2tFeGVjdXRvcnM6IENka3RmU3RhY2tbXVxuKTogUHJvbWlzZTxDZGt0ZlN0YWNrIHwgdW5kZWZpbmVkPiB7XG4gIGxvZ2dlci5kZWJ1ZyhcIkNoZWNraW5nIGZvciBzdGFja3Mgd2l0aCB1bm1ldCBkZXBlbmRlbmNpZXNcIik7XG4gIGxvZ2dlci5kZWJ1ZyhcInN0YWNrIGV4ZWN1dG9yczpcIiwgc3RhY2tFeGVjdXRvcnMpO1xuICBjb25zdCBwZW5kaW5nU3RhY2tzID0gc3RhY2tFeGVjdXRvcnMuZmlsdGVyKChleGVjdXRvcikgPT4gZXhlY3V0b3IuaXNQZW5kaW5nKTtcbiAgbG9nZ2VyLmRlYnVnKFwicGVuZGluZyBzdGFja3M6XCIsIHN0YWNrRXhlY3V0b3JzKTtcblxuICBpZiAocGVuZGluZ1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgY3VycmVudGx5UmVhZHlTdGFjayA9IHBlbmRpbmdTdGFja3MuZmluZCgoZXhlY3V0b3IpID0+XG4gICAgZXhlY3V0b3Iuc3RhY2suZGVwZW5kZW5jaWVzLmV2ZXJ5KFxuICAgICAgKGRlcGVuZGVuY3kpID0+XG4gICAgICAgIHN0YWNrRXhlY3V0b3JzLmZpbmQoKGV4ZWN1dG9yKSA9PiBleGVjdXRvci5zdGFjay5uYW1lID09PSBkZXBlbmRlbmN5KVxuICAgICAgICAgID8uY3VycmVudFN0YXRlID09PSBcImRvbmVcIlxuICAgIClcbiAgKTtcblxuICBpZiAoY3VycmVudGx5UmVhZHlTdGFjaykge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkZvdW5kIGEgc3RhY2sgd2l0aCBubyB1bm1ldCBkZXBlbmRlbmNpZXNcIik7XG4gICAgcmV0dXJuIGN1cnJlbnRseVJlYWR5U3RhY2s7XG4gIH1cblxuICBjb25zdCBzdGFja0V4ZWN1dGlvblByb21pc2VzID0gc3RhY2tFeGVjdXRvcnNcbiAgICAuZmlsdGVyKChleCkgPT4gZXguY3VycmVudFdvcmtQcm9taXNlKVxuICAgIC5tYXAoKGV4KSA9PiBleC5jdXJyZW50V29ya1Byb21pc2UpO1xuXG4gIGxvZ2dlci5kZWJ1ZyhcbiAgICBgJHtzdGFja0V4ZWN1dGlvblByb21pc2VzLmxlbmd0aH0gc3RhY2tzIGFyZSBjdXJyZW50bHkgYnVzeSwgd2FpdGluZyBmb3Igb25lIHRvIGZpbmlzaGBcbiAgKTtcblxuICBpZiAoIXN0YWNrRXhlY3V0aW9uUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGF3YWl0IFByb21pc2UucmFjZShzdGFja0V4ZWN1dGlvblByb21pc2VzKTtcblxuICByZXR1cm4gYXdhaXQgZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGVuY2llcyhzdGFja0V4ZWN1dG9ycyk7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxEZXBlbmRhbnRTdGFja3MoXG4gIHN0YWNrRXhlY3V0b3JzOiBDZGt0ZlN0YWNrW10sXG4gIHN0YWNrTmFtZTogc3RyaW5nXG4pOiBDZGt0ZlN0YWNrW10ge1xuICByZXR1cm4gc3RhY2tFeGVjdXRvcnMuZmlsdGVyKChpbm5lckV4ZWN1dG9yKSA9PlxuICAgIGlubmVyRXhlY3V0b3Iuc3RhY2suZGVwZW5kZW5jaWVzLmluY2x1ZGVzKHN0YWNrTmFtZSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbE5lc3RlZERlcGVuZGFudFN0YWNrcyhcbiAgc3RhY2tFeGVjdXRvcnM6IENka3RmU3RhY2tbXSxcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gIGtub3duRGVwZW5kYW50U3RhY2tOYW1lczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcbik6IENka3RmU3RhY2tbXSB7XG4gIGNvbnN0IGRlcGVuZGFudFN0YWNrcyA9IGZpbmRBbGxEZXBlbmRhbnRTdGFja3Moc3RhY2tFeGVjdXRvcnMsIHN0YWNrTmFtZSk7XG4gIGRlcGVuZGFudFN0YWNrcy5mb3JFYWNoKChzdGFjaykgPT4ge1xuICAgIGlmIChrbm93bkRlcGVuZGFudFN0YWNrTmFtZXMuaGFzKHN0YWNrLnN0YWNrLm5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAga25vd25EZXBlbmRhbnRTdGFja05hbWVzLmFkZChzdGFjay5zdGFjay5uYW1lKTtcbiAgICBmaW5kQWxsTmVzdGVkRGVwZW5kYW50U3RhY2tzKFxuICAgICAgc3RhY2tFeGVjdXRvcnMsXG4gICAgICBzdGFjay5zdGFjay5uYW1lLFxuICAgICAga25vd25EZXBlbmRhbnRTdGFja05hbWVzXG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHN0YWNrRXhlY3V0b3JzLmZpbHRlcigoZXhlY3V0b3IpID0+XG4gICAga25vd25EZXBlbmRhbnRTdGFja05hbWVzLmhhcyhleGVjdXRvci5zdGFjay5uYW1lKVxuICApO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBzdGFjayB0aGF0IGhhcyBubyBkZXBlbmRlbnRzIHRoYXQgbmVlZCB0byBiZSBkZXN0cm95ZWQgZmlyc3RcbmFzeW5jIGZ1bmN0aW9uIGdldFN0YWNrV2l0aE5vVW5tZXREZXBlbmRhbnRzKFxuICBzdGFja0V4ZWN1dG9yczogQ2RrdGZTdGFja1tdXG4pOiBQcm9taXNlPENka3RmU3RhY2sgfCB1bmRlZmluZWQ+IHtcbiAgbG9nZ2VyLmRlYnVnKFwiQ2hlY2tpbmcgZm9yIHN0YWNrcyB3aXRoIHVubWV0IGRlcGVuZGFudHNcIik7XG4gIGxvZ2dlci5kZWJ1ZyhcInN0YWNrIGV4ZWN1dG9yczpcIiwgc3RhY2tFeGVjdXRvcnMpO1xuICBjb25zdCBwZW5kaW5nU3RhY2tzID0gc3RhY2tFeGVjdXRvcnMuZmlsdGVyKChleGVjdXRvcikgPT4gZXhlY3V0b3IuaXNQZW5kaW5nKTtcbiAgbG9nZ2VyLmRlYnVnKFwicGVuZGluZyBzdGFja3M6XCIsIHN0YWNrRXhlY3V0b3JzKTtcblxuICBpZiAocGVuZGluZ1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgY3VycmVudGx5UmVhZHlTdGFjayA9IHBlbmRpbmdTdGFja3MuZmluZCgoZXhlY3V0b3IpID0+IHtcbiAgICBjb25zdCBkZXBlbmRhbnRTdGFja3MgPSBmaW5kQWxsRGVwZW5kYW50U3RhY2tzKFxuICAgICAgc3RhY2tFeGVjdXRvcnMsXG4gICAgICBleGVjdXRvci5zdGFjay5uYW1lXG4gICAgKTtcbiAgICByZXR1cm4gZGVwZW5kYW50U3RhY2tzLmV2ZXJ5KChzdGFjaykgPT4gc3RhY2suY3VycmVudFN0YXRlID09PSBcImRvbmVcIik7XG4gIH0pO1xuXG4gIGlmIChjdXJyZW50bHlSZWFkeVN0YWNrKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiRm91bmQgYSBzdGFjayB3aXRoIG5vIHVubWV0IGRlcGVuZGFudHNcIik7XG4gICAgcmV0dXJuIGN1cnJlbnRseVJlYWR5U3RhY2s7XG4gIH1cbiAgY29uc3Qgc3RhY2tFeGVjdXRpb25Qcm9taXNlcyA9IHN0YWNrRXhlY3V0b3JzXG4gICAgLmZpbHRlcigoZXgpID0+IGV4LmN1cnJlbnRXb3JrUHJvbWlzZSlcbiAgICAubWFwKChleCkgPT4gZXguY3VycmVudFdvcmtQcm9taXNlKTtcblxuICBsb2dnZXIuZGVidWcoXG4gICAgYCR7c3RhY2tFeGVjdXRpb25Qcm9taXNlcy5sZW5ndGh9IHN0YWNrcyBhcmUgY3VycmVudGx5IGJ1c3ksIHdhaXRpbmcgZm9yIG9uZSB0byBmaW5pc2hgXG4gICk7XG4gIGlmICghc3RhY2tFeGVjdXRpb25Qcm9taXNlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgYXdhaXQgUHJvbWlzZS5yYWNlKHN0YWNrRXhlY3V0aW9uUHJvbWlzZXMpO1xuICByZXR1cm4gYXdhaXQgZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGFudHMoc3RhY2tFeGVjdXRvcnMpO1xufVxuXG4vLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYSBkZXBlbmRhbnQgc3RhY2sgdGhhdCBpcyBub3QgaW5jbHVkZWRcbmZ1bmN0aW9uIGNoZWNrSWZBbGxEZXBlbmRhbnRzQXJlSW5jbHVkZWQoXG4gIHN0YWNrc1RvUnVuOiBTeW50aGVzaXplZFN0YWNrW10sXG4gIGFsbFN0YWNrczogU3ludGhlc2l6ZWRTdGFja1tdXG4pIHtcbiAgY29uc3QgYWxsRGVwZW5kYW50cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBzdGFja3NUb1J1blxuICAgIC5tYXAoKHN0YWNrKSA9PlxuICAgICAgYWxsU3RhY2tzLmZpbHRlcigocykgPT4gcy5kZXBlbmRlbmNpZXMuaW5jbHVkZXMoc3RhY2submFtZSkpXG4gICAgKVxuICAgIC5mbGF0KClcbiAgICAuZm9yRWFjaCgoZGVwZW5kYW50KSA9PiBhbGxEZXBlbmRhbnRzLmFkZChkZXBlbmRhbnQubmFtZSkpO1xuXG4gIGNvbnN0IHN0YWNrTmFtZXMgPSBzdGFja3NUb1J1bi5tYXAoKHN0YWNrKSA9PiBzdGFjay5uYW1lKTtcbiAgY29uc3QgbWlzc2luZ0RlcGVuZGFudHMgPSBbLi4uYWxsRGVwZW5kYW50c10uZmlsdGVyKFxuICAgIChkZXBlbmRhbnQpID0+ICFzdGFja05hbWVzLmluY2x1ZGVzKGRlcGVuZGFudClcbiAgKTtcblxuICBpZiAobWlzc2luZ0RlcGVuZGFudHMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBUaGUgZm9sbG93aW5nIGRlcGVuZGFudCBzdGFja3MgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGUgc3RhY2tzIHRvIHJ1bjogJHttaXNzaW5nRGVwZW5kYW50cy5qb2luKFxuICAgICAgICBcIiwgXCJcbiAgICAgICl9LiBFaXRoZXIgYWRkIHRoZW0gb3IgYWRkIHRoZSAtLWlnbm9yZS1taXNzaW5nLXN0YWNrLWRlcGVuZGVuY2llcyBmbGFnLmBcbiAgICApO1xuICB9XG59XG5cbi8vIFRocm93cyBhbiBlcnJvciBpZiB0aGVyZSBpcyBhIGRlcGVuZGVuY3kgdGhhdCBpcyBub3QgaW5jbHVkZWRcbi8vIEN5Y2xlcyBhcmUgZGV0ZWN0ZWQgb24gZGVwZW5kZW5jeSBjcmVhdGlvbiBhdCBzeW50aGVzaXMgdGltZVxuLy8gUnVubmluZyB0aGlzIHByZXZlbnRzIHVzIGZyb20gYmVpbmcgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgaGF2ZSB0byB3YWl0IGZvciBhIHN0YWNrIHRvIGJlIGRlcGxveWVkXG4vLyB0aGF0IGlzIG5vdCBpbmNsdWRlZCB0byBiZSBydW5cbmZ1bmN0aW9uIGNoZWNrSWZBbGxEZXBlbmRlbmNpZXNBcmVJbmNsdWRlZChzdGFja3NUb1J1bjogU3ludGhlc2l6ZWRTdGFja1tdKSB7XG4gIGNvbnN0IGFsbERlcGVuZGVuY2llcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBzdGFja3NUb1J1blxuICAgIC5tYXAoKHN0YWNrKSA9PiBzdGFjay5kZXBlbmRlbmNpZXMpXG4gICAgLmZsYXQoKVxuICAgIC5mb3JFYWNoKChkZXBlbmRlbmN5KSA9PiBhbGxEZXBlbmRlbmNpZXMuYWRkKGRlcGVuZGVuY3kpKTtcblxuICBjb25zdCBzdGFja05hbWVzID0gc3RhY2tzVG9SdW4ubWFwKChzdGFjaykgPT4gc3RhY2submFtZSk7XG4gIGNvbnN0IG1pc3NpbmdEZXBlbmRlbmNpZXMgPSBbLi4uYWxsRGVwZW5kZW5jaWVzXS5maWx0ZXIoXG4gICAgKGRlcGVuZGVuY3kpID0+ICFzdGFja05hbWVzLmluY2x1ZGVzKGRlcGVuZGVuY3kpXG4gICk7XG5cbiAgaWYgKG1pc3NpbmdEZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgIGBUaGUgZm9sbG93aW5nIGRlcGVuZGVuY2llcyBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSBzdGFja3MgdG8gcnVuOiAke21pc3NpbmdEZXBlbmRlbmNpZXMuam9pbihcbiAgICAgICAgXCIsIFwiXG4gICAgICApfS4gRWl0aGVyIGFkZCB0aGVtIG9yIGFkZCB0aGUgLS1pZ25vcmUtbWlzc2luZy1zdGFjay1kZXBlbmRlbmNpZXMgZmxhZy5gXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBTaW5nbGVTdGFja09wdGlvbnMgPSB7XG4gIHN0YWNrTmFtZT86IHN0cmluZztcbn07XG5cbmV4cG9ydCB0eXBlIE11bHRpcGxlU3RhY2tPcHRpb25zID0ge1xuICBzdGFja05hbWVzPzogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBFeGVjdXRpb25PcHRpb25zID0gTXVsdGlwbGVTdGFja09wdGlvbnMgJiB7XG4gIGF1dG9BcHByb3ZlPzogYm9vbGVhbjtcbiAgaWdub3JlTWlzc2luZ1N0YWNrRGVwZW5kZW5jaWVzPzogYm9vbGVhbjtcbiAgcGFyYWxsZWxpc20/OiBudW1iZXI7XG4gIHJlZnJlc2hPbmx5PzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCB0eXBlIERpZmZPcHRpb25zID0gU2luZ2xlU3RhY2tPcHRpb25zICYge1xuICByZWZyZXNoT25seT86IGJvb2xlYW47XG59O1xuXG50eXBlIExvZ01lc3NhZ2UgPSB7XG4gIHN0YWNrTmFtZTogc3RyaW5nO1xuICBtZXNzYWdlV2l0aENvbnN0cnVjdFBhdGg/OiBzdHJpbmc7XG4gIG1lc3NhZ2U6IHN0cmluZztcbn07XG5cbi8vIFN0b3JlcyBhIGxvZyB2YWx1ZSBvZiBhIGNlcnRhaW4gdHlwZSB1bnRpbCBpdCBjYW4gYmUgc2VudFxudHlwZSBCdWZmZXJlZDxULCBWPiA9IHtcbiAgY2I6IChpdGVtOiBUKSA9PiB2b2lkO1xuICB2YWx1ZTogVDtcbiAgdHlwZTogVjtcbn07XG5cbmV4cG9ydCB0eXBlIENka3RmUHJvamVjdE9wdGlvbnMgPSB7XG4gIHN5bnRoQ29tbWFuZDogc3RyaW5nO1xuICBvdXREaXI6IHN0cmluZztcbiAgb25VcGRhdGU6ICh1cGRhdGU6IFByb2plY3RVcGRhdGUpID0+IHZvaWQ7XG4gIG9uTG9nPzogKGxvZzogTG9nTWVzc2FnZSkgPT4gdm9pZDtcbiAgd29ya2luZ0RpcmVjdG9yeT86IHN0cmluZztcbn07XG5leHBvcnQgY2xhc3MgQ2RrdGZQcm9qZWN0IHtcbiAgcHVibGljIHN0YWNrcz86IFN5bnRoZXNpemVkU3RhY2tbXTtcbiAgcHVibGljIGhhcmRBYm9ydDogKCkgPT4gdm9pZDtcblxuICBwcml2YXRlIHN5bnRoQ29tbWFuZDogc3RyaW5nO1xuICBwcml2YXRlIG91dERpcjogc3RyaW5nO1xuICBwcml2YXRlIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZztcbiAgcHJpdmF0ZSBvblVwZGF0ZTogKHVwZGF0ZTogUHJvamVjdFVwZGF0ZSkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBvbkxvZz86IChsb2c6IExvZ01lc3NhZ2UpID0+IHZvaWQ7XG4gIHByaXZhdGUgYWJvcnRTaWduYWw6IEFib3J0U2lnbmFsO1xuXG4gIC8vIFNldCBkdXJpbmcgZGVwbG95IC8gZGVzdHJveVxuICBwdWJsaWMgc3RhY2tzVG9SdW46IENka3RmU3RhY2tbXSA9IFtdO1xuICAvLyBUaGlzIG1lYW5zIHN0aCBkaWZmZXJlbnQgaW4gZGVwbG95IC8gZGVzdHJveVxuICBwcml2YXRlIHN0b3BBbGxTdGFja3NUaGF0Q2FuTm90UnVuV2l0aG91dDogKHN0YWNrTmFtZTogc3RyaW5nKSA9PiB2b2lkID1cbiAgICAoKSA9PiB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgLy8gUGF1c2VzIGFsbCBwcm9ncmVzcyAvIHN0YXR1cyBldmVudHMgZnJvbSBiZWluZyBmb3J3YXJkZWQgdG8gdGhlIHVzZXJcbiAgLy8gSWYgc2V0IGZyb20gdHJ1ZSB0byBmYWxzZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHNlbnQgdGhyb3VnaCB0aGUgY2hhbm5lbHMgdGhleSBjYW1lIGluXG4gIC8vICh1bnRpbCBhIHdhaXRpbmcgZm9yIGFwcHJvdmFsIGV2ZW50IGlzIHNlbnQpXG4gIHByaXZhdGUgd2FpdGluZ0ZvckFwcHJvdmFsID0gZmFsc2U7XG4gIHByaXZhdGUgZXZlbnRCdWZmZXI6IEFycmF5PFxuICAgIHwgQnVmZmVyZWQ8UHJvamVjdFVwZGF0ZSwgXCJwcm9qZWN0VXBkYXRlXCI+XG4gICAgfCBCdWZmZXJlZDxMb2dNZXNzYWdlLCBcImxvZ01lc3NhZ2VcIj5cbiAgPiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzeW50aENvbW1hbmQsXG4gICAgb3V0RGlyLFxuICAgIG9uVXBkYXRlLFxuICAgIG9uTG9nLFxuICAgIHdvcmtpbmdEaXJlY3RvcnkgPSBwcm9jZXNzLmN3ZCgpLFxuICB9OiBDZGt0ZlByb2plY3RPcHRpb25zKSB7XG4gICAgdGhpcy5zeW50aENvbW1hbmQgPSBzeW50aENvbW1hbmQ7XG4gICAgdGhpcy5vdXREaXIgPSBvdXREaXI7XG4gICAgdGhpcy53b3JraW5nRGlyZWN0b3J5ID0gd29ya2luZ0RpcmVjdG9yeTtcbiAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGU7XG4gICAgdGhpcy5vbkxvZyA9IG9uTG9nO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuYWJvcnRTaWduYWwgPSBhYy5zaWduYWw7XG5cbiAgICB0aGlzLmhhcmRBYm9ydCA9IGFjLmFib3J0LmJpbmQoYWMpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdG9wQWxsU3RhY2tzKCkge1xuICAgIHRoaXMuc3RhY2tzVG9SdW4uZm9yRWFjaCgoc3RhY2spID0+IHN0YWNrLnN0b3AoKSk7XG4gICAgdGhpcy5ldmVudEJ1ZmZlciA9IHRoaXMuZXZlbnRCdWZmZXIuZmlsdGVyKFxuICAgICAgKGV2ZW50KSA9PlxuICAgICAgICBldmVudC50eXBlID09PSBcInByb2plY3RVcGRhdGVcIlxuICAgICAgICAgID8gZXZlbnQudmFsdWUudHlwZSAhPT0gXCJ3YWl0aW5nIGZvciBhcHByb3ZhbFwiIC8vIHdlIHdhbnQgdG8gZmlsdGVyIG91dCB0aGUgd2FpdGluZyBmb3IgYXBwcm92YWwgZXZlbnRzXG4gICAgICAgICAgOiB0cnVlIC8vIHdlIHdhbnQgYWxsIG90aGVyIHR5cGVzXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgd2FpdEZvckFwcHJvdmFsKCkge1xuICAgIHRoaXMud2FpdGluZ0ZvckFwcHJvdmFsID0gdHJ1ZTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzdW1lQWZ0ZXJBcHByb3ZhbCgpIHtcbiAgICAvLyBXZSBmaXJzdCBuZWVkIHRvIGZsdXNoIGFsbCBldmVudHMsIHdlIGNhbiBub3QgcmVzdW1lIGlmIHRoZXJlIGlzIGEgbmV3IHdhaXRpbmcgZm9yIGFwcHJvdmFsIHVwZGF0ZVxuICAgIGxldCBldmVudCA9IHRoaXMuZXZlbnRCdWZmZXIuc2hpZnQoKTtcbiAgICB3aGlsZSAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50eXBlID09PSBcInByb2plY3RVcGRhdGVcIikge1xuICAgICAgICBldmVudC5jYihldmVudC52YWx1ZSk7XG4gICAgICAgIGlmIChldmVudC52YWx1ZS50eXBlID09PSBcIndhaXRpbmcgZm9yIGFwcHJvdmFsXCIpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIHdhaXQgZm9yIGFwcHJvdmFsIGFnYWluLCB0aGVyZWZvcmUgd2UgY2FuIG5vdCByZXN1bWVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcImxvZ01lc3NhZ2VcIikge1xuICAgICAgICBldmVudC5jYihldmVudC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50ID0gdGhpcy5ldmVudEJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgcG9pbnQgdGhlcmUgd2FzIG5vIHdhaXRpbmcgZm9yIGFwcHJvdmFsIGV2ZW50LCBzbyB3ZSBjYW4gc2FmZWx5IHJlc3VtZVxuICAgIHRoaXMud2FpdGluZ0ZvckFwcHJvdmFsID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUFwcHJvdmFsUHJvY2VzcyhjYjogKHVwZGF0ZVRvU2VuZDogUHJvamVjdFVwZGF0ZSkgPT4gdm9pZCkge1xuICAgIHJldHVybiAodXBkYXRlOiBTdGFja1VwZGF0ZSB8IFN0YWNrQXBwcm92YWxVcGRhdGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlckNiID0gKGJ1ZmZlcmVkVXBkYXRlOiBQcm9qZWN0VXBkYXRlKSA9PiB7XG4gICAgICAgIHRoaXMuZXZlbnRCdWZmZXIucHVzaCh7XG4gICAgICAgICAgY2IsXG4gICAgICAgICAgdmFsdWU6IGJ1ZmZlcmVkVXBkYXRlLFxuICAgICAgICAgIHR5cGU6IFwicHJvamVjdFVwZGF0ZVwiLFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBidWZmZXJhYmxlQ2IgPSB0aGlzLndhaXRpbmdGb3JBcHByb3ZhbCA/IGJ1ZmZlckNiIDogY2I7XG5cbiAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gXCJ3YWl0aW5nIGZvciBzdGFjayBhcHByb3ZhbFwiKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh1cGRhdGU6IFN0YWNrQXBwcm92YWxVcGRhdGUpID0+ICh7XG4gICAgICAgICAgYXBwcm92ZTogKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlLmFwcHJvdmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lQWZ0ZXJBcHByb3ZhbCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzbWlzczogKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlLnJlamVjdCgpO1xuXG4gICAgICAgICAgICB0aGlzLnN0b3BBbGxTdGFja3NUaGF0Q2FuTm90UnVuV2l0aG91dCh1cGRhdGUuc3RhY2tOYW1lKTtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lQWZ0ZXJBcHByb3ZhbCgpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlLnJlamVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wQWxsU3RhY2tzKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZUFmdGVyQXBwcm92YWwoKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53YWl0Rm9yQXBwcm92YWwoKTtcblxuICAgICAgICBidWZmZXJhYmxlQ2Ioe1xuICAgICAgICAgIHR5cGU6IFwid2FpdGluZyBmb3IgYXBwcm92YWxcIixcbiAgICAgICAgICBzdGFja05hbWU6IHVwZGF0ZS5zdGFja05hbWUsXG4gICAgICAgICAgcGxhbjogdXBkYXRlLnBsYW4sXG4gICAgICAgICAgLi4uY2FsbGJhY2tzKHVwZGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyYWJsZUNiKHVwZGF0ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYnVmZmVyV2hpbGVXYWl0aW5nRm9yQXBwcm92YWwoY2I/OiAobXNnOiBMb2dNZXNzYWdlKSA9PiB2b2lkKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gKG1zZzogTG9nTWVzc2FnZSkgPT4ge1xuICAgICAgaWYgKHRoaXMud2FpdGluZ0ZvckFwcHJvdmFsKSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdWZmZXIucHVzaCh7XG4gICAgICAgICAgY2IsXG4gICAgICAgICAgdmFsdWU6IG1zZyxcbiAgICAgICAgICB0eXBlOiBcImxvZ01lc3NhZ2VcIixcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihtc2cpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZ2V0U3RhY2tFeGVjdXRvcihcbiAgICBzdGFjazogU3ludGhlc2l6ZWRTdGFjayxcbiAgICBvcHRzOiBFeGVjdXRpb25PcHRpb25zID0ge31cbiAgKSB7XG4gICAgY29uc3QgZW5oYW5jZUxvZ01lc3NhZ2UgPSBjcmVhdGVFbmhhbmNlTG9nTWVzc2FnZShzdGFjayk7XG4gICAgY29uc3Qgb25Mb2cgPSB0aGlzLmJ1ZmZlcldoaWxlV2FpdGluZ0ZvckFwcHJvdmFsKHRoaXMub25Mb2cpO1xuICAgIHJldHVybiBuZXcgQ2RrdGZTdGFjayh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgc3RhY2ssXG4gICAgICBvblVwZGF0ZTogdGhpcy5oYW5kbGVBcHByb3ZhbFByb2Nlc3ModGhpcy5vblVwZGF0ZSksXG4gICAgICBvbkxvZzogb25Mb2dcbiAgICAgICAgPyAoeyBtZXNzYWdlIH0pID0+XG4gICAgICAgICAgICBvbkxvZyh7XG4gICAgICAgICAgICAgIHN0YWNrTmFtZTogc3RhY2submFtZSxcbiAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgbWVzc2FnZVdpdGhDb25zdHJ1Y3RQYXRoOiBlbmhhbmNlTG9nTWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgYWJvcnRTaWduYWw6IHRoaXMuYWJvcnRTaWduYWwsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG91dHB1dHNCeUNvbnN0cnVjdElkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrc1RvUnVuLnJlZHVjZShcbiAgICAgIChhY2MsIHN0YWNrKSA9PiAoe1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIC4uLnN0YWNrLm91dHB1dHNCeUNvbnN0cnVjdElkLFxuICAgICAgfSksXG4gICAgICB7fSBhcyBOZXN0ZWRUZXJyYWZvcm1PdXRwdXRzXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzeW50aCgpIHtcbiAgICB0aGlzLm9uVXBkYXRlKHtcbiAgICAgIHR5cGU6IFwic3ludGhlc2l6aW5nXCIsXG4gICAgfSk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgU3ludGhTdGFjay5zeW50aChcbiAgICAgIHRoaXMuYWJvcnRTaWduYWwsXG4gICAgICB0aGlzLnN5bnRoQ29tbWFuZCxcbiAgICAgIHRoaXMub3V0RGlyLFxuICAgICAgdGhpcy53b3JraW5nRGlyZWN0b3J5XG4gICAgKTtcblxuICAgIHByaW50QW5ub3RhdGlvbnMoc3RhY2tzKTtcblxuICAgIHRoaXMub25VcGRhdGUoe1xuICAgICAgdHlwZTogXCJzeW50aGVzaXplZFwiLFxuICAgICAgc3RhY2tzLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkaWZmKG9wdHM/OiBEaWZmT3B0aW9ucykge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IHRoaXMuc3ludGgoKTtcbiAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2tFeGVjdXRvcihcbiAgICAgIGdldFNpbmdsZVN0YWNrKHN0YWNrcywgb3B0cz8uc3RhY2tOYW1lLCBcImRpZmZcIilcbiAgICApO1xuICAgIGF3YWl0IHN0YWNrLmRpZmYoeyByZWZyZXNoT25seTogb3B0cz8ucmVmcmVzaE9ubHkgfSk7XG4gICAgaWYgKCFzdGFjay5jdXJyZW50UGxhbilcbiAgICAgIHRocm93IEVycm9ycy5FeHRlcm5hbChcbiAgICAgICAgYFN0YWNrIGZhaWxlZCB0byBwbGFuOiAke3N0YWNrLnN0YWNrLm5hbWV9LiBQbGVhc2UgY2hlY2sgdGhlIGxvZ3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgKTtcbiAgICByZXR1cm4gc3RhY2suY3VycmVudFBsYW47XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4ZWN1dGUoXG4gICAgbWV0aG9kOiBcImRlcGxveVwiIHwgXCJkZXN0cm95XCIsXG4gICAgbmV4dDogKCkgPT4gUHJvbWlzZTxDZGt0ZlN0YWNrIHwgdW5kZWZpbmVkPixcbiAgICBwYXJhbGxlbGlzbTogbnVtYmVyLFxuICAgIHJlZnJlc2hPbmx5PzogYm9vbGVhblxuICApIHtcbiAgICAvLyBXZSBvbmx5IHN1cHBvcnQgcmVmcmVzaCBvbmx5IG9uIGRlcGxveSwgYSBiaXQgb2YgYSBsZWFreSBhYnN0cmFjdGlvbiBoZXJlXG4gICAgaWYgKHJlZnJlc2hPbmx5ICYmIG1ldGhvZCAhPT0gXCJkZXBsb3lcIikge1xuICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKGBSZWZyZXNoIG9ubHkgaXMgb25seSBzdXBwb3J0ZWQgb24gZGVwbG95YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWF4UGFyYWxsZWxSdW5zID0gcGFyYWxsZWxpc20gPT09IC0xID8gSW5maW5pdHkgOiBwYXJhbGxlbGlzbTtcbiAgICB3aGlsZSAodGhpcy5zdGFja3NUb1J1bi5maWx0ZXIoKHN0YWNrKSA9PiBzdGFjay5pc1BlbmRpbmcpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJ1bm5pbmdTdGFja3MgPSB0aGlzLnN0YWNrc1RvUnVuLmZpbHRlcigoc3RhY2spID0+IHN0YWNrLmlzUnVubmluZyk7XG4gICAgICBpZiAocnVubmluZ1N0YWNrcy5sZW5ndGggPj0gbWF4UGFyYWxsZWxSdW5zKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShydW5uaW5nU3RhY2tzLm1hcCgocykgPT4gcy5jdXJyZW50V29ya1Byb21pc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG5leHRSdW5uaW5nRXhlY3V0b3IgPSBhd2FpdCBuZXh0KCk7XG4gICAgICAgIGlmICghbmV4dFJ1bm5pbmdFeGVjdXRvcikge1xuICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBoYXZlIG5vIHBlbmRpbmcgc3RhY2tzLCBidXQgd2UgYWxzbyBjYW4gbm90IGZpbmQgYSBuZXcgZXhlY3V0b3JcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIG1ldGhvZCA9PT0gXCJkZXBsb3lcIlxuICAgICAgICAgID8gbmV4dFJ1bm5pbmdFeGVjdXRvci5kZXBsb3kocmVmcmVzaE9ubHkpXG4gICAgICAgICAgOiBuZXh0UnVubmluZ0V4ZWN1dG9yLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZSBlbmQgdGhlIGxvb3Agd2hlbiBhbGwgc3RhY2tzIGFyZSBzdGFydGVkLCBub3cgd2UgbmVlZCB0byB3YWl0IGZvciB0aGVtIHRvIGJlIGRvbmVcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuc3RhY2tzVG9SdW5cbiAgICAgICAgLmZpbHRlcigoZXgpID0+IGV4LmN1cnJlbnRXb3JrUHJvbWlzZSlcbiAgICAgICAgLm1hcCgoZXgpID0+IGV4LmN1cnJlbnRXb3JrUHJvbWlzZSlcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveShvcHRzOiBFeGVjdXRpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwYXJhbGxlbGlzbSA9IG9wdHMucGFyYWxsZWxpc20gfHwgLTE7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zeW50aCgpO1xuICAgIGNvbnN0IHN0YWNrc1RvUnVuID0gZ2V0TXVsdGlwbGVTdGFja3Moc3RhY2tzLCBvcHRzLnN0YWNrTmFtZXMsIFwiZGVwbG95XCIpO1xuICAgIGlmICghb3B0cy5pZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNoZWNrSWZBbGxEZXBlbmRlbmNpZXNBcmVJbmNsdWRlZChzdGFja3NUb1J1bik7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wQWxsU3RhY2tzVGhhdENhbk5vdFJ1bldpdGhvdXQgPSAoc3RhY2tOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGZpbmRBbGxOZXN0ZWREZXBlbmRhbnRTdGFja3ModGhpcy5zdGFja3NUb1J1biwgc3RhY2tOYW1lKS5mb3JFYWNoKFxuICAgICAgICAoc3RhY2spID0+IHN0YWNrLnN0b3AoKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdGFja3NUb1J1biA9IHN0YWNrc1RvUnVuLm1hcCgoc3RhY2spID0+XG4gICAgICB0aGlzLmdldFN0YWNrRXhlY3V0b3Ioc3RhY2ssIG9wdHMpXG4gICAgKTtcblxuICAgIGNvbnN0IG5leHQgPSBvcHRzLmlnbm9yZU1pc3NpbmdTdGFja0RlcGVuZGVuY2llc1xuICAgICAgPyAoKSA9PlxuICAgICAgICAgIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgIHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKChzdGFjaykgPT4gc3RhY2suaXNQZW5kaW5nKVswXVxuICAgICAgICAgIClcbiAgICAgIDogKCkgPT4gZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGVuY2llcyh0aGlzLnN0YWNrc1RvUnVuKTtcblxuICAgIGF3YWl0IHRoaXMuZXhlY3V0ZShcImRlcGxveVwiLCBuZXh0LCBwYXJhbGxlbGlzbSwgb3B0cy5yZWZyZXNoT25seSk7XG5cbiAgICBjb25zdCB1bnByb2Nlc3NlZFN0YWNrcyA9IHRoaXMuc3RhY2tzVG9SdW4uZmlsdGVyKFxuICAgICAgKGV4ZWN1dG9yKSA9PiBleGVjdXRvci5pc1BlbmRpbmdcbiAgICApO1xuICAgIGlmICh1bnByb2Nlc3NlZFN0YWNrcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuRXh0ZXJuYWwoXG4gICAgICAgIGBTb21lIHN0YWNrcyBmYWlsZWQgdG8gZGVwbG95OiAke3VucHJvY2Vzc2VkU3RhY2tzXG4gICAgICAgICAgLm1hcCgocykgPT4gcy5zdGFjay5uYW1lKVxuICAgICAgICAgIC5qb2luKFwiLCBcIil9LiBQbGVhc2UgY2hlY2sgdGhlIGxvZ3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVzdHJveShvcHRzOiBFeGVjdXRpb25PcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwYXJhbGxlbGlzbSA9IG9wdHMucGFyYWxsZWxpc20gfHwgLTE7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zeW50aCgpO1xuICAgIGNvbnN0IHN0YWNrc1RvUnVuID0gZ2V0TXVsdGlwbGVTdGFja3Moc3RhY2tzLCBvcHRzLnN0YWNrTmFtZXMsIFwiZGVzdHJveVwiKTtcblxuICAgIGlmICghb3B0cy5pZ25vcmVNaXNzaW5nU3RhY2tEZXBlbmRlbmNpZXMpIHtcbiAgICAgIGNoZWNrSWZBbGxEZXBlbmRhbnRzQXJlSW5jbHVkZWQoc3RhY2tzVG9SdW4sIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wQWxsU3RhY2tzVGhhdENhbk5vdFJ1bldpdGhvdXQgPSAoc3RhY2tOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IHN0YWNrRXhlY3V0b3IgPSB0aGlzLnN0YWNrc1RvUnVuLmZpbmQoXG4gICAgICAgIChzKSA9PiBzLnN0YWNrLm5hbWUgPT09IHN0YWNrTmFtZVxuICAgICAgKTtcbiAgICAgIGlmICghc3RhY2tFeGVjdXRvcikge1xuICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgICAgYENvdWxkIG5vdCBmaW5kIHN0YWNrIFwiJHtzdGFja05hbWV9XCIgdGhhdCB3YXMgc3RvcHBlZGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgc3RhY2tFeGVjdXRvci5zdGFjay5kZXBlbmRlbmNpZXMuZm9yRWFjaCgoZGVwZW5kYW50KSA9PiB7XG4gICAgICAgIHRoaXMuc3RvcEFsbFN0YWNrc1RoYXRDYW5Ob3RSdW5XaXRob3V0KGRlcGVuZGFudCk7XG5cbiAgICAgICAgY29uc3QgZGVwZW5kYW50U3RhY2sgPSB0aGlzLnN0YWNrc1RvUnVuLmZpbmQoXG4gICAgICAgICAgKHMpID0+IHMuc3RhY2submFtZSA9PT0gZGVwZW5kYW50XG4gICAgICAgICk7XG4gICAgICAgIGlmICghZGVwZW5kYW50U3RhY2spIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgICAgICBgQ291bGQgbm90IGZpbmQgc3RhY2sgXCIke2RlcGVuZGFudH1cIiB0aGF0IHdhcyBzdG9wcGVkYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXBlbmRhbnRTdGFjay5zdG9wKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc3RhY2tzVG9SdW4gPSBzdGFja3NUb1J1bi5tYXAoKHN0YWNrKSA9PlxuICAgICAgdGhpcy5nZXRTdGFja0V4ZWN1dG9yKHN0YWNrLCBvcHRzKVxuICAgICk7XG4gICAgY29uc3QgbmV4dCA9IG9wdHMuaWdub3JlTWlzc2luZ1N0YWNrRGVwZW5kZW5jaWVzXG4gICAgICA/ICgpID0+XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgdGhpcy5zdGFja3NUb1J1bi5maWx0ZXIoKHN0YWNrKSA9PiBzdGFjay5jdXJyZW50U3RhdGUgIT09IFwiZG9uZVwiKVswXVxuICAgICAgICAgIClcbiAgICAgIDogKCkgPT4gZ2V0U3RhY2tXaXRoTm9Vbm1ldERlcGVuZGFudHModGhpcy5zdGFja3NUb1J1bik7XG5cbiAgICBhd2FpdCB0aGlzLmV4ZWN1dGUoXCJkZXN0cm95XCIsIG5leHQsIHBhcmFsbGVsaXNtKTtcblxuICAgIGNvbnN0IHVucHJvY2Vzc2VkU3RhY2tzID0gdGhpcy5zdGFja3NUb1J1bi5maWx0ZXIoXG4gICAgICAoZXhlY3V0b3IpID0+IGV4ZWN1dG9yLmlzUGVuZGluZ1xuICAgICk7XG4gICAgaWYgKHVucHJvY2Vzc2VkU3RhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IEVycm9ycy5FeHRlcm5hbChcbiAgICAgICAgYFNvbWUgc3RhY2tzIGZhaWxlZCB0byBkZXN0cm95OiAke3VucHJvY2Vzc2VkU3RhY2tzXG4gICAgICAgICAgLm1hcCgocykgPT4gcy5zdGFjay5uYW1lKVxuICAgICAgICAgIC5qb2luKFwiLCBcIil9LiBQbGVhc2UgY2hlY2sgdGhlIGxvZ3MgZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZmV0Y2hPdXRwdXRzKG9wdHM6IE11bHRpcGxlU3RhY2tPcHRpb25zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zeW50aCgpO1xuXG4gICAgY29uc3Qgc3RhY2tzVG9SdW4gPSBnZXRNdWx0aXBsZVN0YWNrcyhcbiAgICAgIHN0YWNrcyxcbiAgICAgIG9wdHMuc3RhY2tOYW1lcyB8fCBbXSxcbiAgICAgIFwiZGVwbG95XCJcbiAgICApO1xuXG4gICAgaWYgKHN0YWNrc1RvUnVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3RhY2tzIHRvIGZldGNoIG91dHB1dHMgZm9yIHNwZWNpZmllZFwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrc1RvUnVuID0gc3RhY2tzVG9SdW4ubWFwKChzdGFjaykgPT5cbiAgICAgIHRoaXMuZ2V0U3RhY2tFeGVjdXRvcihzdGFjaywgb3B0cylcbiAgICApO1xuXG4gICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5zdGFja3NUb1J1bi5tYXAoYXN5bmMgKHMpID0+IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcy5mZXRjaE91dHB1dHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbcy5zdGFjay5uYW1lXTogb3V0cHV0LFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICApO1xuXG4gICAgcmV0dXJuIG91dHB1dHMucmVkdWNlKFxuICAgICAgKGFjYywgY3VycikgPT4gKHsgLi4uYWNjLCAuLi5jdXJyIH0pLFxuICAgICAge31cbiAgICApIGFzIE5lc3RlZFRlcnJhZm9ybU91dHB1dHM7XG4gIH1cbn1cbiJdfQ==