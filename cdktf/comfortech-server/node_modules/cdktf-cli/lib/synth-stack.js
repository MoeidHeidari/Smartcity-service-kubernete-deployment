"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SynthStack = void 0;
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const chalk = __importStar(require("chalk"));
const indent_string_1 = __importDefault(require("indent-string"));
const cdktf_1 = require("cdktf");
const perf_hooks_1 = require("perf_hooks");
const checkpoint_1 = require("./checkpoint");
const util_1 = require("./util");
const chalkColour = new chalk.Instance();
class SynthStack {
    static async synth(abortSignal, command, outdir, workingDirectory = process.cwd(), graceful = false, // will not exit the process but rethrow the error instead
    synthOrigin) {
        // start performance timer
        const startTime = perf_hooks_1.performance.now();
        const isDirectory = (source) => fs.lstatSync(source).isDirectory();
        const getDirectories = (source) => {
            if (!fs.existsSync(source))
                return [];
            return fs
                .readdirSync(source)
                .map((name) => path.join(source, name))
                .filter(isDirectory);
        };
        const existingDirectories = getDirectories(path.join(outdir, cdktf_1.Manifest.stacksFolder));
        const env = Object.fromEntries(Object.entries(process.env).filter(
        // We don't want to pass Terraform variables to the synth command since they should only be used at execution time
        ([key]) => !key.startsWith("TF_VAR_")));
        // Increases the default memory available to Node.js when synthesizing a TypeScript CDK project.
        if (env.NODE_OPTIONS &&
            !env.NODE_OPTIONS.includes(`--max-old-space-size`)) {
            console.warn(`found NODE_OPTIONS environment variable without a setting for --max-old-space-size.
The synthesizing step for TypeScript may need an increased amount of memory if multiple large providers
are used with locally generated bindings. You can ignore this if you don't use CDKTF with TypeScript.
If not present, the cdktf-cli sets it to NODE_OPTIONS="--max-old-space-size=4048" by default. But as
your environment already contains a NODE_OPTIONS variable, we won't override it. Hence, the app command
might fail while synthesizing with an out of memory error.`);
        }
        else {
            // increase memory to allow ts-node (when using TypeScript) to handle large amounts of generated code in memory
            env.NODE_OPTIONS = "--max-old-space-size=4048";
        }
        try {
            await util_1.shell(command, [], {
                shell: true,
                env: {
                    ...env,
                    CDKTF_OUTDIR: outdir,
                    CDKTF_CONTINUE_SYNTH_ON_ERROR_ANNOTATIONS: "true",
                },
                cwd: workingDirectory,
                signal: abortSignal,
            });
        }
        catch (e) {
            const errorOutput = chalkColour `{redBright cdktf encountered an error while synthesizing}

Synth command: {blue ${command}}
Error:         {redBright ${e.message}}
${e.stderr
                ? chalkColour `
Command output on stderr:

{dim ${indent_string_1.default(e.stderr, 4)}}
`
                : ""}
${e.stdout
                ? chalkColour `
Command output on stdout:

{dim ${indent_string_1.default(e.stdout, 4)}}
`
                : ""}`;
            await this.synthErrorTelemetry(synthOrigin);
            if (graceful) {
                e.errorOutput = errorOutput;
                throw e;
            }
            console.error(errorOutput);
            process.exit(1);
        }
        if (!(await fs.pathExists(path.join(outdir, cdktf_1.Manifest.fileName)))) {
            const errorMessage = `ERROR: synthesis failed, app expected to create "${outdir}/${cdktf_1.Manifest.fileName}"`;
            if (graceful) {
                throw new Error(errorMessage);
            }
            console.error(errorMessage);
            process.exit(1);
        }
        // end performance timer
        const endTime = perf_hooks_1.performance.now();
        const stacks = [];
        const manifest = JSON.parse(fs.readFileSync(path.join(outdir, cdktf_1.Manifest.fileName)).toString());
        for (const stackName in manifest.stacks) {
            const stack = manifest.stacks[stackName];
            const filePath = path.join(outdir, stack.synthesizedStackPath);
            const jsonContent = JSON.parse(fs.readFileSync(filePath).toString());
            stacks.push({
                ...stack,
                workingDirectory: path.join(outdir, stack.workingDirectory),
                content: JSON.stringify(jsonContent, null, 2),
            });
        }
        await this.synthTelemetry(endTime - startTime, stacks, synthOrigin);
        if (stacks.length === 0) {
            console.error("ERROR: No Terraform code synthesized.");
        }
        const stackNames = stacks.map((s) => s.name);
        const orphanedDirectories = existingDirectories.filter((e) => !stackNames.includes(path.basename(e)));
        for (const orphanedDirectory of orphanedDirectories) {
            fs.rmSync(orphanedDirectory, { recursive: true });
        }
        return stacks;
    }
    static async synthTelemetry(totalTime, stacks, synthOrigin) {
        await checkpoint_1.sendTelemetry("synth", {
            totalTime: totalTime,
            synthOrigin,
            stackMetadata: stacks.map((stack) => JSON.parse(stack.content)["//"].metadata),
        });
    }
    static async synthErrorTelemetry(synthOrigin) {
        await checkpoint_1.sendTelemetry("synth", { error: true, synthOrigin });
    }
}
exports.SynthStack = SynthStack;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGgtc3RhY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzeW50aC1zdGFjay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNkNBQStCO0FBQy9CLDJDQUE2QjtBQUM3Qiw2Q0FBK0I7QUFDL0Isa0VBQXlDO0FBQ3pDLGlDQUF3RTtBQUN4RSwyQ0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLGlDQUErQjtBQUUvQixNQUFNLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQWlCekMsTUFBYSxVQUFVO0lBQ2QsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQ3ZCLFdBQXdCLEVBQ3hCLE9BQWUsRUFDZixNQUFjLEVBQ2QsZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUNoQyxRQUFRLEdBQUcsS0FBSyxFQUFFLDBEQUEwRDtJQUM1RSxXQUF5QjtRQUV6QiwwQkFBMEI7UUFDMUIsTUFBTSxTQUFTLEdBQUcsd0JBQVcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUVwQyxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQWMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMzRSxNQUFNLGNBQWMsR0FBRyxDQUFDLE1BQWMsRUFBRSxFQUFFO1lBQ3hDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQztnQkFBRSxPQUFPLEVBQUUsQ0FBQztZQUN0QyxPQUFPLEVBQUU7aUJBQ04sV0FBVyxDQUFDLE1BQU0sQ0FBQztpQkFDbkIsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDdEMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsQ0FBQztRQUVGLE1BQU0sbUJB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QUFDO1FBRUYsS0FBSyxNQUFNLGlCQUFpQixJQUFJLG1CQUFtQixFQUFFO1lBQ25ELEVBQUUsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNuRDtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsQ0FDaEMsU0FBaUIsRUFDakIsTUFBMEIsRUFDMUIsV0FBeUI7UUFFekIsTUFBTSwwQkFBYSxDQUFDLE9BQU8sRUFBRTtZQUMzQixTQUFTLEVBQUUsU0FBUztZQUNwQixXQUFXO1lBQ1gsYUFBYSxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQ3ZCLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQ3BEO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsV0FBeUI7UUFDL0QsTUFBTSwwQkFBYSxDQUFDLE9BQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUM3RCxDQUFDO0NBQ0Y7QUE1SkQsZ0NBNEpDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCBpbmRlbnRTdHJpbmcgZnJvbSBcImluZGVudC1zdHJpbmdcIjtcbmltcG9ydCB7IE1hbmlmZXN0LCBTdGFja01hbmlmZXN0LCBUZXJyYWZvcm1TdGFja01ldGFkYXRhIH0gZnJvbSBcImNka3RmXCI7XG5pbXBvcnQgeyBwZXJmb3JtYW5jZSB9IGZyb20gXCJwZXJmX2hvb2tzXCI7XG5pbXBvcnQgeyBzZW5kVGVsZW1ldHJ5IH0gZnJvbSBcIi4vY2hlY2twb2ludFwiO1xuaW1wb3J0IHsgc2hlbGwgfSBmcm9tIFwiLi91dGlsXCI7XG5cbmNvbnN0IGNoYWxrQ29sb3VyID0gbmV3IGNoYWxrLkluc3RhbmNlKCk7XG5cbmludGVyZmFjZSBTeW50aGVzaXplZFN0YWNrTWV0YWRhdGEge1xuICBcIi8vXCI/OiB7IFtrZXk6IHN0cmluZ106IFRlcnJhZm9ybVN0YWNrTWV0YWRhdGEgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW50aGVzaXplZFN0YWNrIGV4dGVuZHMgU3RhY2tNYW5pZmVzdCB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1hbmlmZXN0SnNvbiB7XG4gIHZlcnNpb246IHN0cmluZztcbiAgc3RhY2tzOiBTdGFja01hbmlmZXN0W107XG59XG5cbnR5cGUgU3ludGhPcmlnaW4gPSBcIndhdGNoXCI7XG5cbmV4cG9ydCBjbGFzcyBTeW50aFN0YWNrIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBzeW50aChcbiAgICBhYm9ydFNpZ25hbDogQWJvcnRTaWduYWwsXG4gICAgY29tbWFuZDogc3RyaW5nLFxuICAgIG91dGRpcjogc3RyaW5nLFxuICAgIHdvcmtpbmdEaXJlY3RvcnkgPSBwcm9jZXNzLmN3ZCgpLFxuICAgIGdyYWNlZnVsID0gZmFsc2UsIC8vIHdpbGwgbm90IGV4aXQgdGhlIHByb2Nlc3MgYnV0IHJldGhyb3cgdGhlIGVycm9yIGluc3RlYWRcbiAgICBzeW50aE9yaWdpbj86IFN5bnRoT3JpZ2luXG4gICk6IFByb21pc2U8U3ludGhlc2l6ZWRTdGFja1tdPiB7XG4gICAgLy8gc3RhcnQgcGVyZm9ybWFuY2UgdGltZXJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGNvbnN0IGlzRGlyZWN0b3J5ID0gKHNvdXJjZTogc3RyaW5nKSA9PiBmcy5sc3RhdFN5bmMoc291cmNlKS5pc0RpcmVjdG9yeSgpO1xuICAgIGNvbnN0IGdldERpcmVjdG9yaWVzID0gKHNvdXJjZTogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc291cmNlKSkgcmV0dXJuIFtdO1xuICAgICAgcmV0dXJuIGZzXG4gICAgICAgIC5yZWFkZGlyU3luYyhzb3VyY2UpXG4gICAgICAgIC5tYXAoKG5hbWUpID0+IHBhdGguam9pbihzb3VyY2UsIG5hbWUpKVxuICAgICAgICAuZmlsdGVyKGlzRGlyZWN0b3J5KTtcbiAgICB9O1xuXG4gICAgY29uc3QgZXhpc3RpbmdEaXJlY3RvcmllcyA9IGdldERpcmVjdG9yaWVzKFxuICAgICAgcGF0aC5qb2luKG91dGRpciwgTWFuaWZlc3Quc3RhY2tzRm9sZGVyKVxuICAgICk7XG5cbiAgICBjb25zdCBlbnYgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhwcm9jZXNzLmVudikuZmlsdGVyKFxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHBhc3MgVGVycmFmb3JtIHZhcmlhYmxlcyB0byB0aGUgc3ludGggY29tbWFuZCBzaW5jZSB0aGV5IHNob3VsZCBvbmx5IGJlIHVzZWQgYXQgZXhlY3V0aW9uIHRpbWVcbiAgICAgICAgKFtrZXldKSA9PiAha2V5LnN0YXJ0c1dpdGgoXCJURl9WQVJfXCIpXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIEluY3JlYXNlcyB0aGUgZGVmYXVsdCBtZW1vcnkgYXZhaWxhYmxlIHRvIE5vZGUuanMgd2hlbiBzeW50aGVzaXppbmcgYSBUeXBlU2NyaXB0IENESyBwcm9qZWN0LlxuICAgIGlmIChcbiAgICAgIGVudi5OT0RFX09QVElPTlMgJiZcbiAgICAgICFlbnYuTk9ERV9PUFRJT05TLmluY2x1ZGVzKGAtLW1heC1vbGQtc3BhY2Utc2l6ZWApXG4gICAgKSB7XG4gICAgICBjb25zb2xlLndhcm4oYGZvdW5kIE5PREVfT1BUSU9OUyBlbnZpcm9ubWVudCB2YXJpYWJsZSB3aXRob3V0IGEgc2V0dGluZyBmb3IgLS1tYXgtb2xkLXNwYWNlLXNpemUuXG5UaGUgc3ludGhlc2l6aW5nIHN0ZXAgZm9yIFR5cGVTY3JpcHQgbWF5IG5lZWQgYW4gaW5jcmVhc2VkIGFtb3VudCBvZiBtZW1vcnkgaWYgbXVsdGlwbGUgbGFyZ2UgcHJvdmlkZXJzXG5hcmUgdXNlZCB3aXRoIGxvY2FsbHkgZ2VuZXJhdGVkIGJpbmRpbmdzLiBZb3UgY2FuIGlnbm9yZSB0aGlzIGlmIHlvdSBkb24ndCB1c2UgQ0RLVEYgd2l0aCBUeXBlU2NyaXB0LlxuSWYgbm90IHByZXNlbnQsIHRoZSBjZGt0Zi1jbGkgc2V0cyBpdCB0byBOT0RFX09QVElPTlM9XCItLW1heC1vbGQtc3BhY2Utc2l6ZT00MDQ4XCIgYnkgZGVmYXVsdC4gQnV0IGFzXG55b3VyIGVudmlyb25tZW50IGFscmVhZHkgY29udGFpbnMgYSBOT0RFX09QVElPTlMgdmFyaWFibGUsIHdlIHdvbid0IG92ZXJyaWRlIGl0LiBIZW5jZSwgdGhlIGFwcCBjb21tYW5kXG5taWdodCBmYWlsIHdoaWxlIHN5bnRoZXNpemluZyB3aXRoIGFuIG91dCBvZiBtZW1vcnkgZXJyb3IuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluY3JlYXNlIG1lbW9yeSB0byBhbGxvdyB0cy1ub2RlICh3aGVuIHVzaW5nIFR5cGVTY3JpcHQpIHRvIGhhbmRsZSBsYXJnZSBhbW91bnRzIG9mIGdlbmVyYXRlZCBjb2RlIGluIG1lbW9yeVxuICAgICAgZW52Lk5PREVfT1BUSU9OUyA9IFwiLS1tYXgtb2xkLXNwYWNlLXNpemU9NDA0OFwiO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBzaGVsbChjb21tYW5kLCBbXSwge1xuICAgICAgICBzaGVsbDogdHJ1ZSxcbiAgICAgICAgZW52OiB7XG4gICAgICAgICAgLi4uZW52LFxuICAgICAgICAgIENES1RGX09VVERJUjogb3V0ZGlyLFxuICAgICAgICAgIENES1RGX0NPTlRJTlVFX1NZTlRIX09OX0VSUk9SX0FOTk9UQVRJT05TOiBcInRydWVcIiwgLy8gd2Ugd2FudCB0byBkaXNwbGF5IHRoZSBlcnJvcnMgb3Vyc2VsdmVzXG4gICAgICAgIH0sXG4gICAgICAgIGN3ZDogd29ya2luZ0RpcmVjdG9yeSxcbiAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IGVycm9yT3V0cHV0ID0gY2hhbGtDb2xvdXJge3JlZEJyaWdodCBjZGt0ZiBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBzeW50aGVzaXppbmd9XG5cblN5bnRoIGNvbW1hbmQ6IHtibHVlICR7Y29tbWFuZH19XG5FcnJvcjogICAgICAgICB7cmVkQnJpZ2h0ICR7ZS5tZXNzYWdlfX1cbiR7XG4gIGUuc3RkZXJyXG4gICAgPyBjaGFsa0NvbG91cmBcbkNvbW1hbmQgb3V0cHV0IG9uIHN0ZGVycjpcblxue2RpbSAke2luZGVudFN0cmluZyhlLnN0ZGVyciwgNCl9fVxuYFxuICAgIDogXCJcIlxufVxuJHtcbiAgZS5zdGRvdXRcbiAgICA/IGNoYWxrQ29sb3VyYFxuQ29tbWFuZCBvdXRwdXQgb24gc3Rkb3V0OlxuXG57ZGltICR7aW5kZW50U3RyaW5nKGUuc3Rkb3V0LCA0KX19XG5gXG4gICAgOiBcIlwiXG59YDtcbiAgICAgIGF3YWl0IHRoaXMuc3ludGhFcnJvclRlbGVtZXRyeShzeW50aE9yaWdpbik7XG4gICAgICBpZiAoZ3JhY2VmdWwpIHtcbiAgICAgICAgZS5lcnJvck91dHB1dCA9IGVycm9yT3V0cHV0O1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihlcnJvck91dHB1dCk7XG4gICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuXG4gICAgaWYgKCEoYXdhaXQgZnMucGF0aEV4aXN0cyhwYXRoLmpvaW4ob3V0ZGlyLCBNYW5pZmVzdC5maWxlTmFtZSkpKSkge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gYEVSUk9SOiBzeW50aGVzaXMgZmFpbGVkLCBhcHAgZXhwZWN0ZWQgdG8gY3JlYXRlIFwiJHtvdXRkaXJ9LyR7TWFuaWZlc3QuZmlsZU5hbWV9XCJgO1xuICAgICAgaWYgKGdyYWNlZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIC8vIGVuZCBwZXJmb3JtYW5jZSB0aW1lclxuICAgIGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgIGNvbnN0IHN0YWNrczogU3ludGhlc2l6ZWRTdGFja1tdID0gW107XG4gICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKFxuICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihvdXRkaXIsIE1hbmlmZXN0LmZpbGVOYW1lKSkudG9TdHJpbmcoKVxuICAgICkgYXMgTWFuaWZlc3RKc29uO1xuXG4gICAgZm9yIChjb25zdCBzdGFja05hbWUgaW4gbWFuaWZlc3Quc3RhY2tzKSB7XG4gICAgICBjb25zdCBzdGFjayA9IG1hbmlmZXN0LnN0YWNrc1tzdGFja05hbWVdO1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4ob3V0ZGlyLCBzdGFjay5zeW50aGVzaXplZFN0YWNrUGF0aCk7XG4gICAgICBjb25zdCBqc29uQ29udGVudDogU3ludGhlc2l6ZWRTdGFja01ldGFkYXRhID0gSlNPTi5wYXJzZShcbiAgICAgICAgZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoKS50b1N0cmluZygpXG4gICAgICApO1xuICAgICAgc3RhY2tzLnB1c2goe1xuICAgICAgICAuLi5zdGFjayxcbiAgICAgICAgd29ya2luZ0RpcmVjdG9yeTogcGF0aC5qb2luKG91dGRpciwgc3RhY2sud29ya2luZ0RpcmVjdG9yeSksXG4gICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGpzb25Db250ZW50LCBudWxsLCAyKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuc3ludGhUZWxlbWV0cnkoZW5kVGltZSAtIHN0YXJ0VGltZSwgc3RhY2tzLCBzeW50aE9yaWdpbik7XG5cbiAgICBpZiAoc3RhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SOiBObyBUZXJyYWZvcm0gY29kZSBzeW50aGVzaXplZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tOYW1lcyA9IHN0YWNrcy5tYXAoKHMpID0+IHMubmFtZSk7XG4gICAgY29uc3Qgb3JwaGFuZWREaXJlY3RvcmllcyA9IGV4aXN0aW5nRGlyZWN0b3JpZXMuZmlsdGVyKFxuICAgICAgKGUpID0+ICFzdGFja05hbWVzLmluY2x1ZGVzKHBhdGguYmFzZW5hbWUoZSkpXG4gICAgKTtcblxuICAgIGZvciAoY29uc3Qgb3JwaGFuZWREaXJlY3Rvcnkgb2Ygb3JwaGFuZWREaXJlY3Rvcmllcykge1xuICAgICAgZnMucm1TeW5jKG9ycGhhbmVkRGlyZWN0b3J5LCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBzeW50aFRlbGVtZXRyeShcbiAgICB0b3RhbFRpbWU6IG51bWJlcixcbiAgICBzdGFja3M6IFN5bnRoZXNpemVkU3RhY2tbXSxcbiAgICBzeW50aE9yaWdpbj86IFN5bnRoT3JpZ2luXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHNlbmRUZWxlbWV0cnkoXCJzeW50aFwiLCB7XG4gICAgICB0b3RhbFRpbWU6IHRvdGFsVGltZSxcbiAgICAgIHN5bnRoT3JpZ2luLFxuICAgICAgc3RhY2tNZXRhZGF0YTogc3RhY2tzLm1hcChcbiAgICAgICAgKHN0YWNrKSA9PiBKU09OLnBhcnNlKHN0YWNrLmNvbnRlbnQpW1wiLy9cIl0ubWV0YWRhdGFcbiAgICAgICksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGFzeW5jIHN5bnRoRXJyb3JUZWxlbWV0cnkoc3ludGhPcmlnaW4/OiBTeW50aE9yaWdpbikge1xuICAgIGF3YWl0IHNlbmRUZWxlbWV0cnkoXCJzeW50aFwiLCB7IGVycm9yOiB0cnVlLCBzeW50aE9yaWdpbiB9KTtcbiAgfVxufVxuIl19