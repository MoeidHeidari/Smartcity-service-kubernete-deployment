"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineDeps = exports.init = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs-extra"));
const utilities_1 = require("../bin/cmds/helper/utilities");
const errors_1 = require("./errors");
const sscaff_1 = require("sscaff");
const features_1 = require("cdktf/lib/features");
const pkg = utilities_1.readPackageJson();
const constructsVersion = pkg.dependencies.constructs;
async function init({ cdktfVersion, destination, dist, projectId, projectInfo, templatePath, sendCrashReports, }) {
    const deps = await determineDeps(cdktfVersion, dist);
    const futureFlags = Object.entries(features_1.FUTURE_FLAGS)
        .map(([key, value]) => `    "${key}": "${value}"`)
        .join(`,\n`);
    await sscaff_1.sscaff(templatePath, destination, {
        ...deps,
        ...projectInfo,
        futureFlags,
        projectId,
        sendCrashReports,
    });
}
exports.init = init;
async function determineDeps(version = pkg.version, dist) {
    // TS: cdktf-0.10.1-dev.2160938258
    // Py: cdktf-0.10.1.dev1658821493.tar.gz
    const pythonVersion = version
        .replace(/-pre\./g, ".dev")
        .replace(/-dev\./g, ".dev");
    if (dist) {
        const ret = {
            npm_cdktf: path.resolve(dist, "js", `cdktf@${version}.jsii.tgz`),
            npm_cdktf_cli: path.resolve(dist, "js", `cdktf-cli-${version}.tgz`),
            pypi_cdktf: path.resolve(dist, "python", `cdktf-${pythonVersion}.tar.gz`),
            mvn_cdktf: path.resolve(dist, "java", `com/hashicorp/cdktf/${version}/cdktf-${version}.jar`),
            nuget_cdktf: path.resolve(dist, "dotnet", `HashiCorp.Cdktf.${version}.nupkg`),
            go_cdktf: path.resolve(dist, "go", `cdktf`),
        };
        for (const file of Object.values(ret)) {
            if (!(await fs.pathExists(file))) {
                throw errors_1.Errors.Internal(`unable to find ${file} under the "dist" directory (${dist})`, { version });
            }
        }
        const versions = {
            cdktf_version: version,
            constructs_version: constructsVersion,
        };
        return {
            ...ret,
            ...versions,
        };
    }
    if (version === "0.0.0") {
        throw errors_1.Errors.Usage(`cannot use version 0.0.0, use --cdktf-version, --dist or CDKTF_DIST to install from a "dist" directory`, {});
    }
    // determine if we want a specific pinned version or a version range we take
    // a pinned version if version includes a hyphen which means it is a
    // pre-release (e.g. "0.12.0-pre.e6834d3"). otherwise, we require a caret
    // version.
    const ver = version.includes("-") ? version : `^${version}`;
    return {
        cdktf_version: version,
        constructs_version: constructsVersion,
        npm_cdktf: `cdktf@${ver}`,
        npm_cdktf_cli: `cdktf-cli@${ver}`,
        pypi_cdktf: `cdktf~=${pythonVersion}`,
        mvn_cdktf: version,
        nuget_cdktf: version,
        go_cdktf: `v${version}`,
    };
}
exports.determineDeps = determineDeps;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDJDQUE2QjtBQUM3Qiw2Q0FBK0I7QUFDL0IsNERBQStEO0FBQy9ELHFDQUFrQztBQUVsQyxtQ0FBZ0M7QUFDaEMsaURBQWtEO0FBRWxELE1BQU0sR0FBRyxHQUFHLDJCQUFlLEVBQUUsQ0FBQztBQUM5QixNQUFNLGlCQUFpQixHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDO0FBdUIvQyxLQUFLLFVBQVUsSUFBSSxDQUFDLEVBQ3pCLFlBQVksRUFDWixXQUFXLEVBQ1gsSUFBSSxFQUNKLFNBQVMsRUFDVCxXQUFXLEVBQ1gsWUFBWSxFQUNaLGdCQUFnQixHQUNQO0lBQ1QsTUFBTSxJQUFJLEdBQVEsTUFBTSxhQUFhLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRTFELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsdUJBQVksQ0FBQztTQUM3QyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsUUFBUSxHQUFHLE9BQU8sS0FBSyxHQUFHLENBQUM7U0FDakQsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWYsTUFBTSxlQUFNLENBQUMsWUFBWSxFQUFFLFdBQVcsRUFBRTtRQUN0QyxHQUFHLElBQUk7UUFDUCxHQUFHLFdBQVc7UUFDZCxXQUFXO1FBQ1gsU0FBUztRQUNULGdCQUFnQjtLQUNqQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBdEJELG9CQXNCQztBQVlNLEtBQUssVUFBVSxhQUFhLENBQ2pDLFVBQWtCLEdBQUcsQ0FBQyxPQUFPLEVBQzdCLElBQWE7SUFFYixrQ0FBa0M7SUFDbEMsd0NBQXdDO0lBQ3hDLE1BQU0sYUFBYSxHQUFHLE9BQU87U0FDMUIsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUM7U0FDMUIsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUU5QixJQUFJLElBQUksRUFBRTtRQUNSLE1BQU0sR0FBRyxHQUFHO1lBQ1YsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLE9BQU8sV0FBVyxDQUFDO1lBQ2hFLGFBQWEsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsYUFBYSxPQUFPLE1BQU0sQ0FBQztZQUNuRSxVQUFVLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFNBQVMsYUFBYSxTQUFTLENBQUM7WUFDekUsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQ3JCLElBQUksRUFDSixNQUFNLEVBQ04sdUJBQXVCLE9BQU8sVUFBVSxPQUFPLE1BQU0sQ0FDdEQ7WUFDRCxXQUFXLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FDdkIsSUFBSSxFQUNKLFFBQVEsRUFDUixtQkFBbUIsT0FBTyxRQUFRLENBQ25DO1lBQ0QsUUFBUSxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUM7U0FDNUMsQ0FBQztRQUVGLEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNyQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtnQkFDaEMsTUFBTSxlQUFNLENBQUMsUUFBUSxDQUNuQixrQkFBa0IsSUFBSSxnQ0FBZ0MsSUFBSSxHQUFHLEVBQzdELEVBQUUsT0FBTyxFQUFFLENBQ1osQ0FBQzthQUNIO1NBQ0Y7UUFFRCxNQUFNLFFBQVEsR0FBRztZQUNmLGFBQWEsRUFBRSxPQUFPO1lBQ3RCLGtCQUFrQixFQUFFLGlCQUFpQjtTQUN0QyxDQUFDO1FBRUYsT0FBTztZQUNMLEdBQUcsR0FBRztZQUNOLEdBQUcsUUFBUTtTQUNaLENBQUM7S0FDSDtJQUVELElBQUksT0FBTyxLQUFLLE9BQU8sRUFBRTtRQUN2QixNQUFNLGVBQU0sQ0FBQyxLQUFLLENBQ2hCLHdHQUF3RyxFQUN4RyxFQUFFLENBQ0gsQ0FBQztLQUNIO0lBRUQsNEVBQTRFO0lBQzVFLG9FQUFvRTtJQUNwRSx5RUFBeUU7SUFDekUsV0FBVztJQUNYLE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLEVBQUUsQ0FBQztJQUU1RCxPQUFPO1FBQ0wsYUFBYSxFQUFFLE9BQU87UUFDdEIsa0JBQWtCLEVBQUUsaUJBQWlCO1FBQ3JDLFNBQVMsRUFBRSxTQUFTLEdBQUcsRUFBRTtRQUN6QixhQUFhLEVBQUUsYUFBYSxHQUFHLEVBQUU7UUFDakMsVUFBVSxFQUFFLFVBQVUsYUFBYSxFQUFFO1FBQ3JDLFNBQVMsRUFBRSxPQUFPO1FBQ2xCLFdBQVcsRUFBRSxPQUFPO1FBQ3BCLFFBQVEsRUFBRSxJQUFJLE9BQU8sRUFBRTtLQUN4QixDQUFDO0FBQ0osQ0FBQztBQXZFRCxzQ0F1RUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcbmltcG9ydCB7IHJlYWRQYWNrYWdlSnNvbiB9IGZyb20gXCIuLi9iaW4vY21kcy9oZWxwZXIvdXRpbGl0aWVzXCI7XG5pbXBvcnQgeyBFcnJvcnMgfSBmcm9tIFwiLi9lcnJvcnNcIjtcblxuaW1wb3J0IHsgc3NjYWZmIH0gZnJvbSBcInNzY2FmZlwiO1xuaW1wb3J0IHsgRlVUVVJFX0ZMQUdTIH0gZnJvbSBcImNka3RmL2xpYi9mZWF0dXJlc1wiO1xuXG5jb25zdCBwa2cgPSByZWFkUGFja2FnZUpzb24oKTtcbmNvbnN0IGNvbnN0cnVjdHNWZXJzaW9uID0gcGtnLmRlcGVuZGVuY2llcy5jb25zdHJ1Y3RzO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsUHJvamVjdCB7XG4gIERlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIE5hbWU6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW1vdGVQcm9qZWN0IGV4dGVuZHMgTG9jYWxQcm9qZWN0IHtcbiAgT3JnYW5pemF0aW9uTmFtZTogc3RyaW5nO1xuICBXb3Jrc3BhY2VOYW1lOiBzdHJpbmc7XG59XG5leHBvcnQgdHlwZSBQcm9qZWN0ID0gTG9jYWxQcm9qZWN0IHwgUmVtb3RlUHJvamVjdDtcblxuZXhwb3J0IHR5cGUgSW5pdEFyZ3MgPSB7XG4gIGNka3RmVmVyc2lvbj86IHN0cmluZztcbiAgZGVzdGluYXRpb246IHN0cmluZztcbiAgZGlzdD86IHN0cmluZztcbiAgcHJvamVjdElkOiBzdHJpbmc7XG4gIHByb2plY3RJbmZvOiBQcm9qZWN0O1xuICB0ZW1wbGF0ZVBhdGg6IHN0cmluZztcbiAgc2VuZENyYXNoUmVwb3J0czogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0KHtcbiAgY2RrdGZWZXJzaW9uLFxuICBkZXN0aW5hdGlvbixcbiAgZGlzdCxcbiAgcHJvamVjdElkLFxuICBwcm9qZWN0SW5mbyxcbiAgdGVtcGxhdGVQYXRoLFxuICBzZW5kQ3Jhc2hSZXBvcnRzLFxufTogSW5pdEFyZ3MpIHtcbiAgY29uc3QgZGVwczogYW55ID0gYXdhaXQgZGV0ZXJtaW5lRGVwcyhjZGt0ZlZlcnNpb24sIGRpc3QpO1xuXG4gIGNvbnN0IGZ1dHVyZUZsYWdzID0gT2JqZWN0LmVudHJpZXMoRlVUVVJFX0ZMQUdTKVxuICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCAgICBcIiR7a2V5fVwiOiBcIiR7dmFsdWV9XCJgKVxuICAgIC5qb2luKGAsXFxuYCk7XG5cbiAgYXdhaXQgc3NjYWZmKHRlbXBsYXRlUGF0aCwgZGVzdGluYXRpb24sIHtcbiAgICAuLi5kZXBzLFxuICAgIC4uLnByb2plY3RJbmZvLFxuICAgIGZ1dHVyZUZsYWdzLFxuICAgIHByb2plY3RJZCxcbiAgICBzZW5kQ3Jhc2hSZXBvcnRzLFxuICB9KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEZXBzIHtcbiAgbnBtX2Nka3RmOiBzdHJpbmc7XG4gIG5wbV9jZGt0Zl9jbGk6IHN0cmluZztcbiAgcHlwaV9jZGt0Zjogc3RyaW5nO1xuICBtdm5fY2RrdGY6IHN0cmluZztcbiAgbnVnZXRfY2RrdGY6IHN0cmluZztcbiAgZ29fY2RrdGY6IHN0cmluZztcbiAgY2RrdGZfdmVyc2lvbjogc3RyaW5nO1xuICBjb25zdHJ1Y3RzX3ZlcnNpb246IHN0cmluZztcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVEZXBzKFxuICB2ZXJzaW9uOiBzdHJpbmcgPSBwa2cudmVyc2lvbixcbiAgZGlzdD86IHN0cmluZ1xuKTogUHJvbWlzZTxEZXBzPiB7XG4gIC8vIFRTOiBjZGt0Zi0wLjEwLjEtZGV2LjIxNjA5MzgyNThcbiAgLy8gUHk6IGNka3RmLTAuMTAuMS5kZXYxNjU4ODIxNDkzLnRhci5nelxuICBjb25zdCBweXRob25WZXJzaW9uID0gdmVyc2lvblxuICAgIC5yZXBsYWNlKC8tcHJlXFwuL2csIFwiLmRldlwiKVxuICAgIC5yZXBsYWNlKC8tZGV2XFwuL2csIFwiLmRldlwiKTtcblxuICBpZiAoZGlzdCkge1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIG5wbV9jZGt0ZjogcGF0aC5yZXNvbHZlKGRpc3QsIFwianNcIiwgYGNka3RmQCR7dmVyc2lvbn0uanNpaS50Z3pgKSxcbiAgICAgIG5wbV9jZGt0Zl9jbGk6IHBhdGgucmVzb2x2ZShkaXN0LCBcImpzXCIsIGBjZGt0Zi1jbGktJHt2ZXJzaW9ufS50Z3pgKSxcbiAgICAgIHB5cGlfY2RrdGY6IHBhdGgucmVzb2x2ZShkaXN0LCBcInB5dGhvblwiLCBgY2RrdGYtJHtweXRob25WZXJzaW9ufS50YXIuZ3pgKSxcbiAgICAgIG12bl9jZGt0ZjogcGF0aC5yZXNvbHZlKFxuICAgICAgICBkaXN0LFxuICAgICAgICBcImphdmFcIixcbiAgICAgICAgYGNvbS9oYXNoaWNvcnAvY2RrdGYvJHt2ZXJzaW9ufS9jZGt0Zi0ke3ZlcnNpb259LmphcmBcbiAgICAgICksXG4gICAgICBudWdldF9jZGt0ZjogcGF0aC5yZXNvbHZlKFxuICAgICAgICBkaXN0LFxuICAgICAgICBcImRvdG5ldFwiLFxuICAgICAgICBgSGFzaGlDb3JwLkNka3RmLiR7dmVyc2lvbn0ubnVwa2dgXG4gICAgICApLFxuICAgICAgZ29fY2RrdGY6IHBhdGgucmVzb2x2ZShkaXN0LCBcImdvXCIsIGBjZGt0ZmApLFxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgT2JqZWN0LnZhbHVlcyhyZXQpKSB7XG4gICAgICBpZiAoIShhd2FpdCBmcy5wYXRoRXhpc3RzKGZpbGUpKSkge1xuICAgICAgICB0aHJvdyBFcnJvcnMuSW50ZXJuYWwoXG4gICAgICAgICAgYHVuYWJsZSB0byBmaW5kICR7ZmlsZX0gdW5kZXIgdGhlIFwiZGlzdFwiIGRpcmVjdG9yeSAoJHtkaXN0fSlgLFxuICAgICAgICAgIHsgdmVyc2lvbiB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdmVyc2lvbnMgPSB7XG4gICAgICBjZGt0Zl92ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgY29uc3RydWN0c192ZXJzaW9uOiBjb25zdHJ1Y3RzVmVyc2lvbixcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJldCxcbiAgICAgIC4uLnZlcnNpb25zLFxuICAgIH07XG4gIH1cblxuICBpZiAodmVyc2lvbiA9PT0gXCIwLjAuMFwiKSB7XG4gICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgYGNhbm5vdCB1c2UgdmVyc2lvbiAwLjAuMCwgdXNlIC0tY2RrdGYtdmVyc2lvbiwgLS1kaXN0IG9yIENES1RGX0RJU1QgdG8gaW5zdGFsbCBmcm9tIGEgXCJkaXN0XCIgZGlyZWN0b3J5YCxcbiAgICAgIHt9XG4gICAgKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBpZiB3ZSB3YW50IGEgc3BlY2lmaWMgcGlubmVkIHZlcnNpb24gb3IgYSB2ZXJzaW9uIHJhbmdlIHdlIHRha2VcbiAgLy8gYSBwaW5uZWQgdmVyc2lvbiBpZiB2ZXJzaW9uIGluY2x1ZGVzIGEgaHlwaGVuIHdoaWNoIG1lYW5zIGl0IGlzIGFcbiAgLy8gcHJlLXJlbGVhc2UgKGUuZy4gXCIwLjEyLjAtcHJlLmU2ODM0ZDNcIikuIG90aGVyd2lzZSwgd2UgcmVxdWlyZSBhIGNhcmV0XG4gIC8vIHZlcnNpb24uXG4gIGNvbnN0IHZlciA9IHZlcnNpb24uaW5jbHVkZXMoXCItXCIpID8gdmVyc2lvbiA6IGBeJHt2ZXJzaW9ufWA7XG5cbiAgcmV0dXJuIHtcbiAgICBjZGt0Zl92ZXJzaW9uOiB2ZXJzaW9uLFxuICAgIGNvbnN0cnVjdHNfdmVyc2lvbjogY29uc3RydWN0c1ZlcnNpb24sXG4gICAgbnBtX2Nka3RmOiBgY2RrdGZAJHt2ZXJ9YCxcbiAgICBucG1fY2RrdGZfY2xpOiBgY2RrdGYtY2xpQCR7dmVyfWAsXG4gICAgcHlwaV9jZGt0ZjogYGNka3Rmfj0ke3B5dGhvblZlcnNpb259YCxcbiAgICBtdm5fY2RrdGY6IHZlcnNpb24sXG4gICAgbnVnZXRfY2RrdGY6IHZlcnNpb24sXG4gICAgZ29fY2RrdGY6IGB2JHt2ZXJzaW9ufWAsXG4gIH07XG59XG4iXX0=