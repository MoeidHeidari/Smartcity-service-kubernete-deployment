"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageManager = void 0;
const provider_generator_1 = require("@cdktf/provider-generator");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
const util_1 = require("../util");
const xml_js_1 = require("xml-js");
const errors_1 = require("../errors");
const fs = __importStar(require("fs-extra"));
/**
 * manages installing, updating, and removing dependencies
 * in the package system used by the target language of a CDKTF
 * project
 */
class PackageManager {
    constructor(workingDirectory) {
        this.workingDirectory = workingDirectory;
    }
    static forLanguage(language, workingDirectory) {
        switch (language) {
            case provider_generator_1.Language.GO:
                return new GoPackageManager(workingDirectory);
            case provider_generator_1.Language.TYPESCRIPT:
                return new NodePackageManager(workingDirectory);
            case provider_generator_1.Language.PYTHON:
                return new PythonPackageManager(workingDirectory);
            case provider_generator_1.Language.CSHARP:
                return new NugetPackageManager(workingDirectory);
            case provider_generator_1.Language.JAVA:
                return new MavenPackageManager(workingDirectory);
            default:
                throw new Error(`Unknown language: ${language}`);
        }
    }
}
exports.PackageManager = PackageManager;
class NodePackageManager extends PackageManager {
    hasYarnLockfile() {
        return fs_extra_1.existsSync(path_1.default.join(this.workingDirectory, "yarn.lock"));
    }
    async addPackage(packageName, packageVersion) {
        console.log(`Adding package ${packageName} @ ${packageVersion}`);
        // probe for package-lock.json or yarn.lock
        let command = "npm";
        let args = ["install"];
        if (this.hasYarnLockfile()) {
            command = "yarn";
            args = ["add"];
        }
        args.push(packageVersion ? packageName + "@" + packageVersion : packageName);
        console.log(`Installing package ${packageName} @ ${packageVersion} using ${command}.`);
        await util_1.exec(command, args, { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
}
class PythonPackageManager extends PackageManager {
    get appCommand() {
        try {
            return JSON.parse(fs.readFileSync(path_1.default.resolve(this.workingDirectory, "cdktf.json"), "utf8"))["app"];
        }
        catch (e) {
            throw errors_1.Errors.Usage(`Could not find find and parse cdktf.json in ${this.workingDirectory}`);
        }
    }
    async addPackage(packageName, packageVersion) {
        const usePipenv = this.appCommand.includes("pipenv");
        if (usePipenv) {
            console.log(`Installing package ${packageName} @ ${packageVersion} using pipenv.`);
            await util_1.exec("pipenv", ["install", `${packageName}~=${packageVersion}`], {
                cwd: this.workingDirectory,
                env: {
                    ...process.env,
                    PIPENV_QUIET: "1",
                },
                stdio: ["inherit", 1, 1],
            });
            console.log("Package installed.");
        }
        else {
            console.log(`Installing package ${packageName} @ ${packageVersion} using pip.`);
            const requirementsFilePath = path_1.default.join(this.workingDirectory, "requirements.txt");
            if (!fs.existsSync(requirementsFilePath)) {
                throw errors_1.Errors.Usage(`Could not find requirements.txt in ${this.workingDirectory}`);
            }
            const requirements = await fs.readFile(requirementsFilePath, "utf8");
            if (requirements.includes(packageName)) {
                console.log(`Package ${packageName} already installed. Skipping installation.`);
                return;
            }
            const newRequirements = requirements +
                `\n${packageName}${packageVersion ? `~=${packageVersion}` : ""}`;
            await fs.writeFile(requirementsFilePath, newRequirements, "utf8");
            await util_1.exec("pip", ["install", "-r", "requirements.txt"], {
                cwd: this.workingDirectory,
                stdio: ["inherit", 1, 1],
            });
            console.log("Package installed.");
        }
    }
}
class NugetPackageManager extends PackageManager {
    async addPackage(packageName, packageVersion) {
        const command = "dotnet";
        const args = ["add", "package", packageName];
        if (packageVersion) {
            args.push("--version", packageVersion);
        }
        console.log(`Installing package ${packageName} @ ${packageVersion} using "${command} ${args.join(" ")}".`);
        await util_1.exec(command, args, { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
}
class MavenPackageManager extends PackageManager {
    async addPackage(packageName, packageVersion = "LATEST" // the latest option is deprecated in maven 3.5
    ) {
        var _a, _b, _c, _d, _e;
        console.log(`Adding ${packageName} @ ${packageVersion} to pom.xml`);
        // Assert pom.xml exists
        const pomPath = path_1.default.join(this.workingDirectory, "pom.xml");
        if (!fs_extra_1.existsSync(pomPath)) {
            throw errors_1.Errors.Usage("No pom.xml found in current working directory. Please run the command from the root of your project.");
        }
        const pom = await fs.readFile(pomPath, "utf8");
        const pomXml = (await xml_js_1.xml2js(pom, {}));
        // Mutate dependencies
        const nameParts = packageName.split(".");
        const groupId = nameParts.slice(0, nameParts.length - 1).join(".");
        const artifactId = nameParts[nameParts.length - 1];
        const newDependency = (await xml_js_1.xml2js(`<dependency>
    <groupId>${groupId}</groupId>
    <artifactId>${artifactId}</artifactId>
    <version>${packageVersion}</version>
</dependency>`));
        (_e = (_d = (_c = (_b = (_a = pomXml.elements) === null || _a === void 0 ? void 0 : _a.find((el) => el.name === "project")) === null || _b === void 0 ? void 0 : _b.elements) === null || _c === void 0 ? void 0 : _c.find((el) => el.name === "dependencies")) === null || _d === void 0 ? void 0 : _d.elements) === null || _e === void 0 ? void 0 : _e.push(newDependency.elements[0]);
        // Write new pom.xml
        await fs.writeFile(pomPath, xml_js_1.js2xml(pomXml, { spaces: 2 }));
        // Install
        await util_1.exec("mvn", ["install"], { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
}
class GoPackageManager extends PackageManager {
    async addPackage(packageName, packageVersion) {
        console.log(`Adding package ${packageName} @ ${packageVersion}`);
        // Install
        await util_1.exec("go", ["get", packageName], { cwd: this.workingDirectory });
        console.log("Package installed.");
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFja2FnZS1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFja2FnZS1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrRUFBcUQ7QUFDckQsdUNBQXNDO0FBQ3RDLGdEQUF3QjtBQUN4QixrQ0FBK0I7QUFDL0IsbUNBQWlEO0FBQ2pELHNDQUFtQztBQUNuQyw2Q0FBK0I7QUFFL0I7Ozs7R0FJRztBQUNILE1BQXNCLGNBQWM7SUFDbEMsWUFBK0IsZ0JBQXdCO1FBQXhCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBUTtJQUFHLENBQUM7SUFFcEQsTUFBTSxDQUFDLFdBQVcsQ0FDdkIsUUFBa0IsRUFDbEIsZ0JBQXdCO1FBRXhCLFFBQVEsUUFBUSxFQUFFO1lBQ2hCLEtBQUssNkJBQVEsQ0FBQyxFQUFFO2dCQUNkLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2hELEtBQUssNkJBQVEsQ0FBQyxVQUFVO2dCQUN0QixPQUFPLElBQUksa0JBQWtCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUNsRCxLQUFLLDZCQUFRLENBQUMsTUFBTTtnQkFDbEIsT0FBTyxJQUFJLG9CQUFvQixDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDcEQsS0FBSyw2QkFBUSxDQUFDLE1BQU07Z0JBQ2xCLE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ25ELEtBQUssNkJBQVEsQ0FBQyxJQUFJO2dCQUNoQixPQUFPLElBQUksbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUNuRDtnQkFDRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQ3BEO0lBQ0gsQ0FBQztDQVFGO0FBN0JELHdDQTZCQztBQUVELE1BQU0sa0JBQW1CLFNBQVEsY0FBYztJQUNyQyxlQUFlO1FBQ3JCLE9BQU8scUJBQVUsQ0FB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QW9CLENBQUMsQ0FBQztJQUNwQyxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMYW5ndWFnZSB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5pbXBvcnQgeyBleGlzdHNTeW5jIH0gZnJvbSBcImZzLWV4dHJhXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gXCIuLi91dGlsXCI7XG5pbXBvcnQgeyB4bWwyanMsIGpzMnhtbCwgRWxlbWVudCB9IGZyb20gXCJ4bWwtanNcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCIuLi9lcnJvcnNcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuXG4vKipcbiAqIG1hbmFnZXMgaW5zdGFsbGluZywgdXBkYXRpbmcsIGFuZCByZW1vdmluZyBkZXBlbmRlbmNpZXNcbiAqIGluIHRoZSBwYWNrYWdlIHN5c3RlbSB1c2VkIGJ5IHRoZSB0YXJnZXQgbGFuZ3VhZ2Ugb2YgYSBDREtURlxuICogcHJvamVjdFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUGFja2FnZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgcmVhZG9ubHkgd29ya2luZ0RpcmVjdG9yeTogc3RyaW5nKSB7fVxuXG4gIHB1YmxpYyBzdGF0aWMgZm9yTGFuZ3VhZ2UoXG4gICAgbGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIHdvcmtpbmdEaXJlY3Rvcnk6IHN0cmluZ1xuICApOiBQYWNrYWdlTWFuYWdlciB7XG4gICAgc3dpdGNoIChsYW5ndWFnZSkge1xuICAgICAgY2FzZSBMYW5ndWFnZS5HTzpcbiAgICAgICAgcmV0dXJuIG5ldyBHb1BhY2thZ2VNYW5hZ2VyKHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgY2FzZSBMYW5ndWFnZS5UWVBFU0NSSVBUOlxuICAgICAgICByZXR1cm4gbmV3IE5vZGVQYWNrYWdlTWFuYWdlcih3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuUFlUSE9OOlxuICAgICAgICByZXR1cm4gbmV3IFB5dGhvblBhY2thZ2VNYW5hZ2VyKHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgY2FzZSBMYW5ndWFnZS5DU0hBUlA6XG4gICAgICAgIHJldHVybiBuZXcgTnVnZXRQYWNrYWdlTWFuYWdlcih3b3JraW5nRGlyZWN0b3J5KTtcbiAgICAgIGNhc2UgTGFuZ3VhZ2UuSkFWQTpcbiAgICAgICAgcmV0dXJuIG5ldyBNYXZlblBhY2thZ2VNYW5hZ2VyKHdvcmtpbmdEaXJlY3RvcnkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxhbmd1YWdlOiAke2xhbmd1YWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhYnN0cmFjdCBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPjtcbiAgLy8gcHVibGljIGFic3RyYWN0IGxpc3RQYWNrYWdlcygpOiBQcm9taXNlPHRvZG8+OyBmdXR1cmUgc3R1ZmYuLlxuICAvLyBhZGQgY2hlY2sgaWYgcGFja2FnZSBleGlzdHMgYWxyZWFkeS4gbWlnaHQgcXVlcnkgdmVyc2lvbiBpbiB0aGUgZnV0dXJlIGFuZCBvZmZlciB0byB1cGdyYWRlP1xufVxuXG5jbGFzcyBOb2RlUGFja2FnZU1hbmFnZXIgZXh0ZW5kcyBQYWNrYWdlTWFuYWdlciB7XG4gIHByaXZhdGUgaGFzWWFybkxvY2tmaWxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBleGlzdHNTeW5jKHBhdGguam9pbih0aGlzLndvcmtpbmdEaXJlY3RvcnksIFwieWFybi5sb2NrXCIpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhZGRQYWNrYWdlKFxuICAgIHBhY2thZ2VOYW1lOiBzdHJpbmcsXG4gICAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coYEFkZGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn1gKTtcblxuICAgIC8vIHByb2JlIGZvciBwYWNrYWdlLWxvY2suanNvbiBvciB5YXJuLmxvY2tcbiAgICBsZXQgY29tbWFuZCA9IFwibnBtXCI7XG4gICAgbGV0IGFyZ3MgPSBbXCJpbnN0YWxsXCJdO1xuXG4gICAgaWYgKHRoaXMuaGFzWWFybkxvY2tmaWxlKCkpIHtcbiAgICAgIGNvbW1hbmQgPSBcInlhcm5cIjtcbiAgICAgIGFyZ3MgPSBbXCJhZGRcIl07XG4gICAgfVxuICAgIGFyZ3MucHVzaChcbiAgICAgIHBhY2thZ2VWZXJzaW9uID8gcGFja2FnZU5hbWUgKyBcIkBcIiArIHBhY2thZ2VWZXJzaW9uIDogcGFja2FnZU5hbWVcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coXG4gICAgICBgSW5zdGFsbGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn0gdXNpbmcgJHtjb21tYW5kfS5gXG4gICAgKTtcblxuICAgIGF3YWl0IGV4ZWMoY29tbWFuZCwgYXJncywgeyBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSB9KTtcblxuICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBpbnN0YWxsZWQuXCIpO1xuICB9XG59XG5cbmNsYXNzIFB5dGhvblBhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwcml2YXRlIGdldCBhcHBDb21tYW5kKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICAgICAgZnMucmVhZEZpbGVTeW5jKFxuICAgICAgICAgIHBhdGgucmVzb2x2ZSh0aGlzLndvcmtpbmdEaXJlY3RvcnksIFwiY2RrdGYuanNvblwiKSxcbiAgICAgICAgICBcInV0ZjhcIlxuICAgICAgICApXG4gICAgICApW1wiYXBwXCJdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IEVycm9ycy5Vc2FnZShcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIGZpbmQgYW5kIHBhcnNlIGNka3RmLmpzb24gaW4gJHt0aGlzLndvcmtpbmdEaXJlY3Rvcnl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHVzZVBpcGVudiA9IHRoaXMuYXBwQ29tbWFuZC5pbmNsdWRlcyhcInBpcGVudlwiKTtcblxuICAgIGlmICh1c2VQaXBlbnYpIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgSW5zdGFsbGluZyBwYWNrYWdlICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn0gdXNpbmcgcGlwZW52LmBcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IGV4ZWMoXCJwaXBlbnZcIiwgW1wiaW5zdGFsbFwiLCBgJHtwYWNrYWdlTmFtZX1+PSR7cGFja2FnZVZlcnNpb259YF0sIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgIGVudjoge1xuICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgIFBJUEVOVl9RVUlFVDogXCIxXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHN0ZGlvOiBbXCJpbmhlcml0XCIsIDEsIDFdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBpbnN0YWxsZWQuXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgYEluc3RhbGxpbmcgcGFja2FnZSAke3BhY2thZ2VOYW1lfSBAICR7cGFja2FnZVZlcnNpb259IHVzaW5nIHBpcC5gXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXF1aXJlbWVudHNGaWxlUGF0aCA9IHBhdGguam9pbihcbiAgICAgICAgdGhpcy53b3JraW5nRGlyZWN0b3J5LFxuICAgICAgICBcInJlcXVpcmVtZW50cy50eHRcIlxuICAgICAgKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhyZXF1aXJlbWVudHNGaWxlUGF0aCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgICAgIGBDb3VsZCBub3QgZmluZCByZXF1aXJlbWVudHMudHh0IGluICR7dGhpcy53b3JraW5nRGlyZWN0b3J5fWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVxdWlyZW1lbnRzID0gYXdhaXQgZnMucmVhZEZpbGUocmVxdWlyZW1lbnRzRmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgIGlmIChyZXF1aXJlbWVudHMuaW5jbHVkZXMocGFja2FnZU5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGBQYWNrYWdlICR7cGFja2FnZU5hbWV9IGFscmVhZHkgaW5zdGFsbGVkLiBTa2lwcGluZyBpbnN0YWxsYXRpb24uYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1JlcXVpcmVtZW50cyA9XG4gICAgICAgIHJlcXVpcmVtZW50cyArXG4gICAgICAgIGBcXG4ke3BhY2thZ2VOYW1lfSR7cGFja2FnZVZlcnNpb24gPyBgfj0ke3BhY2thZ2VWZXJzaW9ufWAgOiBcIlwifWA7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUocmVxdWlyZW1lbnRzRmlsZVBhdGgsIG5ld1JlcXVpcmVtZW50cywgXCJ1dGY4XCIpO1xuXG4gICAgICBhd2FpdCBleGVjKFwicGlwXCIsIFtcImluc3RhbGxcIiwgXCItclwiLCBcInJlcXVpcmVtZW50cy50eHRcIl0sIHtcbiAgICAgICAgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnksXG4gICAgICAgIHN0ZGlvOiBbXCJpbmhlcml0XCIsIDEsIDFdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBpbnN0YWxsZWQuXCIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBOdWdldFBhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNvbW1hbmQgPSBcImRvdG5ldFwiO1xuICAgIGNvbnN0IGFyZ3MgPSBbXCJhZGRcIiwgXCJwYWNrYWdlXCIsIHBhY2thZ2VOYW1lXTtcbiAgICBpZiAocGFja2FnZVZlcnNpb24pIHtcbiAgICAgIGFyZ3MucHVzaChcIi0tdmVyc2lvblwiLCBwYWNrYWdlVmVyc2lvbik7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKFxuICAgICAgYEluc3RhbGxpbmcgcGFja2FnZSAke3BhY2thZ2VOYW1lfSBAICR7cGFja2FnZVZlcnNpb259IHVzaW5nIFwiJHtjb21tYW5kfSAke2FyZ3Muam9pbihcbiAgICAgICAgXCIgXCJcbiAgICAgICl9XCIuYFxuICAgICk7XG5cbiAgICBhd2FpdCBleGVjKGNvbW1hbmQsIGFyZ3MsIHsgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnkgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIlBhY2thZ2UgaW5zdGFsbGVkLlwiKTtcbiAgfVxufVxuXG5jbGFzcyBNYXZlblBhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uID0gXCJMQVRFU1RcIiAvLyB0aGUgbGF0ZXN0IG9wdGlvbiBpcyBkZXByZWNhdGVkIGluIG1hdmVuIDMuNVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZyhgQWRkaW5nICR7cGFja2FnZU5hbWV9IEAgJHtwYWNrYWdlVmVyc2lvbn0gdG8gcG9tLnhtbGApO1xuICAgIC8vIEFzc2VydCBwb20ueG1sIGV4aXN0c1xuICAgIGNvbnN0IHBvbVBhdGggPSBwYXRoLmpvaW4odGhpcy53b3JraW5nRGlyZWN0b3J5LCBcInBvbS54bWxcIik7XG4gICAgaWYgKCFleGlzdHNTeW5jKHBvbVBhdGgpKSB7XG4gICAgICB0aHJvdyBFcnJvcnMuVXNhZ2UoXG4gICAgICAgIFwiTm8gcG9tLnhtbCBmb3VuZCBpbiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LiBQbGVhc2UgcnVuIHRoZSBjb21tYW5kIGZyb20gdGhlIHJvb3Qgb2YgeW91ciBwcm9qZWN0LlwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHBvbSA9IGF3YWl0IGZzLnJlYWRGaWxlKHBvbVBhdGgsIFwidXRmOFwiKTtcbiAgICBjb25zdCBwb21YbWwgPSAoYXdhaXQgeG1sMmpzKHBvbSwge30pKSBhcyBFbGVtZW50O1xuXG4gICAgLy8gTXV0YXRlIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IG5hbWVQYXJ0cyA9IHBhY2thZ2VOYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCBncm91cElkID0gbmFtZVBhcnRzLnNsaWNlKDAsIG5hbWVQYXJ0cy5sZW5ndGggLSAxKS5qb2luKFwiLlwiKTtcbiAgICBjb25zdCBhcnRpZmFjdElkID0gbmFtZVBhcnRzW25hbWVQYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgIGNvbnN0IG5ld0RlcGVuZGVuY3kgPSAoYXdhaXQgeG1sMmpzKFxuICAgICAgYDxkZXBlbmRlbmN5PlxuICAgIDxncm91cElkPiR7Z3JvdXBJZH08L2dyb3VwSWQ+XG4gICAgPGFydGlmYWN0SWQ+JHthcnRpZmFjdElkfTwvYXJ0aWZhY3RJZD5cbiAgICA8dmVyc2lvbj4ke3BhY2thZ2VWZXJzaW9ufTwvdmVyc2lvbj5cbjwvZGVwZW5kZW5jeT5gXG4gICAgKSkgYXMgRWxlbWVudDtcblxuICAgIHBvbVhtbC5lbGVtZW50c1xuICAgICAgPy5maW5kKChlbCkgPT4gZWwubmFtZSA9PT0gXCJwcm9qZWN0XCIpXG4gICAgICA/LmVsZW1lbnRzPy5maW5kKChlbCkgPT4gZWwubmFtZSA9PT0gXCJkZXBlbmRlbmNpZXNcIilcbiAgICAgID8uZWxlbWVudHM/LnB1c2gobmV3RGVwZW5kZW5jeS5lbGVtZW50cyFbMF0pO1xuXG4gICAgLy8gV3JpdGUgbmV3IHBvbS54bWxcbiAgICBhd2FpdCBmcy53cml0ZUZpbGUocG9tUGF0aCwganMyeG1sKHBvbVhtbCwgeyBzcGFjZXM6IDIgfSkpO1xuXG4gICAgLy8gSW5zdGFsbFxuICAgIGF3YWl0IGV4ZWMoXCJtdm5cIiwgW1wiaW5zdGFsbFwiXSwgeyBjd2Q6IHRoaXMud29ya2luZ0RpcmVjdG9yeSB9KTtcbiAgICBjb25zb2xlLmxvZyhcIlBhY2thZ2UgaW5zdGFsbGVkLlwiKTtcbiAgfVxufVxuXG5jbGFzcyBHb1BhY2thZ2VNYW5hZ2VyIGV4dGVuZHMgUGFja2FnZU1hbmFnZXIge1xuICBwdWJsaWMgYXN5bmMgYWRkUGFja2FnZShcbiAgICBwYWNrYWdlTmFtZTogc3RyaW5nLFxuICAgIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgcGFja2FnZSAke3BhY2thZ2VOYW1lfSBAICR7cGFja2FnZVZlcnNpb259YCk7XG5cbiAgICAvLyBJbnN0YWxsXG4gICAgYXdhaXQgZXhlYyhcImdvXCIsIFtcImdldFwiLCBwYWNrYWdlTmFtZV0sIHsgY3dkOiB0aGlzLndvcmtpbmdEaXJlY3RvcnkgfSk7XG5cbiAgICBjb25zb2xlLmxvZyhcIlBhY2thZ2UgaW5zdGFsbGVkLlwiKTtcbiAgfVxufVxuIl19