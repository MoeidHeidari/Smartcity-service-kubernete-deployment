"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.versionMatchesConstraint = exports.parseConstraint = void 0;
const semver = __importStar(require("semver"));
const errors_1 = require("../errors");
// constraints can be prefixed with "~>", ">", "<", "=", ">=", "<=" or "!="
// no prefix means "="
function parseConstraint(constraint) {
    var _a;
    const cleaned = constraint.trim();
    const operator = (((_a = cleaned.match(/(~>|>=|<=|>|<|=|!=)/)) === null || _a === void 0 ? void 0 : _a[0]) ||
        "=");
    const version = cleaned.replace(operator, "").trim();
    return {
        operator,
        version,
    };
}
exports.parseConstraint = parseConstraint;
function versionMatchesConstraint(version, constraint) {
    // https://www.terraform.io/language/expressions/version-constraints
    // version can contain multiple constraints split by ","
    var _a, _b;
    const constraints = constraint.split(",");
    version = (_b = (_a = semver.coerce(version)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : version;
    // each constraint needs to be satisfied
    return constraints.every((c) => {
        var _a, _b;
        const parsed = parseConstraint(c);
        const cleanedParsedVersion = (_b = (_a = semver.coerce(parsed.version)) === null || _a === void 0 ? void 0 : _a.version) !== null && _b !== void 0 ? _b : parsed.version;
        switch (parsed.operator) {
            case "=":
                return version === cleanedParsedVersion;
            case "!=":
                return version !== cleanedParsedVersion;
            case "~>": {
                // allows rightmost version component to increment
                // ~>2.0 which allows 2.1 and 2.1.1 needs special handling as
                // npm semver handles "~" differently for ~2.0 than for ~2 or ~2.1.0
                // So we need to use "^" (e.g. ^2.0) for this case
                // see: https://github.com/npm/node-semver/issues/11
                const allowMinorAndPatchOnly = parsed.version.split(".").length === 2;
                const range = allowMinorAndPatchOnly
                    ? `^${parsed.version}`
                    : `~${parsed.version}`;
                return semver.satisfies(version, range);
            }
            case ">=":
                return semver.gte(version, cleanedParsedVersion);
            case "<=":
                return semver.lte(version, cleanedParsedVersion);
            case ">":
                return semver.gt(version, cleanedParsedVersion);
            case "<":
                return semver.lt(version, cleanedParsedVersion);
            default:
                throw errors_1.Errors.External(`Unknown constraint operator: ${parsed.operator} in version constraint ${constraint}`);
        }
    });
}
exports.versionMatchesConstraint = versionMatchesConstraint;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi1jb25zdHJhaW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZlcnNpb24tY29uc3RyYWludHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUFpQztBQUNqQyxzQ0FBbUM7QUFJbkMsMkVBQTJFO0FBQzNFLHNCQUFzQjtBQUN0QixTQUFnQixlQUFlLENBQUMsVUFBa0I7O0lBSWhELE1BQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUVsQyxNQUFNLFFBQVEsR0FBRyxDQUFDLE9BQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQywwQ0FBRyxDQUFDO1FBQ3hELEdBQUcsQ0FBYSxDQUFDO0lBQ25CLE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBRXJELE9BQU87UUFDTCxRQUFRO1FBQ1IsT0FBTztLQUNSLENBQUM7QUFDSixDQUFDO0FBZEQsMENBY0M7QUFFRCxTQUFnQix3QkFBd0IsQ0FDdEMsT0FBZSxFQUNmLFVBQWtCO0lBRWxCLG9FQUFvRTtJQUNwRSx3REFBd0Q7O0lBRXhELE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUMsT0FBTyxlQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLDBDQUFFLE9BQU8sbUNBQUksT0FBTyxDQUFDO0lBRXJELHdDQUF3QztJQUN4QyxPQUFPLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRTs7UUFDN0IsTUFBTSxNQUFNLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRWxDLE1BQU0sb0JBQW9CLGVBQ3hCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQywwQ0FBRSxPQUFPLG1DQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFFM0QsUUFBUSxNQUFNLENBQUMsUUFBUSxFQUFFO1lBQ3ZCLEtBQUssR0FBRztnQkFDTixPQUFPLE9BQU8sS0FBSyxvQkFBb0IsQ0FBQztZQUMxQyxLQUFLLElBQUk7Z0JBQ1AsT0FBTyxPQUFPLEtBQUssb0JBQW9CLENBQUM7WUFDMUMsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxrREFBa0Q7Z0JBRWxELDZEQUE2RDtnQkFDN0Qsb0VBQW9FO2dCQUNwRSxrREFBa0Q7Z0JBQ2xELG9EQUFvRDtnQkFDcEQsTUFBTSxzQkFBc0IsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO2dCQUV0RSxNQUFNLEtBQUssR0FBRyxzQkFBc0I7b0JBQ2xDLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUU7b0JBQ3RCLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFFekIsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN6QztZQUNELEtBQUssSUFBSTtnQkFDUCxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLG9CQUFvQixDQUFDLENBQUM7WUFDbkQsS0FBSyxJQUFJO2dCQUNQLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztZQUNuRCxLQUFLLEdBQUc7Z0JBQ04sT0FBTyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ2xELEtBQUssR0FBRztnQkFDTixPQUFPLE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLG9CQUFvQixDQUFDLENBQUM7WUFDbEQ7Z0JBQ0UsTUFBTSxlQUFNLENBQUMsUUFBUSxDQUNuQixnQ0FBZ0MsTUFBTSxDQUFDLFFBQVEsMEJBQTBCLFVBQVUsRUFBRSxDQUN0RixDQUFDO1NBQ0w7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFuREQsNERBbURDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2VtdmVyIGZyb20gXCJzZW12ZXJcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCIuLi9lcnJvcnNcIjtcblxudHlwZSBPcGVyYXRvciA9IFwiPVwiIHwgXCIhPVwiIHwgXCJ+PlwiIHwgXCI+PVwiIHwgXCI8PVwiIHwgXCI+XCIgfCBcIjxcIjtcblxuLy8gY29uc3RyYWludHMgY2FuIGJlIHByZWZpeGVkIHdpdGggXCJ+PlwiLCBcIj5cIiwgXCI8XCIsIFwiPVwiLCBcIj49XCIsIFwiPD1cIiBvciBcIiE9XCJcbi8vIG5vIHByZWZpeCBtZWFucyBcIj1cIlxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uc3RyYWludChjb25zdHJhaW50OiBzdHJpbmcpOiB7XG4gIG9wZXJhdG9yOiBPcGVyYXRvcjtcbiAgdmVyc2lvbjogc3RyaW5nO1xufSB7XG4gIGNvbnN0IGNsZWFuZWQgPSBjb25zdHJhaW50LnRyaW0oKTtcblxuICBjb25zdCBvcGVyYXRvciA9IChjbGVhbmVkLm1hdGNoKC8ofj58Pj18PD18Pnw8fD18IT0pLyk/LlswXSB8fFxuICAgIFwiPVwiKSBhcyBPcGVyYXRvcjtcbiAgY29uc3QgdmVyc2lvbiA9IGNsZWFuZWQucmVwbGFjZShvcGVyYXRvciwgXCJcIikudHJpbSgpO1xuXG4gIHJldHVybiB7XG4gICAgb3BlcmF0b3IsXG4gICAgdmVyc2lvbixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcnNpb25NYXRjaGVzQ29uc3RyYWludChcbiAgdmVyc2lvbjogc3RyaW5nLFxuICBjb25zdHJhaW50OiBzdHJpbmdcbik6IGJvb2xlYW4ge1xuICAvLyBodHRwczovL3d3dy50ZXJyYWZvcm0uaW8vbGFuZ3VhZ2UvZXhwcmVzc2lvbnMvdmVyc2lvbi1jb25zdHJhaW50c1xuICAvLyB2ZXJzaW9uIGNhbiBjb250YWluIG11bHRpcGxlIGNvbnN0cmFpbnRzIHNwbGl0IGJ5IFwiLFwiXG5cbiAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50LnNwbGl0KFwiLFwiKTtcbiAgdmVyc2lvbiA9IHNlbXZlci5jb2VyY2UodmVyc2lvbik/LnZlcnNpb24gPz8gdmVyc2lvbjtcblxuICAvLyBlYWNoIGNvbnN0cmFpbnQgbmVlZHMgdG8gYmUgc2F0aXNmaWVkXG4gIHJldHVybiBjb25zdHJhaW50cy5ldmVyeSgoYykgPT4ge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29uc3RyYWludChjKTtcblxuICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRWZXJzaW9uID1cbiAgICAgIHNlbXZlci5jb2VyY2UocGFyc2VkLnZlcnNpb24pPy52ZXJzaW9uID8/IHBhcnNlZC52ZXJzaW9uO1xuXG4gICAgc3dpdGNoIChwYXJzZWQub3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgIHJldHVybiB2ZXJzaW9uID09PSBjbGVhbmVkUGFyc2VkVmVyc2lvbjtcbiAgICAgIGNhc2UgXCIhPVwiOlxuICAgICAgICByZXR1cm4gdmVyc2lvbiAhPT0gY2xlYW5lZFBhcnNlZFZlcnNpb247XG4gICAgICBjYXNlIFwifj5cIjoge1xuICAgICAgICAvLyBhbGxvd3MgcmlnaHRtb3N0IHZlcnNpb24gY29tcG9uZW50IHRvIGluY3JlbWVudFxuXG4gICAgICAgIC8vIH4+Mi4wIHdoaWNoIGFsbG93cyAyLjEgYW5kIDIuMS4xIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmcgYXNcbiAgICAgICAgLy8gbnBtIHNlbXZlciBoYW5kbGVzIFwiflwiIGRpZmZlcmVudGx5IGZvciB+Mi4wIHRoYW4gZm9yIH4yIG9yIH4yLjEuMFxuICAgICAgICAvLyBTbyB3ZSBuZWVkIHRvIHVzZSBcIl5cIiAoZS5nLiBeMi4wKSBmb3IgdGhpcyBjYXNlXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXNlbXZlci9pc3N1ZXMvMTFcbiAgICAgICAgY29uc3QgYWxsb3dNaW5vckFuZFBhdGNoT25seSA9IHBhcnNlZC52ZXJzaW9uLnNwbGl0KFwiLlwiKS5sZW5ndGggPT09IDI7XG5cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBhbGxvd01pbm9yQW5kUGF0Y2hPbmx5XG4gICAgICAgICAgPyBgXiR7cGFyc2VkLnZlcnNpb259YFxuICAgICAgICAgIDogYH4ke3BhcnNlZC52ZXJzaW9ufWA7XG5cbiAgICAgICAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgIHJldHVybiBzZW12ZXIuZ3RlKHZlcnNpb24sIGNsZWFuZWRQYXJzZWRWZXJzaW9uKTtcbiAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICByZXR1cm4gc2VtdmVyLmx0ZSh2ZXJzaW9uLCBjbGVhbmVkUGFyc2VkVmVyc2lvbik7XG4gICAgICBjYXNlIFwiPlwiOlxuICAgICAgICByZXR1cm4gc2VtdmVyLmd0KHZlcnNpb24sIGNsZWFuZWRQYXJzZWRWZXJzaW9uKTtcbiAgICAgIGNhc2UgXCI8XCI6XG4gICAgICAgIHJldHVybiBzZW12ZXIubHQodmVyc2lvbiwgY2xlYW5lZFBhcnNlZFZlcnNpb24pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3JzLkV4dGVybmFsKFxuICAgICAgICAgIGBVbmtub3duIGNvbnN0cmFpbnQgb3BlcmF0b3I6ICR7cGFyc2VkLm9wZXJhdG9yfSBpbiB2ZXJzaW9uIGNvbnN0cmFpbnQgJHtjb25zdHJhaW50fWBcbiAgICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuIl19