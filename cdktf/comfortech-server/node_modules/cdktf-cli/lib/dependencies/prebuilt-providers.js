"use strict";
// TODO: introduce caching for the calls to NPM
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPrebuiltProviderVersion = exports.getNpmPackageName = void 0;
const https_proxy_agent_1 = require("https-proxy-agent");
const node_fetch_1 = __importDefault(require("node-fetch"));
const semver = __importStar(require("semver"));
const logging_1 = require("../logging");
const dependency_manager_1 = require("./dependency-manager");
const version_constraints_1 = require("./version-constraints");
const proxy = process.env.http_proxy || process.env.HTTP_PROXY;
let agent;
if (proxy) {
    agent = new https_proxy_agent_1.HttpsProxyAgent(proxy);
}
// uses https://github.com/hashicorp/cdktf-repository-manager/blob/main/provider.json
const providersMapUrl = `https://raw.githubusercontent.com/hashicorp/cdktf-repository-manager/main/provider.json`;
async function getNpmPackageName(constraint) {
    const providers = (await (await node_fetch_1.default(providersMapUrl, {
        agent,
        headers: { "User-Agent": "HashiCorp/cdktf-cli" },
    })).json());
    const entry = Object.entries(providers).find(([, p]) => dependency_manager_1.ProviderConstraint.fromConfigEntry(p).source === constraint.source);
    if (!entry) {
        return undefined; // no pre-built provider found for this constraint
    }
    const name = entry[0];
    return `@cdktf/provider-${name}`;
}
exports.getNpmPackageName = getNpmPackageName;
async function getPrebuiltProviderVersions(packageName) {
    const url = `https://registry.npmjs.org/${packageName}`;
    const result = (await (await node_fetch_1.default(url, {
        agent,
        headers: { "User-Agent": "HashiCorp/cdktf-cli" },
    })).json()); // TODO: handle 404 and other errors (abort on other errors)
    const versions = Object.entries(result.versions)
        .map(([version, packageJson]) => {
        var _a, _b;
        const provider = (_a = packageJson.cdktf) === null || _a === void 0 ? void 0 : _a.provider;
        if (!provider || !((_b = packageJson.peerDependencies) === null || _b === void 0 ? void 0 : _b.cdktf)) {
            logging_1.logger.trace(`skipping version ${version} of ${packageName} as it does not have a cdktf.provider or peerDependencies.cdktf in package.json`);
            return undefined;
        }
        return {
            packageVersion: version,
            providerVersion: provider.version,
            cdktfPeerDependencyConstraint: packageJson.peerDependencies.cdktf,
        };
    })
        .filter((v) => v !== undefined);
    // latest version first, sorted by packageVersion as that
    // one always increases while the providerVersion may not
    versions.sort((a, b) => {
        if (semver.gt(a.packageVersion, b.packageVersion)) {
            return -1;
        }
        if (semver.lt(a.packageVersion, b.packageVersion)) {
            return 1;
        }
        return 0;
    });
    return versions;
}
function cdktfVersionMatches(cdktfVersion, cdktfPeerDependencyConstraint) {
    return semver.satisfies(cdktfVersion, cdktfPeerDependencyConstraint);
}
async function getPrebuiltProviderVersion(constraint, cdktfVersion) {
    const providerName = await getNpmPackageName(constraint); // TODO: add lots of debug logs to this call
    // no pre-built provider exists
    if (!providerName) {
        return null;
    }
    const versions = await getPrebuiltProviderVersions(providerName);
    // find first the version that matches the requested provider version and cdktf version
    const matchingVersion = versions.find((v) => {
        if (!cdktfVersionMatches(cdktfVersion, v.cdktfPeerDependencyConstraint)) {
            return false; // skip if cdktf version does not match
        }
        if (constraint.version) {
            return version_constraints_1.versionMatchesConstraint(v.providerVersion, constraint.version);
        }
        return true; // if no version constraint is passed, return true on the first match
    });
    if (matchingVersion) {
        return matchingVersion.packageVersion;
    }
    return null;
}
exports.getPrebuiltProviderVersion = getPrebuiltProviderVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlYnVpbHQtcHJvdmlkZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicHJlYnVpbHQtcHJvdmlkZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSwrQ0FBK0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFL0MseURBQW9EO0FBQ3BELDREQUErQjtBQUMvQiwrQ0FBaUM7QUFDakMsd0NBQW9DO0FBQ3BDLDZEQUEwRDtBQUMxRCwrREFBaUU7QUFFakUsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUM7QUFDL0QsSUFBSSxLQUFrQyxDQUFDO0FBQ3ZDLElBQUksS0FBSyxFQUFFO0lBQ1QsS0FBSyxHQUFHLElBQUksbUNBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNwQztBQUVELHFGQUFxRjtBQUNyRixNQUFNLGVBQWUsR0FBRyx5RkFBeUYsQ0FBQztBQUszRyxLQUFLLFVBQVUsaUJBQWlCLENBQ3JDLFVBQThCO0lBRTlCLE1BQU0sU0FBUyxHQUFHLENBQUMsTUFBTSxDQUN2QixNQUFNLG9CQUFLLENBQUMsZUFBZSxFQUFFO1FBQzNCLEtBQUs7UUFDTCxPQUFPLEVBQUUsRUFBRSxZQUFZLEVBQUUscUJBQXFCLEVBQUU7S0FDakQsQ0FBQyxDQUNILENBQUMsSUFBSSxFQUFFLENBQWlCLENBQUM7SUFFMUIsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQzFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDUix1Q0FBa0IsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxNQUFNLENBQ3JFLENBQUM7SUFDRixJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1YsT0FBTyxTQUFTLENBQUMsQ0FBQyxrREFBa0Q7S0FDckU7SUFDRCxNQUFN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LENBQUMsQ0FBQyxlQUFlLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3hFO1FBQ0QsT0FBTyxJQUFJLENBQUMsQ0FBQyxxRUFBcUU7SUFDcEYsQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLGVBQWUsRUFBRTtRQUNuQixPQUFPLGVBQWUsQ0FBQyxjQUFjLENBQUM7S0FDdkM7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUM7QUE3QkQsZ0VBNkJDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogaW50cm9kdWNlIGNhY2hpbmcgZm9yIHRoZSBjYWxscyB0byBOUE1cblxuaW1wb3J0IHsgSHR0cHNQcm94eUFnZW50IH0gZnJvbSBcImh0dHBzLXByb3h5LWFnZW50XCI7XG5pbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tIFwic2VtdmVyXCI7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgUHJvdmlkZXJDb25zdHJhaW50IH0gZnJvbSBcIi4vZGVwZW5kZW5jeS1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uTWF0Y2hlc0NvbnN0cmFpbnQgfSBmcm9tIFwiLi92ZXJzaW9uLWNvbnN0cmFpbnRzXCI7XG5cbmNvbnN0IHByb3h5ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eSB8fCBwcm9jZXNzLmVudi5IVFRQX1BST1hZO1xubGV0IGFnZW50OiBIdHRwc1Byb3h5QWdlbnQgfCB1bmRlZmluZWQ7XG5pZiAocHJveHkpIHtcbiAgYWdlbnQgPSBuZXcgSHR0cHNQcm94eUFnZW50KHByb3h5KTtcbn1cblxuLy8gdXNlcyBodHRwczovL2dpdGh1Yi5jb20vaGFzaGljb3JwL2Nka3RmLXJlcG9zaXRvcnktbWFuYWdlci9ibG9iL21haW4vcHJvdmlkZXIuanNvblxuY29uc3QgcHJvdmlkZXJzTWFwVXJsID0gYGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9oYXNoaWNvcnAvY2RrdGYtcmVwb3NpdG9yeS1tYW5hZ2VyL21haW4vcHJvdmlkZXIuanNvbmA7XG50eXBlIFByb3ZpZGVyc01hcCA9IHtcbiAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROcG1QYWNrYWdlTmFtZShcbiAgY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50XG4pOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICBjb25zdCBwcm92aWRlcnMgPSAoYXdhaXQgKFxuICAgIGF3YWl0IGZldGNoKHByb3ZpZGVyc01hcFVybCwge1xuICAgICAgYWdlbnQsXG4gICAgICBoZWFkZXJzOiB7IFwiVXNlci1BZ2VudFwiOiBcIkhhc2hpQ29ycC9jZGt0Zi1jbGlcIiB9LFxuICAgIH0pXG4gICkuanNvbigpKSBhcyBQcm92aWRlcnNNYXA7XG5cbiAgY29uc3QgZW50cnkgPSBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpLmZpbmQoXG4gICAgKFssIHBdKSA9PlxuICAgICAgUHJvdmlkZXJDb25zdHJhaW50LmZyb21Db25maWdFbnRyeShwKS5zb3VyY2UgPT09IGNvbnN0cmFpbnQuc291cmNlXG4gICk7XG4gIGlmICghZW50cnkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBubyBwcmUtYnVpbHQgcHJvdmlkZXIgZm91bmQgZm9yIHRoaXMgY29uc3RyYWludFxuICB9XG4gIGNvbnN0IG5hbWUgPSBlbnRyeVswXTtcblxuICByZXR1cm4gYEBjZGt0Zi9wcm92aWRlci0ke25hbWV9YDtcbn1cblxudHlwZSBQYWNrYWdlSnNvbiA9IHtcbiAgLy8gaGFzIGJlZW4gaW50cm9kdWNlZCB2aWEgaHR0cHM6Ly9naXRodWIuY29tL2hhc2hpY29ycC9jZGt0Zi1wcm92aWRlci1wcm9qZWN0L3B1bGwvMjE3XG4gIGNka3RmPzoge1xuICAgIC8vIHByb3ZpZGVyIGlzIG9wdGlvbmFsIGFzIHdlIG1pZ2h0IHNldCBvdGhlciBjZGt0ZiByZWxhdGVkIGZpZWxkcyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gZm9yIG90aGVyIGxpYnMgKGkuZS4gY29uc3RydWN0IHBhY2thZ2VzKSB3aGlsZSBzdGlsbCB1c2luZyB0aGUgY2RrdGYga2V5XG4gICAgcHJvdmlkZXI/OiB7XG4gICAgICAvKipcbiAgICAgICAqIG5hbWUgb2YgdGhlIHByb3ZpZGVyLCB3aWxsIHJlc29sdmUgdG8gdGhlIGZ1bGwgbmFtZSBhcyBpbiB0aGUgVGVycmFmb3JtIHNjaGVtYS5cbiAgICAgICAqIGUuZy4gcmVnaXN0cnkudGVycmFmb3JtLmlvL2hhc2hpY29ycC9hd3NcbiAgICAgICAqL1xuICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgLyoqXG4gICAgICAgKiB0aGUgYWN0dWFsIHZlcnNpb24gdGhhdCB3YXMgdXNlZCB0byBidWlsZCB0aGUgcHJvdmlkZXJcbiAgICAgICAqIGUuZy4gNC4xMi4xXG4gICAgICAgKi9cbiAgICAgIHZlcnNpb246IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBwZWVyRGVwZW5kZW5jaWVzPzoge1xuICAgIGNka3RmPzogc3RyaW5nO1xuICB9O1xuICAvLyAuLi4gbWFueSBtb3JlIGZpZWxkc1xufTtcbnR5cGUgTnBtUGFja2FnZVJlc3VsdCA9IHtcbiAgbmFtZTogc3RyaW5nOyAvLyBlLmcuIFwiQGNka3RmL3Byb3ZpZGVyLWF3c1wiXG4gIHZlcnNpb25zOiB7XG4gICAgW3ZlcnNpb246IHN0cmluZ106IFBhY2thZ2VKc29uO1xuICB9O1xufTtcblxudHlwZSBQcmVidWlsdFByb3ZpZGVyVmVyc2lvbiA9IHtcbiAgcGFja2FnZVZlcnNpb246IHN0cmluZzsgLy8gZS5nLiBcIjcuMC40MlwiXG4gIHByb3ZpZGVyVmVyc2lvbjogc3RyaW5nOyAvLyBlLmcuIFwiNC4xMi4xXCJcbiAgY2RrdGZQZWVyRGVwZW5kZW5jeUNvbnN0cmFpbnQ6IHN0cmluZzsgLy8gZS5nLiBcIl4xMC4wLjBcIlxufTtcbmFzeW5jIGZ1bmN0aW9uIGdldFByZWJ1aWx0UHJvdmlkZXJWZXJzaW9ucyhcbiAgcGFja2FnZU5hbWU6IHN0cmluZ1xuKTogUHJvbWlzZTxQcmVidWlsdFByb3ZpZGVyVmVyc2lvbltdPiB7XG4gIGNvbnN0IHVybCA9IGBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy8ke3BhY2thZ2VOYW1lfWA7XG4gIGNvbnN0IHJlc3VsdCA9IChhd2FpdCAoXG4gICAgYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICBhZ2VudCxcbiAgICAgIGhlYWRlcnM6IHsgXCJVc2VyLUFnZW50XCI6IFwiSGFzaGlDb3JwL2Nka3RmLWNsaVwiIH0sXG4gICAgfSlcbiAgKS5qc29uKCkpIGFzIE5wbVBhY2thZ2VSZXN1bHQ7IC8vIFRPRE86IGhhbmRsZSA0MDQgYW5kIG90aGVyIGVycm9ycyAoYWJvcnQgb24gb3RoZXIgZXJyb3JzKVxuXG4gIGNvbnN0IHZlcnNpb25zID0gT2JqZWN0LmVudHJpZXMocmVzdWx0LnZlcnNpb25zKVxuICAgIC5tYXAoKFt2ZXJzaW9uLCBwYWNrYWdlSnNvbl0pID0+IHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gcGFja2FnZUpzb24uY2RrdGY/LnByb3ZpZGVyO1xuICAgICAgaWYgKCFwcm92aWRlciB8fCAhcGFja2FnZUpzb24ucGVlckRlcGVuZGVuY2llcz8uY2RrdGYpIHtcbiAgICAgICAgbG9nZ2VyLnRyYWNlKFxuICAgICAgICAgIGBza2lwcGluZyB2ZXJzaW9uICR7dmVyc2lvbn0gb2YgJHtwYWNrYWdlTmFtZX0gYXMgaXQgZG9lcyBub3QgaGF2ZSBhIGNka3RmLnByb3ZpZGVyIG9yIHBlZXJEZXBlbmRlbmNpZXMuY2RrdGYgaW4gcGFja2FnZS5qc29uYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFja2FnZVZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyVmVyc2lvbjogcHJvdmlkZXIudmVyc2lvbixcbiAgICAgICAgY2RrdGZQZWVyRGVwZW5kZW5jeUNvbnN0cmFpbnQ6IHBhY2thZ2VKc29uLnBlZXJEZXBlbmRlbmNpZXMuY2RrdGYsXG4gICAgICB9O1xuICAgIH0pXG4gICAgLmZpbHRlcigodikgPT4gdiAhPT0gdW5kZWZpbmVkKSBhcyBQcmVidWlsdFByb3ZpZGVyVmVyc2lvbltdO1xuXG4gIC8vIGxhdGVzdCB2ZXJzaW9uIGZpcnN0LCBzb3J0ZWQgYnkgcGFja2FnZVZlcnNpb24gYXMgdGhhdFxuICAvLyBvbmUgYWx3YXlzIGluY3JlYXNlcyB3aGlsZSB0aGUgcHJvdmlkZXJWZXJzaW9uIG1heSBub3RcbiAgdmVyc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChzZW12ZXIuZ3QoYS5wYWNrYWdlVmVyc2lvbiwgYi5wYWNrYWdlVmVyc2lvbikpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHNlbXZlci5sdChhLnBhY2thZ2VWZXJzaW9uLCBiLnBhY2thZ2VWZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KTtcblxuICByZXR1cm4gdmVyc2lvbnM7XG59XG5cbmZ1bmN0aW9uIGNka3RmVmVyc2lvbk1hdGNoZXMoXG4gIGNka3RmVmVyc2lvbjogc3RyaW5nLFxuICBjZGt0ZlBlZXJEZXBlbmRlbmN5Q29uc3RyYWludDogc3RyaW5nXG4pOiBib29sZWFuIHtcbiAgcmV0dXJuIHNlbXZlci5zYXRpc2ZpZXMoY2RrdGZWZXJzaW9uLCBjZGt0ZlBlZXJEZXBlbmRlbmN5Q29uc3RyYWludCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcmVidWlsdFByb3ZpZGVyVmVyc2lvbihcbiAgY29uc3RyYWludDogUHJvdmlkZXJDb25zdHJhaW50LFxuICBjZGt0ZlZlcnNpb246IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnN0IHByb3ZpZGVyTmFtZSA9IGF3YWl0IGdldE5wbVBhY2thZ2VOYW1lKGNvbnN0cmFpbnQpOyAvLyBUT0RPOiBhZGQgbG90cyBvZiBkZWJ1ZyBsb2dzIHRvIHRoaXMgY2FsbFxuXG4gIC8vIG5vIHByZS1idWlsdCBwcm92aWRlciBleGlzdHNcbiAgaWYgKCFwcm92aWRlck5hbWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHZlcnNpb25zID0gYXdhaXQgZ2V0UHJlYnVpbHRQcm92aWRlclZlcnNpb25zKHByb3ZpZGVyTmFtZSk7XG5cbiAgLy8gZmluZCBmaXJzdCB0aGUgdmVyc2lvbiB0aGF0IG1hdGNoZXMgdGhlIHJlcXVlc3RlZCBwcm92aWRlciB2ZXJzaW9uIGFuZCBjZGt0ZiB2ZXJzaW9uXG4gIGNvbnN0IG1hdGNoaW5nVmVyc2lvbiA9IHZlcnNpb25zLmZpbmQoKHYpID0+IHtcbiAgICBpZiAoIWNka3RmVmVyc2lvbk1hdGNoZXMoY2RrdGZWZXJzaW9uLCB2LmNka3RmUGVlckRlcGVuZGVuY3lDb25zdHJhaW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBza2lwIGlmIGNka3RmIHZlcnNpb24gZG9lcyBub3QgbWF0Y2hcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnQudmVyc2lvbikge1xuICAgICAgcmV0dXJuIHZlcnNpb25NYXRjaGVzQ29uc3RyYWludCh2LnByb3ZpZGVyVmVyc2lvbiwgY29uc3RyYWludC52ZXJzaW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7IC8vIGlmIG5vIHZlcnNpb24gY29uc3RyYWludCBpcyBwYXNzZWQsIHJldHVybiB0cnVlIG9uIHRoZSBmaXJzdCBtYXRjaFxuICB9KTtcblxuICBpZiAobWF0Y2hpbmdWZXJzaW9uKSB7XG4gICAgcmV0dXJuIG1hdGNoaW5nVmVyc2lvbi5wYWNrYWdlVmVyc2lvbjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuIl19