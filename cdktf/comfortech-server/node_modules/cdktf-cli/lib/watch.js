"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.watch = void 0;
const path_1 = __importDefault(require("path"));
const cdktf_project_1 = require("./cdktf-project");
const errors_1 = require("./errors");
const fs = __importStar(require("fs"));
const chokidar = __importStar(require("chokidar"));
const logging_1 = require("./logging");
// In this very first iteration we will find out which files to watch by asking the user to provide the files
// We default to something reasonable per language and write it into the cdkt.json file
// Mid-Term we might want to add a WatchFile / WatchDir construct that we can use (e.g. in assets) and that a user can use to specify their watch behaviour
// See https://github.com/hashicorp/terraform-cdk/issues/1668
function getOrWriteDefaultWatchConfig(projectPath = process.cwd()) {
    const cdktfJsonPath = path_1.default.resolve(projectPath, "cdktf.json");
    logging_1.logger.debug(`Getting files to watch from cdktf.json at ${cdktfJsonPath}`);
    let cdktfJson;
    try {
        cdktfJson = require(cdktfJsonPath);
    }
    catch (err) {
        throw errors_1.Errors.Internal(`Could not find cdktf.json file in ${projectPath}`);
    }
    if (cdktfJson.watchPattern) {
        logging_1.logger.debug(`Found watchPattern in cdktf.json: ${cdktfJson.watchPattern}`);
        return cdktfJson.watchPattern;
    }
    const language = cdktfJson.language;
    if (!language) {
        throw errors_1.Errors.Usage(`No language specified in cdktf.json, please either specify a language or watchPattern to use the watch command`);
    }
    const defaultWatchPattern = {
        typescript: ["./**/*.ts"],
        python: ["./**/*.py"],
        java: ["src/**/*.java"],
        csharp: ["./**/*.cs"],
        go: ["./**/*.go"],
    }[language];
    fs.writeFileSync(cdktfJsonPath, JSON.stringify({ ...cdktfJson, watchPattern: defaultWatchPattern }, null, 2));
    logging_1.logger.debug(`Write default watchPattern for ${language} in cdktf.json.`);
    return defaultWatchPattern;
}
const projectStatus = (project) => {
    if (!(project === null || project === void 0 ? void 0 : project.stacksToRun.length)) {
        return {
            inProgress: [],
            finished: [],
            pending: [],
        };
    }
    const inProgress = project.stacksToRun.filter((s) => s.isRunning);
    const finished = project.stacksToRun.filter((s) => s.isDone);
    const pending = project.stacksToRun.filter((s) => s.isPending);
    return { inProgress, finished, pending };
};
async function watch(projectOptions, executionOptions, abortSignal, onStateChange) {
    const patterns = getOrWriteDefaultWatchConfig();
    const watcher = chokidar.watch(patterns, {
        ignoreInitial: true,
    });
    let state = { type: "waiting" };
    const changeState = (newState) => {
        state = newState;
        onStateChange(state);
    };
    async function run() {
        logging_1.logger.debug("Running cdktf deploy");
        const project = new cdktf_project_1.CdktfProject({
            ...projectOptions,
            onLog: (log) => {
                if (projectOptions.onLog) {
                    projectOptions.onLog(log);
                }
                if (state.type === "running") {
                    changeState({ ...state, ...projectStatus(project) });
                }
            },
        });
        const abort = () => project.hardAbort();
        abortSignal.addEventListener("abort", abort);
        await project.deploy(executionOptions);
        abortSignal.removeEventListener("abort", abort);
        logging_1.logger.debug("cdktf deploy finished");
        if (state.type !== "running") {
            throw errors_1.Errors.Internal("Watch was in a state where the state was not running in the run phase");
        }
        if (state.nextRunQueued) {
            logging_1.logger.debug("Next run was queued, starting it now");
            changeState({
                ...state,
                nextRunQueued: false,
                currentRun: run(),
                ...projectStatus(project),
            });
        }
        else {
            logging_1.logger.debug("Nothing queued, waiting for changes");
            changeState({ type: "waiting" });
        }
    }
    abortSignal.addEventListener("abort", () => {
        logging_1.logger.debug("Abort signal received, stopping watch");
        watcher.close();
        changeState({ type: "stopped" });
    });
    const onFileChange = () => {
        if (state.type === "stopped") {
            return;
        }
        if (state.type === "running") {
            changeState({ ...state, nextRunQueued: true });
            return;
        }
        changeState({
            type: "running",
            nextRunQueued: false,
            currentRun: run(),
            ...projectStatus(),
        });
    };
    watcher.on("all", onFileChange);
    // initially run once
    onFileChange();
}
exports.watch = watch;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2F0Y2guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ3YXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsZ0RBQXdCO0FBQ3hCLG1EQUl5QjtBQUN6QixxQ0FBa0M7QUFDbEMsdUNBQXlCO0FBQ3pCLG1EQUFxQztBQUNyQyx1Q0FBbUM7QUFHbkMsNkdBQTZHO0FBQzdHLHVGQUF1RjtBQUN2RiwySkFBMko7QUFDM0osNkRBQTZEO0FBQzdELFNBQVMsNEJBQTRCLENBQUMsV0FBVyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDL0QsTUFBTSxhQUFhLEdBQUcsY0FBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDOUQsZ0JBQU0sQ0FBQyxLQUFLLENBQUMsNkNBQTZDLGFBQWEsRUFBRSxDQUFDLENBQUM7SUFFM0UsSUFBSSxTQUFTLENBQUM7SUFDZCxJQUFJO1FBQ0YsU0FBUyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUNwQztJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osTUFBTSxlQUFNLENBQUMsUUFBUSxDQUFDLHFDQUFxQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0tBQzNFO0lBRUQsSUFBSSxTQUFTLENBQUMsWUFBWSxFQUFFO1FBQzFCLGdCQUFNLENBQUMsS0FBSyxDQUFDLHFDQUFxQyxTQUFTLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQztRQUM1RSxPQUFPLFNBQVMsQ0FBQyxZQUFZLENBQUM7S0FDL0I7SUFDRCxNQUFNLFFBQVEsR0FNRSxTQUFTLENBQUMsUUFBUSxDQUFDO0lBRW5DLElBQUksQ0FBQyxRQUFRLEVBQUU7UUFDYixNQUFNLGVBQU0sQ0FBQyxLQUFLLENBQ2hCLGdIQUFnSCxDQUNqSCxDQUFDO0tBQ0g7SUFFRCxNQUFNLG1CQUFtQixHQUFHO1FBQzFCLFVBQVUsRUFBRSxDQUFDLFdBQVcsQ0FBQztRQUN6QixNQUFNLEVBQUUs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YUFBYSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDL0MsT0FBTztTQUNSO1FBRUQsV0FBVyxDQUFDO1lBQ1YsSUFBSSxFQUFFLFNBQVM7WUFDZixhQUFhLEVBQUUsS0FBSztZQUNwQixVQUFVLEVBQUUsR0FBRyxFQUFFO1lBQ2pCLEdBQUcsYUFBYSxFQUFFO1NBQ25CLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztJQUVGLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBQ2hDLHFCQUFxQjtJQUNyQixZQUFZLEVBQUUsQ0FBQztBQUNqQixDQUFDO0FBbEZELHNCQWtGQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQge1xuICBDZGt0ZlByb2plY3QsXG4gIENka3RmUHJvamVjdE9wdGlvbnMsXG4gIEV4ZWN1dGlvbk9wdGlvbnMsXG59IGZyb20gXCIuL2Nka3RmLXByb2plY3RcIjtcbmltcG9ydCB7IEVycm9ycyB9IGZyb20gXCIuL2Vycm9yc1wiO1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgKiBhcyBjaG9raWRhciBmcm9tIFwiY2hva2lkYXJcIjtcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gXCIuL2xvZ2dpbmdcIjtcbmltcG9ydCB7IENka3RmU3RhY2sgfSBmcm9tIFwiLi9jZGt0Zi1zdGFja1wiO1xuXG4vLyBJbiB0aGlzIHZlcnkgZmlyc3QgaXRlcmF0aW9uIHdlIHdpbGwgZmluZCBvdXQgd2hpY2ggZmlsZXMgdG8gd2F0Y2ggYnkgYXNraW5nIHRoZSB1c2VyIHRvIHByb3ZpZGUgdGhlIGZpbGVzXG4vLyBXZSBkZWZhdWx0IHRvIHNvbWV0aGluZyByZWFzb25hYmxlIHBlciBsYW5ndWFnZSBhbmQgd3JpdGUgaXQgaW50byB0aGUgY2RrdC5qc29uIGZpbGVcbi8vIE1pZC1UZXJtIHdlIG1pZ2h0IHdhbnQgdG8gYWRkIGEgV2F0Y2hGaWxlIC8gV2F0Y2hEaXIgY29uc3RydWN0IHRoYXQgd2UgY2FuIHVzZSAoZS5nLiBpbiBhc3NldHMpIGFuZCB0aGF0IGEgdXNlciBjYW4gdXNlIHRvIHNwZWNpZnkgdGhlaXIgd2F0Y2ggYmVoYXZpb3VyXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2hhc2hpY29ycC90ZXJyYWZvcm0tY2RrL2lzc3Vlcy8xNjY4XG5mdW5jdGlvbiBnZXRPcldyaXRlRGVmYXVsdFdhdGNoQ29uZmlnKHByb2plY3RQYXRoID0gcHJvY2Vzcy5jd2QoKSkge1xuICBjb25zdCBjZGt0Zkpzb25QYXRoID0gcGF0aC5yZXNvbHZlKHByb2plY3RQYXRoLCBcImNka3RmLmpzb25cIik7XG4gIGxvZ2dlci5kZWJ1ZyhgR2V0dGluZyBmaWxlcyB0byB3YXRjaCBmcm9tIGNka3RmLmpzb24gYXQgJHtjZGt0Zkpzb25QYXRofWApO1xuXG4gIGxldCBjZGt0Zkpzb247XG4gIHRyeSB7XG4gICAgY2RrdGZKc29uID0gcmVxdWlyZShjZGt0Zkpzb25QYXRoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgRXJyb3JzLkludGVybmFsKGBDb3VsZCBub3QgZmluZCBjZGt0Zi5qc29uIGZpbGUgaW4gJHtwcm9qZWN0UGF0aH1gKTtcbiAgfVxuXG4gIGlmIChjZGt0Zkpzb24ud2F0Y2hQYXR0ZXJuKSB7XG4gICAgbG9nZ2VyLmRlYnVnKGBGb3VuZCB3YXRjaFBhdHRlcm4gaW4gY2RrdGYuanNvbjogJHtjZGt0Zkpzb24ud2F0Y2hQYXR0ZXJufWApO1xuICAgIHJldHVybiBjZGt0Zkpzb24ud2F0Y2hQYXR0ZXJuO1xuICB9XG4gIGNvbnN0IGxhbmd1YWdlOlxuICAgIHwgXCJ0eXBlc2NyaXB0XCJcbiAgICB8IFwicHl0aG9uXCJcbiAgICB8IFwiamF2YVwiXG4gICAgfCBcImNzaGFycFwiXG4gICAgfCBcImdvXCJcbiAgICB8IHVuZGVmaW5lZCA9IGNka3RmSnNvbi5sYW5ndWFnZTtcblxuICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgdGhyb3cgRXJyb3JzLlVzYWdlKFxuICAgICAgYE5vIGxhbmd1YWdlIHNwZWNpZmllZCBpbiBjZGt0Zi5qc29uLCBwbGVhc2UgZWl0aGVyIHNwZWNpZnkgYSBsYW5ndWFnZSBvciB3YXRjaFBhdHRlcm4gdG8gdXNlIHRoZSB3YXRjaCBjb21tYW5kYFxuICAgICk7XG4gIH1cblxuICBjb25zdCBkZWZhdWx0V2F0Y2hQYXR0ZXJuID0ge1xuICAgIHR5cGVzY3JpcHQ6IFtcIi4vKiovKi50c1wiXSxcbiAgICBweXRob246IFtcIi4vKiovKi5weVwiXSxcbiAgICBqYXZhOiBbXCJzcmMvKiovKi5qYXZhXCJdLFxuICAgIGNzaGFycDogW1wiLi8qKi8qLmNzXCJdLFxuICAgIGdvOiBbXCIuLyoqLyouZ29cIl0sXG4gIH1bbGFuZ3VhZ2VdO1xuXG4gIGZzLndyaXRlRmlsZVN5bmMoXG4gICAgY2RrdGZKc29uUGF0aCxcbiAgICBKU09OLnN0cmluZ2lmeSh7IC4uLmNka3RmSnNvbiwgd2F0Y2hQYXR0ZXJuOiBkZWZhdWx0V2F0Y2hQYXR0ZXJuIH0sIG51bGwsIDIpXG4gICk7XG4gIGxvZ2dlci5kZWJ1ZyhgV3JpdGUgZGVmYXVsdCB3YXRjaFBhdHRlcm4gZm9yICR7bGFuZ3VhZ2V9IGluIGNka3RmLmpzb24uYCk7XG5cbiAgcmV0dXJuIGRlZmF1bHRXYXRjaFBhdHRlcm47XG59XG5cbmNvbnN0IHByb2plY3RTdGF0dXMgPSAocHJvamVjdD86IENka3RmUHJvamVjdCkgPT4ge1xuICBpZiAoIXByb2plY3Q/LnN0YWNrc1RvUnVuLmxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICBpblByb2dyZXNzOiBbXSxcbiAgICAgIGZpbmlzaGVkOiBbXSxcbiAgICAgIHBlbmRpbmc6IFtdLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBpblByb2dyZXNzID0gcHJvamVjdC5zdGFja3NUb1J1bi5maWx0ZXIoKHMpID0+IHMuaXNSdW5uaW5nKTtcbiAgY29uc3QgZmluaXNoZWQgPSBwcm9qZWN0LnN0YWNrc1RvUnVuLmZpbHRlcigocykgPT4gcy5pc0RvbmUpO1xuICBjb25zdCBwZW5kaW5nID0gcHJvamVjdC5zdGFja3NUb1J1bi5maWx0ZXIoKHMpID0+IHMuaXNQZW5kaW5nKTtcbiAgcmV0dXJuIHsgaW5Qcm9ncmVzcywgZmluaXNoZWQsIHBlbmRpbmcgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFN0YXRlID1cbiAgfCB7XG4gICAgICB0eXBlOiBcIndhaXRpbmdcIjtcbiAgICB9XG4gIHwge1xuICAgICAgdHlwZTogXCJydW5uaW5nXCI7XG4gICAgICBuZXh0UnVuUXVldWVkOiBib29sZWFuO1xuICAgICAgY3VycmVudFJ1bjogUHJvbWlzZTx2b2lkPjtcbiAgICAgIGluUHJvZ3Jlc3M6IENka3RmU3RhY2tbXTtcbiAgICAgIGZpbmlzaGVkOiBDZGt0ZlN0YWNrW107XG4gICAgICBwZW5kaW5nOiBDZGt0ZlN0YWNrW107XG4gICAgfVxuICB8IHsgdHlwZTogXCJzdG9wcGVkXCIgfTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdhdGNoKFxuICBwcm9qZWN0T3B0aW9uczogQ2RrdGZQcm9qZWN0T3B0aW9ucyxcbiAgZXhlY3V0aW9uT3B0aW9uczogRXhlY3V0aW9uT3B0aW9ucyxcbiAgYWJvcnRTaWduYWw6IEFib3J0U2lnbmFsLFxuICBvblN0YXRlQ2hhbmdlOiAobmV3U3RhdGU6IFN0YXRlKSA9PiB2b2lkXG4pIHtcbiAgY29uc3QgcGF0dGVybnMgPSBnZXRPcldyaXRlRGVmYXVsdFdhdGNoQ29uZmlnKCk7XG4gIGNvbnN0IHdhdGNoZXIgPSBjaG9raWRhci53YXRjaChwYXR0ZXJucywge1xuICAgIGlnbm9yZUluaXRpYWw6IHRydWUsXG4gIH0pO1xuICBsZXQgc3RhdGU6IFN0YXRlID0geyB0eXBlOiBcIndhaXRpbmdcIiB9O1xuICBjb25zdCBjaGFuZ2VTdGF0ZSA9IChuZXdTdGF0ZTogU3RhdGUpID0+IHtcbiAgICBzdGF0ZSA9IG5ld1N0YXRlO1xuICAgIG9uU3RhdGVDaGFuZ2Uoc3RhdGUpO1xuICB9O1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHJ1bigpIHtcbiAgICBsb2dnZXIuZGVidWcoXCJSdW5uaW5nIGNka3RmIGRlcGxveVwiKTtcbiAgICBjb25zdCBwcm9qZWN0ID0gbmV3IENka3RmUHJvamVjdCh7XG4gICAgICAuLi5wcm9qZWN0T3B0aW9ucyxcbiAgICAgIG9uTG9nOiAobG9nKSA9PiB7XG4gICAgICAgIGlmIChwcm9qZWN0T3B0aW9ucy5vbkxvZykge1xuICAgICAgICAgIHByb2plY3RPcHRpb25zLm9uTG9nKGxvZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09IFwicnVubmluZ1wiKSB7XG4gICAgICAgICAgY2hhbmdlU3RhdGUoeyAuLi5zdGF0ZSwgLi4ucHJvamVjdFN0YXR1cyhwcm9qZWN0KSB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBhYm9ydCA9ICgpID0+IHByb2plY3QuaGFyZEFib3J0KCk7XG4gICAgYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0KTtcbiAgICBhd2FpdCBwcm9qZWN0LmRlcGxveShleGVjdXRpb25PcHRpb25zKTtcbiAgICBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcImNka3RmIGRlcGxveSBmaW5pc2hlZFwiKTtcblxuICAgIGlmIChzdGF0ZS50eXBlICE9PSBcInJ1bm5pbmdcIikge1xuICAgICAgdGhyb3cgRXJyb3JzLkludGVybmFsKFxuICAgICAgICBcIldhdGNoIHdhcyBpbiBhIHN0YXRlIHdoZXJlIHRoZSBzdGF0ZSB3YXMgbm90IHJ1bm5pbmcgaW4gdGhlIHJ1biBwaGFzZVwiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5uZXh0UnVuUXVldWVkKSB7XG4gICAgICBsb2dnZXIuZGVidWcoXCJOZXh0IHJ1biB3YXMgcXVldWVkLCBzdGFydGluZyBpdCBub3dcIik7XG4gICAgICBjaGFuZ2VTdGF0ZSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBuZXh0UnVuUXVldWVkOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFJ1bjogcnVuKCksXG4gICAgICAgIC4uLnByb2plY3RTdGF0dXMocHJvamVjdCksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiTm90aGluZyBxdWV1ZWQsIHdhaXRpbmcgZm9yIGNoYW5nZXNcIik7XG4gICAgICBjaGFuZ2VTdGF0ZSh7IHR5cGU6IFwid2FpdGluZ1wiIH0pO1xuICAgIH1cbiAgfVxuXG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiQWJvcnQgc2lnbmFsIHJlY2VpdmVkLCBzdG9wcGluZyB3YXRjaFwiKTtcbiAgICB3YXRjaGVyLmNsb3NlKCk7XG4gICAgY2hhbmdlU3RhdGUoeyB0eXBlOiBcInN0b3BwZWRcIiB9KTtcbiAgfSk7XG5cbiAgY29uc3Qgb25GaWxlQ2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChzdGF0ZS50eXBlID09PSBcInN0b3BwZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS50eXBlID09PSBcInJ1bm5pbmdcIikge1xuICAgICAgY2hhbmdlU3RhdGUoeyAuLi5zdGF0ZSwgbmV4dFJ1blF1ZXVlZDogdHJ1ZSB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaGFuZ2VTdGF0ZSh7XG4gICAgICB0eXBlOiBcInJ1bm5pbmdcIixcbiAgICAgIG5leHRSdW5RdWV1ZWQ6IGZhbHNlLFxuICAgICAgY3VycmVudFJ1bjogcnVuKCksXG4gICAgICAuLi5wcm9qZWN0U3RhdHVzKCksXG4gICAgfSk7XG4gIH07XG5cbiAgd2F0Y2hlci5vbihcImFsbFwiLCBvbkZpbGVDaGFuZ2UpO1xuICAvLyBpbml0aWFsbHkgcnVuIG9uY2VcbiAgb25GaWxlQ2hhbmdlKCk7XG59XG4iXX0=