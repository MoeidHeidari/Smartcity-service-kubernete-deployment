"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadFile = exports.HttpError = exports.downcaseFirst = exports.readCDKTFManifest = exports.readCDKTFVersion = exports.exec = exports.mkdtemp = exports.withTempDir = exports.shell = void 0;
const cross_spawn_1 = require("cross-spawn");
const fs = __importStar(require("fs-extra"));
const follow_redirects_1 = require("follow-redirects");
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const logging_1 = require("./logging");
const cdktf_1 = require("cdktf");
const provider_generator_1 = require("@cdktf/provider-generator");
async function shell(program, args = [], options = {}) {
    const stderr = new Array();
    const stdout = new Array();
    try {
        return await exports.exec(program, args, options, (chunk) => {
            stdout.push(chunk.toString());
            console.log(chunk.toString());
        }, (chunk) => stderr.push(chunk));
    }
    catch (e) {
        if (stderr.length > 0) {
            e.stderr = stderr.map((chunk) => chunk.toString()).join("");
        }
        if (stdout.length > 0) {
            e.stdout = stdout.join("");
        }
        throw e;
    }
}
exports.shell = shell;
async function withTempDir(dirname, closure) {
    const prevdir = process.cwd();
    const parent = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
    const workdir = path.join(parent, dirname);
    await fs.mkdirp(workdir);
    try {
        process.chdir(workdir);
        await closure();
    }
    finally {
        process.chdir(prevdir);
        await fs.remove(parent);
    }
}
exports.withTempDir = withTempDir;
async function mkdtemp(closure) {
    const workdir = await fs.mkdtemp(path.join(os.tmpdir(), "cdktf."));
    try {
        await closure(workdir);
    }
    finally {
        await fs.remove(workdir);
    }
}
exports.mkdtemp = mkdtemp;
exports.exec = async (command, args, options, stdout, stderr, sendToStderr = true) => {
    return new Promise((ok, ko) => {
        var _a, _b, _c, _d;
        const child = cross_spawn_1.spawn(command, args, options);
        const out = new Array();
        const err = new Array();
        if (stdout !== undefined) {
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (chunk) => {
                logging_1.processLoggerDebug(chunk);
                out.push(chunk);
                stdout(chunk);
            });
        }
        else {
            (_b = child.stdout) === null || _b === void 0 ? void 0 : _b.on("data", (chunk) => {
                logging_1.processLoggerDebug(chunk);
                out.push(chunk);
            });
        }
        if (stderr !== undefined) {
            (_c = child.stderr) === null || _c === void 0 ? void 0 : _c.on("data", (chunk) => {
                logging_1.processLoggerError(chunk);
                if (sendToStderr) {
                    stderr(chunk);
                }
                err.push(chunk);
            });
        }
        else {
            (_d = child.stderr) === null || _d === void 0 ? void 0 : _d.on("data", (chunk) => {
                logging_1.processLoggerError(chunk);
                if (sendToStderr) {
                    process.stderr.write(chunk);
                }
                err.push(chunk);
            });
        }
        child.once("error", (err) => ko(err));
        child.once("close", (code) => {
            if (code !== 0) {
                const error = new Error(`non-zero exit code ${code}`);
                error.stderr = err.map((chunk) => chunk.toString()).join("");
                return ko(error);
            }
            return ok(Buffer.concat(out).toString("utf-8"));
        });
    });
};
async function readCDKTFVersion(outputDir) {
    const outputFile = path.join(outputDir, "cdk.tf.json");
    if (fs.existsSync(outputFile)) {
        const outputJSON = fs.readFileSync(outputFile, "utf8");
        const data = JSON.parse(outputJSON);
        return data["//"].metadata.version;
    }
    return "";
}
exports.readCDKTFVersion = readCDKTFVersion;
async function readCDKTFManifest() {
    const { output } = provider_generator_1.config.readConfigSync();
    const json = await fs.readFile(path.join(output, cdktf_1.Manifest.fileName));
    return JSON.parse(json.toString());
}
exports.readCDKTFManifest = readCDKTFManifest;
/**
 * Downcase the first character in a string.
 *
 * @param str the string to be processed.
 */
function downcaseFirst(str) {
    if (str === "") {
        return str;
    }
    return `${str[0].toLocaleLowerCase()}${str.slice(1)}`;
}
exports.downcaseFirst = downcaseFirst;
class HttpError extends Error {
    constructor(message, statusCode) {
        super(message); // 'Error' breaks prototype chain here
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain
        // see: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html#support-for-newtarget
    }
}
exports.HttpError = HttpError;
async function downloadFile(url, targetFilename) {
    // if the type is inferred to be "http|https" calling .get() is not possible
    // because the options parameter (which we don't use anyway) for get is
    // not compatible between http and https -> so we treat it as http
    const client = (url.startsWith("http://") ? follow_redirects_1.http : follow_redirects_1.https);
    const file = fs.createWriteStream(targetFilename);
    return new Promise((ok, ko) => {
        const request = client.get(url, (response) => {
            if (response.statusCode !== 200) {
                ko(new HttpError(`Failed to get '${url}' (${response.statusCode})`, response.statusCode));
                return;
            }
            response.pipe(file);
        });
        file.on("finish", () => ok());
        request.on("error", (err) => {
            fs.unlink(targetFilename, () => ko(err));
        });
        file.on("error", (err) => {
            fs.unlink(targetFilename, () => ko(err));
        });
        request.end();
    });
}
exports.downloadFile = downloadFile;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLDZDQUFvQztBQUNwQyw2Q0FBK0I7QUFDL0IsdURBQStDO0FBQy9DLHVDQUF5QjtBQUN6QiwyQ0FBNkI7QUFDN0IsdUNBQW1FO0FBQ25FLGlDQUE0QztBQUM1QyxrRUFBbUQ7QUFFNUMsS0FBSyxVQUFVLEtBQUssQ0FDekIsT0FBZSxFQUNmLE9BQWlCLEVBQUUsRUFDbkIsVUFBd0IsRUFBRTtJQUUxQixNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBdUIsQ0FBQztJQUNoRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO0lBQ25DLElBQUk7UUFDRixPQUFPLE1BQU0sWUFBSSxDQUNmLE9BQU8sRUFDUCxJQUFJLEVBQ0osT0FBTyxFQUNQLENBQUMsS0FBYSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ2hDLENBQUMsRUFDRCxDQUFDLEtBQTBCLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQ25ELENBQUM7S0FDSDtJQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ1YsSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNyQixDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM3RDtRQUNELElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDckIsQ0FBQyxDQUFDLE1B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RSxDQUFDLE1BQU0sQ0FBQyxjQUFjLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDM0MsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ3ZCLEVBQUUsQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzNDLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2hCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQW5DRCxvQ0FtQ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTcGF3bk9wdGlvbnMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgc3Bhd24gfSBmcm9tIFwiY3Jvc3Mtc3Bhd25cIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmcy1leHRyYVwiO1xuaW1wb3J0IHsgaHR0cHMsIGh0dHAgfSBmcm9tIFwiZm9sbG93LXJlZGlyZWN0c1wiO1xuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBwcm9jZXNzTG9nZ2VyRXJyb3IsIHByb2Nlc3NMb2dnZXJEZWJ1ZyB9IGZyb20gXCIuL2xvZ2dpbmdcIjtcbmltcG9ydCB7IElNYW5pZmVzdCwgTWFuaWZlc3QgfSBmcm9tIFwiY2RrdGZcIjtcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gXCJAY2RrdGYvcHJvdmlkZXItZ2VuZXJhdG9yXCI7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaGVsbChcbiAgcHJvZ3JhbTogc3RyaW5nLFxuICBhcmdzOiBzdHJpbmdbXSA9IFtdLFxuICBvcHRpb25zOiBTcGF3bk9wdGlvbnMgPSB7fVxuKSB7XG4gIGNvbnN0IHN0ZGVyciA9IG5ldyBBcnJheTxzdHJpbmcgfCBVaW50OEFycmF5PigpO1xuICBjb25zdCBzdGRvdXQgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBleGVjKFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRpb25zLFxuICAgICAgKGNodW5rOiBCdWZmZXIpID0+IHtcbiAgICAgICAgc3Rkb3V0LnB1c2goY2h1bmsudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNodW5rLnRvU3RyaW5nKCkpO1xuICAgICAgfSxcbiAgICAgIChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4gc3RkZXJyLnB1c2goY2h1bmspXG4gICAgKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChzdGRlcnIubGVuZ3RoID4gMCkge1xuICAgICAgZS5zdGRlcnIgPSBzdGRlcnIubWFwKChjaHVuaykgPT4gY2h1bmsudG9TdHJpbmcoKSkuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaWYgKHN0ZG91dC5sZW5ndGggPiAwKSB7XG4gICAgICBlLnN0ZG91dCA9IHN0ZG91dC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoVGVtcERpcihcbiAgZGlybmFtZTogc3RyaW5nLFxuICBjbG9zdXJlOiAoKSA9PiBQcm9taXNlPHZvaWQ+XG4pIHtcbiAgY29uc3QgcHJldmRpciA9IHByb2Nlc3MuY3dkKCk7XG4gIGNvbnN0IHBhcmVudCA9IGF3YWl0IGZzLm1rZHRlbXAocGF0aC5qb2luKG9zLnRtcGRpcigpLCBcImNka3RmLlwiKSk7XG4gIGNvbnN0IHdvcmtkaXIgPSBwYXRoLmpvaW4ocGFyZW50LCBkaXJuYW1lKTtcbiAgYXdhaXQgZnMubWtkaXJwKHdvcmtkaXIpO1xuICB0cnkge1xuICAgIHByb2Nlc3MuY2hkaXIod29ya2Rpcik7XG4gICAgYXdhaXQgY2xvc3VyZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHByb2Nlc3MuY2hkaXIocHJldmRpcik7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHBhcmVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1rZHRlbXAoY2xvc3VyZTogKGRpcjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+KSB7XG4gIGNvbnN0IHdvcmtkaXIgPSBhd2FpdCBmcy5ta2R0ZW1wKHBhdGguam9pbihvcy50bXBkaXIoKSwgXCJjZGt0Zi5cIikpO1xuICB0cnkge1xuICAgIGF3YWl0IGNsb3N1cmUod29ya2Rpcik7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmVtb3ZlKHdvcmtkaXIpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBleGVjID0gYXN5bmMgKFxuICBjb21tYW5kOiBzdHJpbmcsXG4gIGFyZ3M6IHN0cmluZ1tdLFxuICBvcHRpb25zOiBTcGF3bk9wdGlvbnMsXG4gIHN0ZG91dD86IChjaHVuazogQnVmZmVyKSA9PiBhbnksXG4gIHN0ZGVycj86IChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4gYW55LFxuICBzZW5kVG9TdGRlcnIgPSB0cnVlXG4pOiBQcm9taXNlPHN0cmluZz4gPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBrbykgPT4ge1xuICAgIGNvbnN0IGNoaWxkID0gc3Bhd24oY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG4gICAgY29uc3Qgb3V0ID0gbmV3IEFycmF5PEJ1ZmZlcj4oKTtcbiAgICBjb25zdCBlcnIgPSBuZXcgQXJyYXk8c3RyaW5nIHwgVWludDhBcnJheT4oKTtcbiAgICBpZiAoc3Rkb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaWxkLnN0ZG91dD8ub24oXCJkYXRhXCIsIChjaHVuazogQnVmZmVyKSA9PiB7XG4gICAgICAgIHByb2Nlc3NMb2dnZXJEZWJ1ZyhjaHVuayk7XG4gICAgICAgIG91dC5wdXNoKGNodW5rKTtcbiAgICAgICAgc3Rkb3V0KGNodW5rKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZC5zdGRvdXQ/Lm9uKFwiZGF0YVwiLCAoY2h1bms6IEJ1ZmZlcikgPT4ge1xuICAgICAgICBwcm9jZXNzTG9nZ2VyRGVidWcoY2h1bmspO1xuICAgICAgICBvdXQucHVzaChjaHVuayk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHN0ZGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGlsZC5zdGRlcnI/Lm9uKFwiZGF0YVwiLCAoY2h1bms6IHN0cmluZyB8IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgcHJvY2Vzc0xvZ2dlckVycm9yKGNodW5rKTtcbiAgICAgICAgaWYgKHNlbmRUb1N0ZGVycikge1xuICAgICAgICAgIHN0ZGVycihjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyLnB1c2goY2h1bmspO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkLnN0ZGVycj8ub24oXCJkYXRhXCIsIChjaHVuazogc3RyaW5nIHwgVWludDhBcnJheSkgPT4ge1xuICAgICAgICBwcm9jZXNzTG9nZ2VyRXJyb3IoY2h1bmspO1xuICAgICAgICBpZiAoc2VuZFRvU3RkZXJyKSB7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGVyci5wdXNoKGNodW5rKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjaGlsZC5vbmNlKFwiZXJyb3JcIiwgKGVycjogYW55KSA9PiBrbyhlcnIpKTtcbiAgICBjaGlsZC5vbmNlKFwiY2xvc2VcIiwgKGNvZGU6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYG5vbi16ZXJvIGV4aXQgY29kZSAke2NvZGV9YCk7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLnN0ZGVyciA9IGVyci5tYXAoKGNodW5rKSA9PiBjaHVuay50b1N0cmluZygpKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4ga28oZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9rKEJ1ZmZlci5jb25jYXQob3V0KS50b1N0cmluZyhcInV0Zi04XCIpKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENES1RGVmVyc2lvbihvdXRwdXREaXI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IG91dHB1dEZpbGUgPSBwYXRoLmpvaW4ob3V0cHV0RGlyLCBcImNkay50Zi5qc29uXCIpO1xuICBpZiAoZnMuZXhpc3RzU3luYyhvdXRwdXRGaWxlKSkge1xuICAgIGNvbnN0IG91dHB1dEpTT04gPSBmcy5yZWFkRmlsZVN5bmMob3V0cHV0RmlsZSwgXCJ1dGY4XCIpO1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKG91dHB1dEpTT04pO1xuICAgIHJldHVybiBkYXRhW1wiLy9cIl0ubWV0YWRhdGEudmVyc2lvbjtcbiAgfVxuXG4gIHJldHVybiBcIlwiO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENES1RGTWFuaWZlc3QoKTogUHJvbWlzZTxJTWFuaWZlc3Q+IHtcbiAgY29uc3QgeyBvdXRwdXQgfSA9IGNvbmZpZy5yZWFkQ29uZmlnU3luYygpO1xuICBjb25zdCBqc29uID0gYXdhaXQgZnMucmVhZEZpbGUocGF0aC5qb2luKG91dHB1dCwgTWFuaWZlc3QuZmlsZU5hbWUpKTtcbiAgcmV0dXJuIEpTT04ucGFyc2UoanNvbi50b1N0cmluZygpKSBhcyBJTWFuaWZlc3Q7XG59XG5cbi8qKlxuICogRG93bmNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gYmUgcHJvY2Vzc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZG93bmNhc2VGaXJzdChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBgJHtzdHJbMF0udG9Mb2NhbGVMb3dlckNhc2UoKX0ke3N0ci5zbGljZSgxKX1gO1xufVxuXG5leHBvcnQgY2xhc3MgSHR0cEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCBwdWJsaWMgc3RhdHVzQ29kZT86IG51bWJlcikge1xuICAgIHN1cGVyKG1lc3NhZ2UpOyAvLyAnRXJyb3InIGJyZWFrcyBwcm90b3R5cGUgY2hhaW4gaGVyZVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBuZXcudGFyZ2V0LnByb3RvdHlwZSk7IC8vIHJlc3RvcmUgcHJvdG90eXBlIGNoYWluXG4gICAgLy8gc2VlOiBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi0yLmh0bWwjc3VwcG9ydC1mb3ItbmV3dGFyZ2V0XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShcbiAgdXJsOiBzdHJpbmcsXG4gIHRhcmdldEZpbGVuYW1lOiBzdHJpbmdcbik6IFByb21pc2U8dm9pZD4ge1xuICAvLyBpZiB0aGUgdHlwZSBpcyBpbmZlcnJlZCB0byBiZSBcImh0dHB8aHR0cHNcIiBjYWxsaW5nIC5nZXQoKSBpcyBub3QgcG9zc2libGVcbiAgLy8gYmVjYXVzZSB0aGUgb3B0aW9ucyBwYXJhbWV0ZXIgKHdoaWNoIHdlIGRvbid0IHVzZSBhbnl3YXkpIGZvciBnZXQgaXNcbiAgLy8gbm90IGNvbXBhdGlibGUgYmV0d2VlbiBodHRwIGFuZCBodHRwcyAtPiBzbyB3ZSB0cmVhdCBpdCBhcyBodHRwXG4gIGNvbnN0IGNsaWVudCA9ICh1cmwuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgPyBodHRwIDogaHR0cHMpIGFzIHR5cGVvZiBodHRwO1xuICBjb25zdCBmaWxlID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0odGFyZ2V0RmlsZW5hbWUpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKG9rLCBrbykgPT4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnQuZ2V0KHVybCwgKHJlc3BvbnNlKSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgIGtvKFxuICAgICAgICAgIG5ldyBIdHRwRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGdldCAnJHt1cmx9JyAoJHtyZXNwb25zZS5zdGF0dXNDb2RlfSlgLFxuICAgICAgICAgICAgcmVzcG9uc2Uuc3RhdHVzQ29kZVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2UucGlwZShmaWxlKTtcbiAgICB9KTtcblxuICAgIGZpbGUub24oXCJmaW5pc2hcIiwgKCkgPT4gb2soKSk7XG5cbiAgICByZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgKGVycjogRXJyb3IpID0+IHtcbiAgICAgIGZzLnVubGluayh0YXJnZXRGaWxlbmFtZSwgKCkgPT4ga28oZXJyKSk7XG4gICAgfSk7XG5cbiAgICBmaWxlLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgZnMudW5saW5rKHRhcmdldEZpbGVuYW1lLCAoKSA9PiBrbyhlcnIpKTtcbiAgICB9KTtcblxuICAgIHJlcXVlc3QuZW5kKCk7XG4gIH0pO1xufVxuIl19